<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三洋同学的笔记本</title>
  
  <subtitle>十心十意，脚踏实地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://snayan.github.io/"/>
  <updated>2018-08-19T10:39:14.000Z</updated>
  <id>https://snayan.github.io/</id>
  
  <author>
    <name>三洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>canavs核心技术-如何实现复杂的动画</title>
    <link href="https://snayan.github.io/2018/08/19/canavs%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <id>https://snayan.github.io/2018/08/19/canavs核心技术-如何实现复杂的动画/</id>
    <published>2018-08-19T10:20:34.000Z</published>
    <updated>2018-08-19T10:39:14.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇是学习和回顾canvas系列笔记的第五篇，完整笔记详见：&lt;a href=&quot;https://snayan.github.io/2018/07/09/canvas-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&quot;&gt;canvas核心技术&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;https://snayan.github.io/2018/08/11/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB/&quot;&gt;canvas核心技术-如何实现简单的动画&lt;/a&gt;笔记中，我们详细学习了如何进行canvas坐标系的平移，缩放，旋转等操作来实现一些比较简单和单一的动画。但是在实际动画中，影响一个动画的因素是很多的，比如一个小球自由落体运动，我们不仅要考虑小球的初始速度和初始方向，还要考虑重力加速度，空气阻力等外界因素。这一篇笔记，我们会详细学习复杂动画的相关知识。&lt;/p&gt;
&lt;h4 id=&quot;核心逻辑&quot;&gt;&lt;a href=&quot;#核心逻辑&quot; class=&quot;headerlink&quot; title=&quot;核心逻辑&quot;&gt;&lt;/a&gt;核心逻辑&lt;/h4&gt;&lt;p&gt;我们理解的动画，应该是在一段时间内，物体的某些属性，比如颜色，大小，位置，透明度等，发生改变。判断动画流程度的单位是动画刷新的速率，在浏览器中一般是浏览器的帧速率。帧速率越大，动画就越流畅。在现代浏览器中，我们一般是使用&lt;code&gt;requestAnimationFrame&lt;/code&gt;来执行动画。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; raf = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; lastFrame = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//动画&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;animate&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;frame&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// todo:这里可以执行一些动画更新&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(frame)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  raf = requestAnimationFrame(animate);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  lastFrame = frame;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 一些初始化的操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  init();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 执行动画&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  animate(performance.now());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stop&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  cancelAnimationFrame(raf);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="https://snayan.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas核心技术-如何实现简单的动画</title>
    <link href="https://snayan.github.io/2018/08/11/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB/"/>
    <id>https://snayan.github.io/2018/08/11/canvas核心技术-如何实现简单动画/</id>
    <published>2018-08-11T12:22:18.000Z</published>
    <updated>2018-08-11T03:32:19.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇是学习和回顾canvas系列笔记的第四篇，完整笔记详见：&lt;a href=&quot;https://snayan.github.io/2018/07/09/canvas-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&quot;&gt;canvas核心技术&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在前面几篇中，我们回顾了在canvas中绘制线段，图形，图片等基本功能，当在制作2d游戏或者更为丰富的图表库时，必须提供强大的动画功能。canvas本身不提供像css中&lt;code&gt;animation&lt;/code&gt;属性专门来实现动画，但是canvas提供了&lt;code&gt;translate&lt;/code&gt;，&lt;code&gt;scale&lt;/code&gt;，&lt;code&gt;rotate&lt;/code&gt;等基本功能，我们可以通过组合使用这些功能来实现动画。&lt;/p&gt;
&lt;p&gt;跟动画有关的概念中，我们还要理解&lt;strong&gt;帧速率&lt;/strong&gt;。我们通常说&lt;strong&gt;一帧&lt;/strong&gt;，就是浏览器完整绘制一次所经过的时间。现代浏览器的帧速率一般是60fps，就是在1s内可以绘制60次。如果帧速率过低，就会觉得明显的卡顿了。一般是帧速率越高，动画越流畅。在JavaScript中，我们要在1s内绘制60次，以前的做法是使用&lt;code&gt;setTimeout&lt;/code&gt;或者&lt;code&gt;setInterval&lt;/code&gt;来定时执行。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;setInterval(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 执行绘制操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="https://snayan.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas核心技术-如何绘制图片和文本</title>
    <link href="https://snayan.github.io/2018/07/27/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E5%92%8C%E6%96%87%E6%9C%AC/"/>
    <id>https://snayan.github.io/2018/07/27/canvas核心技术-如何绘制图片和文本/</id>
    <published>2018-07-27T00:36:58.000Z</published>
    <updated>2018-07-27T00:50:28.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇是学习和回顾canvas系列笔记的第三篇，完整笔记详见：&lt;a href=&quot;https://snayan.github.io/2018/07/09/canvas-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&quot;&gt;canvas 核心技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过上一篇&lt;a href=&quot;https://snayan.github.io/2018/07/18/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2/&quot;&gt;canvas核心技术-如何绘制图形&lt;/a&gt;的学习，我们知道了如何绘制任意多边形以及图片的填充规则。在canvas中应用比较多的还有绘制图片和文本。这篇文章，我们就来详细聊聊图片和文本的绘制。&lt;/p&gt;
&lt;h4 id=&quot;图片&quot;&gt;&lt;a href=&quot;#图片&quot; class=&quot;headerlink&quot; title=&quot;图片&quot;&gt;&lt;/a&gt;图片&lt;/h4&gt;&lt;p&gt;在canvas中，我们可以把一张图片直接绘制到canvas上，跟使用&lt;code&gt;img&lt;/code&gt;标签类似，不同的是，图片是绘制到canvas画布上的，而非独立的html元素。canvas提供了&lt;code&gt;drawImage&lt;/code&gt;方法来绘制图片，这个方法可以有三种形式的用法，如下，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void drawImage(image,dx,dy);&lt;/code&gt;直接将图片绘制到指定的canvas坐标上，图片由image传入，坐标由dx和dy传入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void drawImage(image,dx,dy,dw,dh);&lt;/code&gt;同上面形式，只不过指定了图片绘制的宽度和高度，宽高由dw和dh传入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);&lt;/code&gt;这个是最复杂，最灵活的使用形式，第一参数是待绘制的图片元素，第二个到第五个参数，指定了原图片上的坐标和宽高，这部分区域将会被绘制到canvas中，而其他区域将忽略，最后四个参数跟形式二一样，指定了canvas目标中的坐标和宽高。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="https://snayan.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas核心技术-如何绘制图形</title>
    <link href="https://snayan.github.io/2018/07/18/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2/"/>
    <id>https://snayan.github.io/2018/07/18/canvas核心技术-如何绘制图形/</id>
    <published>2018-07-18T00:58:15.000Z</published>
    <updated>2018-07-18T01:17:56.592Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇学习和回顾canvas系列笔记的第二篇，完整笔记详见：&lt;a href=&quot;https://snayan.github.io/2018/07/09/canvas-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&quot;&gt;canvas核心技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过上一篇&lt;a href=&quot;https://snayan.github.io/2018/07/09/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E7%BA%BF%E6%AE%B5/&quot;&gt;canvas核心技术-如何绘制线段&lt;/a&gt;的学习，我们知道了如何去绘制线段。很多的线段的拼接就组成了图形了，比如常见的三角形，矩形，圆形等。&lt;/p&gt;
&lt;p&gt;常见图形的绘制可以查看我的在线示例：&lt;a href=&quot;https://snayan.github.io/canvas-demo/?module=shape&quot;&gt;canvas shape&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例项目仓库地址：&lt;a href=&quot;https://github.com/snayan/canvas-demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;canvas demo&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;图形&quot;&gt;&lt;a href=&quot;#图形&quot; class=&quot;headerlink&quot; title=&quot;图形&quot;&gt;&lt;/a&gt;图形&lt;/h4&gt;&lt;h5 id=&quot;三角形&quot;&gt;&lt;a href=&quot;#三角形&quot; class=&quot;headerlink&quot; title=&quot;三角形&quot;&gt;&lt;/a&gt;三角形&lt;/h5&gt;&lt;p&gt;先来看看如何绘制一个三角形。三角形就是由三条边组成，我们可以理解为三个线段组成。确定了三角形的三个顶点的坐标位置，然后用线连接起来。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; point1 = [&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//顶底1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; point2 = [&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//顶点2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; point3 = [&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;120&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//顶点3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.beginPath(); &lt;span class=&quot;comment&quot;&gt;//开始一段新路径&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.moveTo(point1[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], point1[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;//移动起点到顶点1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.lineTo(point2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], point2[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;//连接顶点1与顶点2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.lineTo(point3[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], point3[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;//连接顶点2与顶点3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.stroke(); &lt;span class=&quot;comment&quot;&gt;//描边&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//绘制顶点坐标显示出来&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.textAlign=&lt;span class=&quot;string&quot;&gt;&#39;center&#39;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//绘制文本水平居中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.fillText(&lt;span class=&quot;string&quot;&gt;`(&lt;span class=&quot;subst&quot;&gt;$&amp;#123;point1[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&amp;#125;&lt;/span&gt;,&lt;span class=&quot;subst&quot;&gt;$&amp;#123;point1[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;#125;&lt;/span&gt;)`&lt;/span&gt;, point1[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], point1[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-10&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//绘制顶点1文本&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.fillText(&lt;span class=&quot;string&quot;&gt;`(&lt;span class=&quot;subst&quot;&gt;$&amp;#123;point2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&amp;#125;&lt;/span&gt;,&lt;span class=&quot;subst&quot;&gt;$&amp;#123;point2[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;#125;&lt;/span&gt;)`&lt;/span&gt;, point2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-25&lt;/span&gt;, point2[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//绘制顶点2文本&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ctx.fillText(&lt;span class=&quot;string&quot;&gt;`(&lt;span class=&quot;subst&quot;&gt;$&amp;#123;point3[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&amp;#125;&lt;/span&gt;,&lt;span class=&quot;subst&quot;&gt;$&amp;#123;point3[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;#125;&lt;/span&gt;)`&lt;/span&gt;, point3[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, point3[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//绘制顶点3文本&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="https://snayan.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas核心技术-如何绘制线段</title>
    <link href="https://snayan.github.io/2018/07/09/canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E7%BA%BF%E6%AE%B5/"/>
    <id>https://snayan.github.io/2018/07/09/canvas核心技术-如何绘制线段/</id>
    <published>2018-07-09T12:16:12.000Z</published>
    <updated>2018-07-18T01:24:42.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇是学习和回顾canvas系列笔记的第一篇，完整笔记详见：&lt;a href=&quot;https://snayan.github.io/2018/07/09/canvas-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&quot;&gt;canvas核心技术&lt;/a&gt;&lt;br&gt;学习canvas，首先得知道如何去绘制线段，然后才能通过很多简单的线段去实现比较复杂的图形，比如常见的图表，柱状图，折线图等都是通过一段一段的线段实现的。&lt;/p&gt;
&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;canvas 的基础知识不算多，主要掌握如何绘制线段，图形，图片，文本等。canvas可以在浏览器中绘制，也可以借助 &lt;a href=&quot;https://github.com/Automattic/node-canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-canvas&lt;/a&gt;在node服务端绘制简单的图片。本文只记录在浏览器中绘制，至于在node端如何绘制，自己可以去查看相关资料。&lt;/p&gt;
&lt;p&gt;在浏览器中绘制，就先在html中定义canvas元素，默认宽高是300 * 150，可以通过&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;设置。注意canvas元素样式宽高和canvas绘图画布宽高不是一个东西，详见&lt;em&gt;知识点5中canvas宽高&lt;/em&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;canvas&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;canvas&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;当前浏览器不支持canvas，请升级浏览器&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="https://snayan.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas核心技术</title>
    <link href="https://snayan.github.io/2018/07/09/canvas-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://snayan.github.io/2018/07/09/canvas-核心技术/</id>
    <published>2018-07-09T11:53:41.000Z</published>
    <updated>2018-07-18T01:18:21.737Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目需求中要写较多H5小游戏，游戏本身体量不是很复杂，主要是承载较多业务逻辑，所以决定用canvas来完成游戏部分。之前只是知道H5中有canvas这个东西，也知道它大概是画图的，但具体怎么用，还是一无所知的。在&lt;a href=&quot;https://developer.mo
      
    
    </summary>
    
    
      <category term="canvas" scheme="https://snayan.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>webpack构建常见流程</title>
    <link href="https://snayan.github.io/2018/06/27/%E5%B8%B8%E8%A7%81webpack%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B/"/>
    <id>https://snayan.github.io/2018/06/27/常见webpack构建项目流程/</id>
    <published>2018-06-27T08:03:05.000Z</published>
    <updated>2018-06-27T08:22:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;现在前端项目的构建一般基本都是基于webpack的。项目的技术栈目前比较主流的是react全家桶和vue全家桶。&lt;br&gt;趁空闲，以公司一个项目整理了webpack构建常见的流程,这个项目是使用vue全家桶开发的。&lt;/p&gt;
&lt;h5 id=&quot;技术栈：&quot;&gt;&lt;a href=&quot;#技术栈：&quot; class=&quot;headerlink&quot; title=&quot;技术栈：&quot;&gt;&lt;/a&gt;技术栈：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;vue&lt;/li&gt;
&lt;li&gt;typescript&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;浏览器支持：&quot;&gt;&lt;a href=&quot;#浏览器支持：&quot; class=&quot;headerlink&quot; title=&quot;浏览器支持：&quot;&gt;&lt;/a&gt;浏览器支持：&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&quot;browserslist&quot;: [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;&amp;gt; 1%&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;last 2 versions&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;not ie &amp;lt;= 9&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;Android &amp;gt;= 4.3&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="https://snayan.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue 全家桶初探</title>
    <link href="https://snayan.github.io/2018/06/15/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%88%9D%E6%8E%A2/"/>
    <id>https://snayan.github.io/2018/06/15/vue-全家桶初探/</id>
    <published>2018-06-15T01:51:44.000Z</published>
    <updated>2018-06-27T08:01:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;这个项目主要是用vue+vuex实现一个单页面应用，纯粹是熟悉vue全家桶相关开发模式，用于练手非常合适。&lt;br&gt;着手开发完了之后可以学的东西：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉vue单文件组件开发方式&lt;/li&gt;
&lt;li&gt;熟悉如何写一个vue插件&lt;/li&gt;
&lt;li&gt;熟悉如何使用vue-router以及挂载路由钩子函数&lt;/li&gt;
&lt;li&gt;熟悉vuex是如何运作的，模块化维护应用状态数据&lt;/li&gt;
&lt;li&gt;体验typescript的开发方式&lt;br&gt;如果想学vue的不妨进来看看。&lt;br&gt;项目源码地址：&lt;a href=&quot;https://github.com/snayan/vue-task&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;技术栈&quot;&gt;&lt;a href=&quot;#技术栈&quot; class=&quot;headerlink&quot; title=&quot;技术栈&quot;&gt;&lt;/a&gt;技术栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vue&lt;/li&gt;
&lt;li&gt;vuex&lt;/li&gt;
&lt;li&gt;vue-router&lt;/li&gt;
&lt;li&gt;typescript&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://snayan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react 16学习(四)</title>
    <link href="https://snayan.github.io/2018/04/11/react16%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A04/"/>
    <id>https://snayan.github.io/2018/04/11/react16源码学习4/</id>
    <published>2018-04-11T01:48:07.000Z</published>
    <updated>2018-04-11T01:54:20.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;React中比较重要的就是”React elements”了，可以理解为页面中可看到的节点元素。&lt;/p&gt;
&lt;h3 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h3&gt;&lt;p&gt;一个”React element”的结构为下面这样，&lt;br&gt;&lt;img src=&quot;/assert/img/react_element.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://snayan.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react 16学习(三)</title>
    <link href="https://snayan.github.io/2018/04/04/react16%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A03/"/>
    <id>https://snayan.github.io/2018/04/04/react16源码学习3/</id>
    <published>2018-04-04T01:11:45.000Z</published>
    <updated>2018-04-04T01:15:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;ReactDom在16版本中也新增了一些新的功能，比如&lt;strong&gt;createPortal&lt;/strong&gt;，&lt;strong&gt;hydrate&lt;/strong&gt;。今天主要学习一下&lt;strong&gt;createPortal&lt;/strong&gt;。&lt;br&gt;先看下ReactDom的大致包含的一些属性和方法。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ReactDom = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  createPortal,&lt;span class=&quot;comment&quot;&gt;//reacte16中新增的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  hydrate,&lt;span class=&quot;comment&quot;&gt;//reacte16中新增的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  findDomNode,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  render,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  unmountComponentAtNode,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  flushSync,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  unstable_renderSubtreeIntoContainer,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  unstable_createPortal, &lt;span class=&quot;comment&quot;&gt;//这个实际就是现在的createPortal,将在React17版本中移除&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  unstable_batchedUpdates,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  unstable_deferredUpdates,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  unstable_flushControlled&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到我们熟悉的&lt;code&gt;findDomNode&lt;/code&gt;，&lt;code&gt;render&lt;/code&gt;，&lt;code&gt;unmountComponentAtNode&lt;/code&gt;。这里面新增了两个新的方法&lt;code&gt;createPortal&lt;/code&gt;和&lt;code&gt;hydrate&lt;/code&gt;。以unstable_开头的表示的是当前版本中存在的方法，但可能会在后续版本中改动或移除，所以不建议使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://snayan.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 16学习(二)</title>
    <link href="https://snayan.github.io/2018/03/02/react16%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A02/"/>
    <id>https://snayan.github.io/2018/03/02/react16源码学习2/</id>
    <published>2018-03-02T13:05:48.000Z</published>
    <updated>2018-04-04T01:08:59.709Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上篇大致说了react16的结构，今天来看看react16中新增的Fragment。&lt;/p&gt;
&lt;p&gt;react16中新增的可以渲染的类型：fragments和strings。&lt;/p&gt;
&lt;h3 id=&quot;Fragments&quot;&gt;&lt;a href=&quot;#Fragments&quot; class=&quot;headerlink&quot; title=&quot;Fragments&quot;&gt;&lt;/a&gt;Fragments&lt;/h3&gt;&lt;p&gt;在react16中，component的render方法现在可以返回一个数组了，而在react16之前只能返回一个ReactElement，一般被&lt;code&gt;div&lt;/code&gt;包裹着。在实际使用时，页面会输出一些很多没有用处的&lt;code&gt;div&lt;/code&gt;，增加了dom结构的嵌套层数，不利于页面快速的渲染。&lt;/p&gt;
&lt;h5 id=&quot;react16之前&quot;&gt;&lt;a href=&quot;#react16之前&quot; class=&quot;headerlink&quot; title=&quot;react16之前&quot;&gt;&lt;/a&gt;react16之前&lt;/h5&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Demo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;[1, 2, 3].map(v =&amp;gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;v&amp;#125;&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;`链接$&amp;#123;v&amp;#125;`&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;)&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://snayan.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 16学习(-)</title>
    <link href="https://snayan.github.io/2018/03/01/react16%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A01/"/>
    <id>https://snayan.github.io/2018/03/01/react16源码学习1/</id>
    <published>2018-03-01T12:11:21.000Z</published>
    <updated>2018-04-04T01:08:59.709Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;趁着离职期这段时间，制定了一个计划，再次阅读React16的源码，React16是一个大版本的更新，其中新增了许多的新特性，并且重写了核心模块的架构，叫做&lt;strong&gt;Fiber&lt;/strong&gt;，最令人兴奋的是&lt;strong&gt;async rendering&lt;/strong&gt;。之前也浅显的阅读过React15的部分源码，发现这次React16与之有很大的不同。&lt;/p&gt;
&lt;h3 id=&quot;核心文件&quot;&gt;&lt;a href=&quot;#核心文件&quot; class=&quot;headerlink&quot; title=&quot;核心文件&quot;&gt;&lt;/a&gt;核心文件&lt;/h3&gt;&lt;p&gt;React16真的是重新梳理了代码结构，并且解耦了很多，下面为React16的文件结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assert/img/react16_file_structure.jpg&quot; alt=&quot;react16的文件结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们熟悉的react和react-dom。react-art是绘制图形的，比如Canvas，SVG，VML。react-call-return是一个试验性的，用于react中的多遍渲染。react-reconciler是Fiber的实现。share中存放着一些公用的方法和属性。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://snayan.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>简单的五子棋</title>
    <link href="https://snayan.github.io/2018/01/23/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%94%E5%AD%90%E6%A3%8B/"/>
    <id>https://snayan.github.io/2018/01/23/简单的五子棋/</id>
    <published>2018-01-23T09:14:43.000Z</published>
    <updated>2018-03-28T13:57:53.484Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在某次求职过程中，收到了一个笔试题，要求写一个人机对战的五子棋，题目要求如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  请编写一个单机【五子棋】游戏，要求如下：&lt;br&gt;  使用原生技术实现，兼容 Chrome 浏览器即可。&lt;br&gt;  实现胜负判断，并给出赢棋提示；任意玩家赢得棋局，锁定棋盘。&lt;br&gt;  请尽可能的考虑游戏的扩展性，界面可以使用 DOM / Canvas 实现。考虑后续切换界面实现的方式成本最低。（比如选择使用 DOM 实现界面，需求改变为使用 Canvas 实现时尽可能少的改动代码）。&lt;br&gt;  实现一个悔棋功能&lt;br&gt;  实现一个撤销悔棋功能&lt;br&gt;  实现一个人机对战功能&lt;br&gt;  尽可能的考虑实现的灵活性和扩展性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自己收到这个题目之后感觉有点棘手，自己没有开发过游戏，时间也比较紧。下班之后就开始弄了，简单介绍下自己的实现过程。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://snayan.github.io/tags/javascript/"/>
    
      <category term="五子棋" scheme="https://snayan.github.io/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/"/>
    
  </entry>
  
  <entry>
    <title>2017年小结</title>
    <link href="https://snayan.github.io/2017/12/14/2017%E5%B0%8F%E7%BB%93/"/>
    <id>https://snayan.github.io/2017/12/14/2017小结/</id>
    <published>2017-12-14T15:10:35.000Z</published>
    <updated>2018-03-28T13:57:53.482Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嗯，又到了年末，是时候对17年做个了断，好好开始18年。&lt;br&gt;17年的年初计划是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找一家靠谱的互联网公司&lt;/li&gt;
&lt;li&gt;阅读12本书&lt;/li&gt;
&lt;li&gt;报个英语培训班&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;找一家靠谱的互联网公司&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="2017" scheme="https://snayan.github.io/tags/2017/"/>
    
      <category term="小结" scheme="https://snayan.github.io/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>笔记之decorator</title>
    <link href="https://snayan.github.io/2017/11/26/%E7%AC%94%E8%AE%B0%E4%B9%8Bdecorator/"/>
    <id>https://snayan.github.io/2017/11/26/笔记之decorator/</id>
    <published>2017-11-26T14:30:33.000Z</published>
    <updated>2018-03-28T13:57:53.484Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近一个月都在忙公司的新项目&lt;strong&gt;会过精选&lt;/strong&gt;，加上双11大促，真的是很忙。加上最近的烦心事比较多，心情一直不是很好，做什么事情，都效率低下。收拾收拾心情，继续努力吧。一切都不会那么糟糕。&lt;br&gt;在做会过精选M站时，我们前端组选型的技术栈是React,Redux,TypeScript。一直都知道 decorator这个东西，但之前在卷皮没有机会用，现在在会过，我就高高兴兴的开始用起来了。&lt;br&gt;装饰者的功能实际就是在不改原功能的前提下，对原目标进行额外功能的增强，比如：日志记录，缓存，访问控制等。&lt;/p&gt;
&lt;h3 id=&quot;对类进行装饰&quot;&gt;&lt;a href=&quot;#对类进行装饰&quot; class=&quot;headerlink&quot; title=&quot;对类进行装饰&quot;&gt;&lt;/a&gt;对类进行装饰&lt;/h3&gt;&lt;p&gt;decorator可以作用在类上，达到对类的属性或者原型进行改造。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//定义这个页面是需要登陆权限的页面&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@needPageLogin&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OpenCoupons&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;OpenCouponsProps&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;ComponentState&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://snayan.github.io/tags/javascript/"/>
    
      <category term="decorator" scheme="https://snayan.github.io/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>小程序组件化编程</title>
    <link href="https://snayan.github.io/2017/09/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    <id>https://snayan.github.io/2017/09/17/小程序组件化编程/</id>
    <published>2017-09-17T14:24:28.000Z</published>
    <updated>2018-03-28T13:57:53.484Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在开发微信小程序时，发现缺少了组件化开发体验，在网上找了一波资源，发现都不是很好。其中，有用开发Vue的方式去开发小程序，比如，WePY，最后将源代码编译成小程序的官方文件模式。这种方式，开发感觉爽，但是如果小程序版本升级变了之后，不在支持这种方式，那么就得重新开发一套小程序官方支持的代码了，成本代价很大。并且，这次项目时间非常紧，团队成员不熟悉vue的情况下，不敢用WePY。但是，小程序官方又对组件化支持不是很友好。于是，决定自己弄一套，既有组件化开发体验，又是最大限度的接近小程序官方的开发模式。&lt;/p&gt;
&lt;p&gt;目前项目已经成功上线，小程序：会过精选&lt;br&gt;&lt;a href=&quot;https://github.com/snayan/weChart-component&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码地址以及实例地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一步，改写Page&quot;&gt;&lt;a href=&quot;#第一步，改写Page&quot; class=&quot;headerlink&quot; title=&quot;第一步，改写Page&quot;&gt;&lt;/a&gt;第一步，改写Page&lt;/h3&gt;&lt;p&gt;由于小程序的页面定义是通过&lt;code&gt;Page&lt;/code&gt;方法去定义的，那么，&lt;code&gt;Page&lt;/code&gt;一定在小程序内可以认为是一个全局变量，我只需要改写&lt;code&gt;Page&lt;/code&gt;这个方法，去可以引用组件，调用组件，触发组件的生命周期方法，维持组件内部的数据状态，那么，是不是就可以接近了组件化的编程体验了，并且可以抽离常用组件，达到复用的目的。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//先保存原Page&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; nativePage = Page;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 自定义Page */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Page = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//...改写Page逻辑，增加自己的功能&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//最后一定得调用原Page方法，不然，小程序页面无法生成&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  nativePage(c);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://snayan.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>移动端布局方案浅谈</title>
    <link href="https://snayan.github.io/2017/07/31/mobile-layout/"/>
    <id>https://snayan.github.io/2017/07/31/mobile-layout/</id>
    <published>2017-07-31T14:23:19.000Z</published>
    <updated>2018-03-28T13:57:53.482Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一直想抽时间总结一下现在业界可用的移动端布局方案。需求多，995模式，身心被掏空，一拖再拖，终于在周六的晚上，做着梦弄完成的，不足之道😪，请指教改正🤠。&lt;/p&gt;
&lt;h3 id=&quot;media-百分比&quot;&gt;&lt;a href=&quot;#media-百分比&quot; class=&quot;headerlink&quot; title=&quot;media+百分比&quot;&gt;&lt;/a&gt;media+百分比&lt;/h3&gt;&lt;p&gt;直接采用媒体查询加百分比去布局。&lt;br&gt;核心思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面主体布局基本采用百分比去设置。&lt;/li&gt;
&lt;li&gt;然后，其他块内布局,例如font-size等可通过设置媒体查询的断点来分设置，已达到兼容其他手机尺寸。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mobile" scheme="https://snayan.github.io/tags/mobile/"/>
    
      <category term="h5" scheme="https://snayan.github.io/tags/h5/"/>
    
  </entry>
  
  <entry>
    <title>响应式图片加载</title>
    <link href="https://snayan.github.io/2017/07/24/img_srcset_seizes/"/>
    <id>https://snayan.github.io/2017/07/24/img_srcset_seizes/</id>
    <published>2017-07-24T14:08:34.000Z</published>
    <updated>2018-03-28T13:57:53.482Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在做响应式图片加载需要使用到的两个关键属性就是&lt;code&gt;srcset&lt;/code&gt;和&lt;code&gt;sizes&lt;/code&gt; ，这两个属性是H5中新加的，是给img标签提供多个不同尺寸的图片，在不同设备，不同分辨率的情况下加载不同的图片。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据屏幕分辨率选择&lt;br&gt;当只需要根据屏幕分辨率去选择不同的图片的时候，有2种情况。&lt;br&gt;第1种，语法形式为：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;srcset=&quot;[url] [dpr]x,[url] [dpr]x,....etc&quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般屏幕的分辨率会到3倍，例如iphone6plus，其dpr=3，这种是直接给出每种图片的分辨率规格，例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./mm-width-128px.jpg&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;alt&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;示例图片&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;srcset&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./mm-width-256px.jpg 2x,./mm-width-512px.jpg 3x&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的示例表示，在dpr=1的屏幕下加载128px这张图片；在1&amp;lt;dpr&amp;lt;=2时，加载256px这张图片；当dpr&amp;gt;2时就加载512px这张图片了。&lt;br&gt;注意，srcset里的&lt;strong&gt;x&lt;/strong&gt;一定要是小写，大写的话，chrome会无法识别。&lt;br&gt;&lt;a href=&quot;https://webkit.org/demos/srcset/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查看demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="resposive" scheme="https://snayan.github.io/tags/resposive/"/>
    
      <category term="mobile" scheme="https://snayan.github.io/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title>javascript中ToPrimitive详解</title>
    <link href="https://snayan.github.io/2017/07/06/javascript%E4%B8%ADToPrimitive%E8%AF%A6%E8%A7%A3/"/>
    <id>https://snayan.github.io/2017/07/06/javascript中ToPrimitive详解/</id>
    <published>2017-07-06T15:36:19.000Z</published>
    <updated>2018-03-28T13:57:53.482Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;看了这么多框架方面的东西，但注意，基础很重要。今天就来说说javascipt中容易忽略的类型转换问题。&lt;br&gt;在javascript中有7种基本类型，它们为：string，number，boolean，undefined，null，symbol，object。判断类型的方式是&lt;code&gt;typeof&lt;/code&gt;。我们把string，number，boolean，undefined，null，symbol这几类称为原始类型。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//&#39;number&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;aa&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//&#39;string&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//&#39;boolean&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;() &lt;span class=&quot;comment&quot;&gt;//&#39;symbol&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//&#39;undefined&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//&#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;//&#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;//&#39;function&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意两点，一是，对于函数，实际上也可以认为是object，但使用typeof得到的结果是’function’；二是，对于null，typeof得到的结果是’object’。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://snayan.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>react组件生命周期浅谈</title>
    <link href="https://snayan.github.io/2017/06/19/react-component-life-cycle/"/>
    <id>https://snayan.github.io/2017/06/19/react-component-life-cycle/</id>
    <published>2017-06-19T15:25:17.000Z</published>
    <updated>2018-03-28T13:57:53.483Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，react的组件是有一个个的钩子函数，构建成的生命周期，在用es6的class与用createClass有所不同，其中createClass还包括了&lt;code&gt;getDefaultProps&lt;/code&gt;与&lt;code&gt;getInitialState&lt;/code&gt;。由于createClass 将在后续版本中移除，建议使用class形式。所以，下面讨论的都是class形式下的生命周期方式。&lt;/p&gt;
&lt;h3 id=&quot;初始阶段&quot;&gt;&lt;a href=&quot;#初始阶段&quot; class=&quot;headerlink&quot; title=&quot;初始阶段&quot;&gt;&lt;/a&gt;初始阶段&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;constructor ，构造函数，在初始化实例时首先触发&lt;/li&gt;
&lt;li&gt;componentWillMount，组件将渲染出来之前触发，可以调用setState，简单的合并state，不会触发render重新渲染&lt;/li&gt;
&lt;li&gt;render ，将组件渲染，不可以调用setState&lt;/li&gt;
&lt;li&gt;componentDidMount，组件渲染之后触发，可以调用setState，会重新触发render&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://snayan.github.io/tags/react/"/>
    
  </entry>
  
</feed>
