{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","ableZan":true,"menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"8617040a-0bde-59b9-b446-f495b18769cc","excerpt":"React 从 v16.0.0 开始，实现了异步渲染模式（Concurrency Mode），解决了之前 Stack Reconciler…","html":"<p>React 从 v16.0.0 开始，实现了异步渲染模式（Concurrency Mode），解决了之前 Stack Reconciler 采用同步更新的问题。异步渲染，实际上就是将一个大的渲染任务，分成很多个小的任务，每个任务执行完就交出主线程，使得其他线程可以处理其他事情（比如渲染，响应用户点击等）。最常见的实现方式就是使用<code class=\"language-text\">setTimeout</code>将这些小任务加到事件队列（event queue）里，利用浏览器的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">event loop</a> 来异步执行。本篇是 React Time Slice 系列中的第一篇，深入分析 React v16.0.0 是如何实现 requestIdleCallback polyfill。</p>\n<p>为了尽可能地提高渲染性能，React 希望这些小的任务可以在浏览器空闲时间去执行。浏览器提供了<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\">requestIdleCallback</a>来保证可以在空闲时间执行一些操作。但是它有兼容性问题，对于不支持 rIC 的浏览器，React 团队使用<code class=\"language-text\">requestAnimationFrame</code>和<code class=\"language-text\">postMessage</code>来实现，并且是自动调节<code class=\"language-text\">frame rate</code>的。下面是它的实现逻辑，</p>\n<p>首先定义特殊的 message 事件，并监听<code class=\"language-text\">message</code>事件，</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 定义message 事件名</span>\n<span class=\"token keyword\">var</span> messageKey <span class=\"token operator\">=</span>\n  <span class=\"token string\">\"__reactIdleCallback$\"</span> <span class=\"token operator\">+</span>\n  Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 监听message</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> idleTick<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对于 rIC 的实现，使用 rAF 来保证在下一帧触发</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function-variable function\">rIC</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 先是存储callback</span>\n  scheduledRICCallback <span class=\"token operator\">=</span> callback\n  <span class=\"token comment\">// 判断是否正在rAF调度</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isAnimationFrameScheduled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    isAnimationFrameScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>animationTick<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>先将需要执行的<code class=\"language-text\">callback</code>保存起来，接着触发 rAF。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">animationTick</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">rafTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  isAnimationFrameScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isIdleScheduled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    isIdleScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span>messageKey<span class=\"token punctuation\">,</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 rAF 触发函数里，调用<code class=\"language-text\">postMessage</code>，触发 message 事件。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">idleTick</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 检查是否内部触发的message，</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>source <span class=\"token operator\">!==</span> window <span class=\"token operator\">||</span> event<span class=\"token punctuation\">.</span>data <span class=\"token operator\">!==</span> messageKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  isIdleScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token comment\">// 获取之前存的callback</span>\n  <span class=\"token keyword\">var</span> callback <span class=\"token operator\">=</span> scheduledRICCallback\n  scheduledRICCallback <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>callback <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 真正执行callback</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>frameDeadlineObject<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 message 事件里，才是真正执行<code class=\"language-text\">callback</code>。看完它的实现，有几个疑惑，</p>\n<ol>\n<li>为什么不直接要用 rAF？</li>\n<li>为什么不直接使用<code class=\"language-text\">postMessage</code>？</li>\n<li>为什么不使用<code class=\"language-text\">setTimeout</code>?</li>\n</ol>\n\n        <h2 id='toc-2-1' >\n          如果用 rAF 实现\n        </h2>\n      \n<p>我们知道 rIC 的触发时机是，如果在一帧里有剩余时间，则在当前帧的结尾处触发 rIC，或者是当前页面没有更新，是处于空闲的状态，也会触发 rIC。rAF 的触发时机是，在一帧的开头。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cea3fea54fb577ee83f2ef85ecab0683/60142/frame.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 43.23570432357043%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABC0lEQVQoz5VRXU/CMBTt/38wMajRhAf1V/hiMk3MNCA4o0HGCGCBbNgWx1Ym0nvrZrvGB4Px5qQ5uR+nvadEKaX/EwDgRgjnfFcvYgXtoKWUjDE7jIiAdb0Kc34nq3StUOu4hpKQnbd+yjSU6QC2VKuphqnWM1QU1IepE8qLdsSfaRYlRTBa9mbZw0h0ItYaiJfXeHHbnFzsJVeHeacpbk4SryGD8znn98NlKjdk/Fb4fRZMVr35uj0UjzQrte5C5vf50zjOumfMO1h4jVXrmF8fxZf7sntKmfBD8Z5vCAJos21JrD3u2eXieemR1mtEaQlIUNsfhgFYkywBE0bQArXjzk/y17/ib7DxBUTXBOA1TRKsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/cea3fea54fb577ee83f2ef85ecab0683/cc182/frame.webp 148w,\n/static/cea3fea54fb577ee83f2ef85ecab0683/f7e40/frame.webp 295w,\n/static/cea3fea54fb577ee83f2ef85ecab0683/1a2f4/frame.webp 590w,\n/static/cea3fea54fb577ee83f2ef85ecab0683/92382/frame.webp 717w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/cea3fea54fb577ee83f2ef85ecab0683/cf440/frame.png 148w,\n/static/cea3fea54fb577ee83f2ef85ecab0683/d2d38/frame.png 295w,\n/static/cea3fea54fb577ee83f2ef85ecab0683/b9e4f/frame.png 590w,\n/static/cea3fea54fb577ee83f2ef85ecab0683/60142/frame.png 717w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/cea3fea54fb577ee83f2ef85ecab0683/b9e4f/frame.png\"\n          alt=\"A typical frame\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>如果直接使用 rAF，Fiber tree 的更新操作会在 rAF 里执行，整体增加了当前帧完成所需的时间，会导致帧率下降。</p>\n\n        <h2 id='toc-2-2' >\n          如果用 postMessage 实现\n        </h2>\n      \n<p><code class=\"language-text\">postMessage</code>的常用使用场景是，不同域的父子页面(使用 iframe)之间通信，至于具体使用方式，可以自己查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">MDN 文档</a>。但在这里，它的用途并不涉及跨域通信，仅仅是异步调用。如果只是使用<code class=\"language-text\">postMessage</code>，实现代码大致如下，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> scheduledRICCallback <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"token keyword\">var</span> isIdleScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> idleTick<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">idleTick</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>source <span class=\"token operator\">!==</span> window <span class=\"token operator\">||</span> event<span class=\"token punctuation\">.</span>data <span class=\"token operator\">!==</span> messageKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  isIdleScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token keyword\">var</span> callback <span class=\"token operator\">=</span> scheduledRICCallback\n  scheduledRICCallback <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>callback <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> start <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      didTimeout<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">timeRemaining</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Is there maximum value that timeRemaining() will return? Yes, it’s currently 50ms</span>\n        <span class=\"token comment\">// see: https://developers.google.com/web/updates/2015/08/using-requestidlecallback#faq</span>\n        <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">ric</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">callback</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  scheduledRICCallback <span class=\"token operator\">=</span> callback\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isIdleScheduled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    isIdleScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span>messageKey<span class=\"token punctuation\">,</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样实现的主要问题是，对于当前帧剩余时间的计算是不准确的，它总是默认还有 50ms 的剩余时间，在帧率为 60fps 时，一帧的执行时间才大致 17ms 左右。所以 React 团队使用 rAF 来动态算出当前帧率，计算出当前帧执行截止时间。动态计算当前帧率逻辑大致如下，</p>\n<ol>\n<li>初始以当前帧率为 30fps，则每一帧执行时间大约为 33ms</li>\n<li>如果连续 2 帧的执行时间都小于当前帧率下的每帧执行时间，则表明当前帧率有待提高</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 帧截止时间</span>\n<span class=\"token keyword\">var</span> frameDeadline <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token comment\">// 初始当前帧率为30fps，则帧执行时间为33ms</span>\n<span class=\"token comment\">// 上一帧执行时间</span>\n<span class=\"token keyword\">var</span> previousFrameTime <span class=\"token operator\">=</span> <span class=\"token number\">33</span>\n<span class=\"token comment\">// 30fps下，每一帧执行时间</span>\n<span class=\"token keyword\">var</span> activeFrameTime <span class=\"token operator\">=</span> <span class=\"token number\">33</span>\n\n<span class=\"token comment\">// 计算rIC参数，剩余时间</span>\n<span class=\"token keyword\">var</span> frameDeadlineObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  timeRemaining<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">typeof</span> performance <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> performance<span class=\"token punctuation\">.</span>now <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span>\n      <span class=\"token operator\">?</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> frameDeadline <span class=\"token operator\">-</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> frameDeadline <span class=\"token operator\">-</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">animationTick</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">rafTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 计算出下一帧执行时间，这里的frameDeadline为上一帧的截止时间</span>\n  <span class=\"token keyword\">var</span> nextFrameTime <span class=\"token operator\">=</span> rafTime <span class=\"token operator\">-</span> frameDeadline <span class=\"token operator\">+</span> activeFrameTime\n  <span class=\"token comment\">// 如果连续2帧的执行时间都小于帧执行时间，则说明可以提高帧率</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextFrameTime <span class=\"token operator\">&lt;</span> activeFrameTime <span class=\"token operator\">&amp;&amp;</span> previousFrameTime <span class=\"token operator\">&lt;</span> activeFrameTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextFrameTime <span class=\"token operator\">&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 最高提高的120fps，</span>\n      nextFrameTime <span class=\"token operator\">=</span> <span class=\"token number\">8</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 取连续2帧中执行时间较大的，防止执行超过帧截止时间</span>\n    activeFrameTime <span class=\"token operator\">=</span>\n      nextFrameTime <span class=\"token operator\">&lt;</span> previousFrameTime <span class=\"token operator\">?</span> previousFrameTime <span class=\"token punctuation\">:</span> nextFrameTime\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    previousFrameTime <span class=\"token operator\">=</span> nextFrameTime\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 计算出帧截止时间</span>\n  frameDeadline <span class=\"token operator\">=</span> rafTime <span class=\"token operator\">+</span> activeFrameTime\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>调整逻辑示意图如下，React 的实现中没有针对场景 1 做处理，即不会将帧率调整降低，</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7442a82b68d01a0c19bc2d2dbc96e438/448d4/frame-rate2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 53.41098169717138%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABoklEQVQoz42TS07DQAyGcykkxDG4BKy75g5suABixQoJsYMtbBBF0FD1AQK1SdM0kDRpM533z0xetAIElqw4v+1PHmfioDKtdfFU5imkjct3IQSiKIIUEpDKqLqoreu1UlA2VzGcDZjSNb+CWk2B5HmjawNtYvUV11CnFmQFe54IHF+RRrMA20b7IZLTdgWyeglIn98wPDkroUZz7HT1ZGmusHeUYauV4KbLGyhnDEHrDC87h0gv3OZELFviev8A59u7CG/amxNaI0zjtsdx3+d4nX0dnxOK/M5D3vbBemGj0/cPA7pF/NDF8nVcAgkzOzKeUwUmVPExkmAFaSBFjmsspjOzo8zOBG7yJGdIjbakEkRatXRu+p3OmOPJK90dMzz6Cr3BB0btAdyJgs3HXReLt0uw6SW8qYdhL4LnvqAz0XgyPe6IojNiCOcMjhcL+GvuJQrhbInEC00s4RsPhn2s3rvQ+QBxGiOcLhBPoqLWj3nTmxGxucPvVu6RUIoVFfiPOfUl/dWre7rIMnMbJP6q/3XC9b/BWhAEmM/nP+bW7RPbyE7LrQAsjQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/7442a82b68d01a0c19bc2d2dbc96e438/cc182/frame-rate2.webp 148w,\n/static/7442a82b68d01a0c19bc2d2dbc96e438/f7e40/frame-rate2.webp 295w,\n/static/7442a82b68d01a0c19bc2d2dbc96e438/1a2f4/frame-rate2.webp 590w,\n/static/7442a82b68d01a0c19bc2d2dbc96e438/93064/frame-rate2.webp 601w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/7442a82b68d01a0c19bc2d2dbc96e438/cf440/frame-rate2.png 148w,\n/static/7442a82b68d01a0c19bc2d2dbc96e438/d2d38/frame-rate2.png 295w,\n/static/7442a82b68d01a0c19bc2d2dbc96e438/b9e4f/frame-rate2.png 590w,\n/static/7442a82b68d01a0c19bc2d2dbc96e438/448d4/frame-rate2.png 601w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/7442a82b68d01a0c19bc2d2dbc96e438/b9e4f/frame-rate2.png\"\n          alt=\"adjust frame rate\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<ol>\n<li>第一种场景，下一帧的开始时间大于上一帧的截止时间，说明估算的帧执行时间偏小，帧率可以调整降低</li>\n<li>第二种场景，下一帧的开始时间等于上一帧的截止时间，说明估算的帧执行时间正确，帧率不需要调整</li>\n<li>第三种场景，下一帧的开始时间小于上一帧的截止时间，说明估算的帧执行时间偏大，帧率可以调整增高</li>\n</ol>\n\n        <h2 id='toc-2-3' >\n          为什么不要用 setTimeout\n        </h2>\n      \n<p>既然<code class=\"language-text\">postMessage</code>的作用是异步调度，那么为什么不使用<code class=\"language-text\">setTimeout</code>呢，它同样是可以实现异步调度？</p>\n<p>如果不使用 rIC，我们是无法真正准确的确定帧空闲时机的。上面使用<code class=\"language-text\">postMessage</code>实现异步调度，是为了交出 js 线程执行权，让渲染相关线程得到执行。上面结合使用 rAF 动态计算出当前帧率，得出帧截止时间，从而可以较准确的计算得到 rIC 中参数<code class=\"language-text\">timeRemaining</code>。需要注意的是，帧截止时间是在 rAF 中以当前帧开始时间为基准算的，就是说，我们默认<code class=\"language-text\">callback</code>在计算完成帧截止时间之后就开始执行的。但是如前面所说，我们不能直接在 rAF 里执行<code class=\"language-text\">callback</code>，而是使用异步调度。异步调度越早开始，那么<code class=\"language-text\">timeRemaining</code>得到值的误差就会越小。例如，帧开始时间是 10ms，以 10ms 为基准计算得到帧截止时间为 30ms，也就是说帧执行时间会总共有 20ms，如果异步调度是在 5ms 之后开真正执行<code class=\"language-text\">callback</code>，那么在<code class=\"language-text\">callback</code>中调用<code class=\"language-text\">timeRemaining</code>得到的时间只有<code class=\"language-text\">30 - 5 = 25</code>，比预期的少了 5ms。</p>\n<p>为了减少误差，React 使用了<code class=\"language-text\">postMessage</code>，而不是<code class=\"language-text\">setTimeout</code>，因为<code class=\"language-text\">postMessage</code>比<code class=\"language-text\">setTimeout</code>要早得到执行。对于现代浏览器来说，使用<code class=\"language-text\">setTimeout(callback,0)</code>，会存在 4ms 的执行间隔限制。</p>\n<blockquote>\n<p><a href=\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\">https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers</a></p>\n<ol>\n<li>If timeout is less than 0, then set timeout to 0.</li>\n<li>If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.</li>\n</ol>\n</blockquote>\n<p>考虑如下代码，在<code class=\"language-text\">setTimeout</code>里调用<code class=\"language-text\">setTimeout</code>，当<code class=\"language-text\">cb</code>执行 5 次之后，则后面<code class=\"language-text\">cb</code>必须至少间隔 4ms 执行。</p>\n<blockquote>\n<p><strong>Note</strong>: 4 ms is <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#timers\">specified by the HTML5 spec</a> and is consistent across browsers released in 2010 and onward. Prior to (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2), the minimum timeout value for nested timeouts was 10 ms.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>使用<code class=\"language-text\">postMessage</code>可以较早于<code class=\"language-text\">setTimeout</code>执行，下面是 MDN 上的描述</p>\n<blockquote>\n<p>To implement a 0 ms timeout in a modern browser, you can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\"><code class=\"language-text\">window.postMessage()</code></a> as <a href=\"http://dbaron.org/log/20100309-faster-timeouts\">described here</a>.</p>\n</blockquote>\n<p>React 团队实现这个 polyfill 的作者也做了<a href=\"https://github.com/facebook/react/pull/8833#issuecomment-273974686\">如下说明</a>,</p>\n<blockquote>\n<p>I originally used <code class=\"language-text\">setTimeout(idle, 0)</code> but since it adjusts to at least 4ms and sometimes more, you end up dropping a bit more than I’d like from the available frame time. However, in practice <code class=\"language-text\">postMessage</code> can be delayed up to 4ms anyway because of the internal browser scheduling around the frame.</p>\n</blockquote>\n<p>我自己也亲自在 Chrome(84.0.4147.125)中做了测试如下，</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b2c5596960b8d3e67e0ce7bf514a6dfc/9a004/postMessage.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 29.40516273849607%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAoUlEQVQY05WQSw7CMAxEc5f8nCaN0ySiHyj3v9XgItjApl08yfLieTwqpYR937EsMxpH1BTAgwd5D20MjGCtPY0aYkTvHa0GtEK4CQvLnAieREwOWuvTKCLC9rxj3So6E2aRzSOJMMA69776TXoGFSVhbRM4e4yjQ5J3vbMwh+hz1VwR5pxxfxwdrihTgZWlu9DZX4cUIjIzuEygEC4n+uUFrfGu/2i2U0gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/b2c5596960b8d3e67e0ce7bf514a6dfc/cc182/postMessage.webp 148w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/f7e40/postMessage.webp 295w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/1a2f4/postMessage.webp 590w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/4837b/postMessage.webp 885w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/2f819/postMessage.webp 1180w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/9d157/postMessage.webp 1782w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/b2c5596960b8d3e67e0ce7bf514a6dfc/cf440/postMessage.png 148w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/d2d38/postMessage.png 295w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/b9e4f/postMessage.png 590w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/f9b6a/postMessage.png 885w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/2d849/postMessage.png 1180w,\n/static/b2c5596960b8d3e67e0ce7bf514a6dfc/9a004/postMessage.png 1782w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/b2c5596960b8d3e67e0ce7bf514a6dfc/b9e4f/postMessage.png\"\n          alt=\"postMessage vs setTimeout\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n\n        <h2 id='toc-2-4' >\n          小结\n        </h2>\n      \n<p>React v16.0.0 中实现 rIC 的核心思路就是，使用 rAF 动态计算帧率，使用<code class=\"language-text\">postMessage</code>实现异步调用。当然，它的实现中也有一些场景没有考虑，有一些不足之处，</p>\n<ol>\n<li>浏览器会对 rAF 进行一些优化，有些情况不会触发 rAF，例如切换到后台时；如果 rAF 得不到执行，那么 callback 就不会按照期望得到触发。</li>\n<li>它仅仅只支持单个 callback 执行，如果多次执行<code class=\"language-text\">rIC(callback)</code>，也只会有最后一个 callback 被执行，并不是真正符合 rIC 规范。在 <a href=\"https://github.com/facebook/react/pull/12746\">v16.4.0 中支持了多个 callback</a>。</li>\n<li>当前实现并未支持<code class=\"language-text\">timeout</code>参数，在 <a href=\"https://github.com/facebook/react/commit/9b36df86c6ccecb73ca44899386e6a72a83ad445#diff-5fd92c13da957dbd337d4583340fab8b\">v16.2.0 中就实现了</a></li>\n<li>当前并未支持<code class=\"language-text\">cancelIdleCallback</code>，在 <a href=\"https://github.com/facebook/react/pull/12746\">v16.4.0 中实现了</a></li>\n</ol>\n\n        <h2 id='toc-2-5' >\n          资料\n        </h2>\n      \n<ul>\n<li><a href=\"https://github.com/facebook/react/pull/8833\">requestIdleCallback polyfill - React v16.0.0 中实现</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Minimum_delay_and_timeout_nesting\">Minimum delay and timeout nesting</a></li>\n<li><a href=\"https://dbaron.org/log/20100309-faster-timeouts\">setTimeout with a shorter delay</a></li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">如果用 rAF 实现</a></li><li><a href=\"#toc-2-2\">如果用 postMessage 实现</a></li><li><a href=\"#toc-2-3\">为什么不要用 setTimeout</a></li><li><a href=\"#toc-2-4\">小结</a></li><li><a href=\"#toc-2-5\">资料</a></li></ul>","frontmatter":{"title":"React Time Slice（-） -   requestIdleCallback polyfill","date":"September 02, 2020","tags":["react","time slice"],"zan":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2020/react_time-slice_1/","previous":{"fields":{"slug":"/post/2020/stack_reconciler_vs_fiber_reconciler/"},"frontmatter":{"title":"React Fiber 分享"}},"next":{"fields":{"slug":"/post/2020/react_time-slice_2/"},"frontmatter":{"title":"React Time Slice（二） -   requestIdleCallback polyfill"}}}}