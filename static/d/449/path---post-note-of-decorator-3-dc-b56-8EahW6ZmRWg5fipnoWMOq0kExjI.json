{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"4220061d-6399-5490-98a2-87115328d7bf","excerpt":"最近一个月都在忙公司的新项目会过精选，加上双 11 大促，真的是很忙。加上最近的烦心事比较多，心情一直不是很好，做什么事情，都效率低下。收拾收拾心情，继续努力吧。一切都不会那么糟糕。在做会过精选 M 站时，我们前端组选型的技术栈是 React，Redux，TypeScript。一直都知道 decorator…","html":"<p>最近一个月都在忙公司的新项目<strong>会过精选</strong>，加上双 11 大促，真的是很忙。加上最近的烦心事比较多，心情一直不是很好，做什么事情，都效率低下。收拾收拾心情，继续努力吧。一切都不会那么糟糕。</p>\n<p>在做会过精选 M 站时，我们前端组选型的技术栈是 React，Redux，TypeScript。一直都知道 decorator 这个东西，但之前在卷皮没有机会用，现在在会过，我就高高兴兴的开始用起来了。\n装饰者的功能实际就是在不改原功能的前提下，对原目标进行额外功能的增强，比如：日志记录，缓存，访问控制等。</p>\n\n          <h3 id='toc-3-1' >\n            对类进行装饰\n          </h3>\n        \n<p>decorator 可以作用在类上，达到对类的属性或者原型进行改造。</p>\n<pre><code class=\"language-typescript\">// 定义这个页面是需要登陆权限的页面\n@needPageLogin\nclass OpenCoupons extends React.Component&#x3C;OpenCouponsProps, ComponentState> {\n  // ...\n}\n</code></pre>\n<!--more-->\n<p>这里，<code>needPageLogin</code>就是一个对类装饰者，接受类本身作为参数，这个 react 页面必须是登陆提前下才能查看的。</p>\n<pre><code class=\"language-typescript\">import { isLogin, goLogin } from \"../../platform/utils\"\n/* 配置页面需要登录 */\nexport function needPageLogin(target: React.ComponentClass) {\n  let componentDidMount = target.prototype.componentDidMount\n  target.prototype.componentDidMount = function(...args) {\n    if (isLogin) {\n      return componentDidMount.apply(this, ...args)\n    } else {\n      goLogin()\n    }\n  }\n}\n</code></pre>\n\n          <h3 id='toc-3-2' >\n            对类属性进行装饰\n          </h3>\n        \n<p>decorator 还可以作用在类的属性上，比如<code>properties</code>，<code>methods</code>，<code>geters</code>，<code>setters</code>。</p>\n<pre><code class=\"language-typescript\">class OpenCoupons extends React.Component&#x3C;OpenCouponsProps, ComponentState> {\n  // 定义调用这个方法必须是需要登陆权限的\n  @needActionLogin\n  someAction() {\n    //...\n  }\n}\n</code></pre>\n<p>这里，<code>needActionLogin</code>接受三个参数，第一个参数就是目标对象的原型(OpenCoupons.proptype) ，第二个参数就是属性名('someAction')，第三个参数就是这个属性的属性描述符(descriptor)。</p>\n<pre><code class=\"language-typescript\">/* 配置方法需要登录 */\nexport function needActionLogin(\n  target,\n  name: string,\n  descriptor: PropertyDescriptor\n) {\n  let origin = descriptor.value\n  descriptor.value = function(...args) {\n    if (isLogin) {\n      return origin.apply(this, ...args)\n    } else {\n      goLogin()\n    }\n  }\n}\n</code></pre>\n\n          <h3 id='toc-3-3' >\n            decorator 接受参数\n          </h3>\n        \n<p>在定义 decorator 时可以传递参数，去控制实际要增加的功能。这样实现，实际就是又包装了一层函数，接受参数，处理之后再返回实际的 decorator，这个就是函数式编程中的高阶函数一样，与 React 中的高阶组件 HOC 类似。</p>\n<pre><code class=\"language-typescript\">// 定义这个页面是需要登陆权限的页面\n@sharePage(false)\nclass OpenCoupons extends React.Component&#x3C;OpenCouponsProps, ComponentState> {\n  //...\n}\n</code></pre>\n<p>这里，sharePage 接受一个参数，用来控制页面是否可以分享。</p>\n<pre><code class=\"language-typescript\">/* 设置页面的分享配置 */\nexport default function sharePage(show: boolean = true) {\n  return function(target: React.ComponentClass) {\n    let client = getClient()\n    let cwm = target.prototype.componentWillMount\n    target.prototype.componentWillMount = function(...args) {\n      if (client === \"wx\") {\n        Promise.all([getWxConfig(), importWxJS()])\n          .then(([data]: [ShareConfig, {}]) => {\n            let shareConfig: Huiguo.WxConfig = {\n              debug: data.debug || false,\n              appId: data.app_id,\n              timestamp: data.timestamp,\n              nonceStr: data.noncestr,\n              signature: data.signature,\n            }\n            if (window.wx &#x26;&#x26; window.wx.config) {\n              window.wx.config({\n                ...shareConfig,\n                jsApiList: [\n                  \"onMenuShareTimeline\",\n                  \"onMenuShareAppMessage\",\n                  \"hideOptionMenu\",\n                  \"showOptionMenu\",\n                  \"hideMenuItems\",\n                  \"showMenuItems\",\n                ],\n              })\n              if (!show) {\n                window.wx.ready(function() {\n                  window.wx.hideOptionMenu()\n                  /* window.wx.hideMenuItems({\n                    menuList: ['menuItem:share:appMessage', 'menuItem:share:timeline']\n                  }); */\n                })\n              }\n            }\n          })\n          .catch(e => {\n            console.error(e)\n          })\n      }\n      if (typeof cwm === \"function\") {\n        cwm.apply(this, args)\n      }\n    }\n  }\n}\n</code></pre>\n\n          <h3 id='toc-3-4' >\n            应用多个 decorator\n          </h3>\n        \n<p>对同一个类或者类的属性，可以同时应用多个 decorator，它们会按照 decorator 的顺序，先从外到内进入，然后由内向外执行。</p>\n<pre><code class=\"language-typescript\">@demoDecorator(1)\n@demoDecorator(2)\n@demoDecorator(3)\nclass OpenCoupons extends React.Component&#x3C;OpenCouponsProps, ComponentState> {\n  //...\n}\n</code></pre>\n<p>上面的定义，那么进入 demoDecorator 依次是 1，2，3；但是，真正对类<code>OpenCoupons</code>应用 decorator 时的顺序是 3，2，1 的顺序。</p>\n<pre><code class=\"language-typescript\">export default function demoDecorator(v: number) {\n  console.log(v, \"evaluated\")\n  return function(target: React.ComponentClass) {\n    console.log(v, \"executed\")\n  }\n}\n</code></pre>\n<p>实际，执行的结果是:</p>\n<pre><code class=\"language-bash\"> 1 \"evaluated\"\n 2 \"evaluated\"\n 3 \"evaluated\"\n 3 \"executed\"\n 2 \"executed\"\n 1 \"executed\"\n</code></pre>\n<p>现在，GitHub 上比较多的一个 decorator 库是<a href=\"https://github.com/jayphelps/core-decorators\">core-decorators</a>，这里定义了一些常见的用法，但是如果要结合实际业务去使用，那必须自己去写了。</p>\n\n          <h3 id='toc-3-5' >\n            小结\n          </h3>\n        \n<p>这次在会过精选项目的 M 站中，页面登录权限控制，页面分享配置，服务器时间配置等功能都用到了 decorator。</p>\n\n          <h3 id='toc-3-6' >\n            参考\n          </h3>\n        \n<ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/decorator\">http://es6.ruanyifeng.com/#docs/decorator</a></li>\n<li><a href=\"https://www.sitepoint.com/javascript-decorators-what-they-are/\">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></li>\n<li><a href=\"https://github.com/wycats/javascript-decorators\">https://github.com/wycats/javascript-decorators</a></li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">对类进行装饰</a><ul></ul></li><li><a href=\"#toc-3-2\">对类属性进行装饰</a><ul></ul></li><li><a href=\"#toc-3-3\">decorator 接受参数</a><ul></ul></li><li><a href=\"#toc-3-4\">应用多个 decorator</a><ul></ul></li><li><a href=\"#toc-3-5\">小结</a><ul></ul></li><li><a href=\"#toc-3-6\">参考</a><ul></ul></li></ul>","frontmatter":{"title":"笔记之decorator","date":"November 26, 2017","tags":["decorator","javascript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/note_of_decorator/","previous":{"fields":{"slug":"/post/mini_program_component_programming/"},"frontmatter":{"title":"小程序组件化编程"}},"next":{"fields":{"slug":"/post/summary_of_2017/"},"frontmatter":{"title":"2017年小结"}}}}