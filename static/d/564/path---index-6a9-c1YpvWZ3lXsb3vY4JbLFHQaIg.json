{"data":{"site":{"siteMetadata":{"title":"三羊的小站","postLimit":10,"menu":{"search":{"name":"搜索","link":"/search"}}}},"allMarkdownRemark":{"totalCount":34,"edges":[{"node":{"excerpt":"基础数据结构，最基础的就只有两种，一个是数组，一个是链表。其他的数据结构都是在它们之上抽象出来的，比如，栈，队列，散列表，树，图等。","fields":{"slug":"/post/algorithm_basic_data_structure/"},"frontmatter":{"date":"May 08, 2019","title":"数据结构和算法-基础数据结构","tags":["algorithm","javascript"],"description":"基础数据结构，最基础的就只有两种，一个是数组，一个是链表。其他的数据结构都是在它们之上抽象出来的，比如，栈，队列，散列表，树，图等。"}}},{"node":{"excerpt":"背景最近老板来了一个新需求，地理位置组团。其中一个功能点，就是用户可以进入地图页面，查看当前自身位置，且扫描圈内和圈外其他玩家，将玩家头像显示在地图页面上，标明玩家在哪个位置。老板说，在地图上要可以同时显示 200 个玩家头像，且保证页面流畅；Android6 的手机上，在拖拽，缩小放大时，不能出现明显的卡顿，必须保证用户体验。在拖拽，缩小或者放大等改变地图可视范围时，或则停留时间超过 60s，需要更新当前地图上的用户头像。","fields":{"slug":"/post/optimize_map_page/"},"frontmatter":{"date":"April 13, 2019","title":"性能优化篇-地图页面","tags":["performance","javascript"],"description":"应用数据结构和算法等知识来优化前端性能"}}},{"node":{"excerpt":"好快，2018 没了。","fields":{"slug":"/post/summary_of_2018/"},"frontmatter":{"date":"January 02, 2019","title":"2018年小结","tags":["2018","summary"],"description":null}}},{"node":{"excerpt":"在跨平台客户端开发中，H5 是使用最为广泛的方式，它既可以运行在 iOS 中，也可以运行在 Android 中，还可以运行在 web 浏览器中，可以说是”write once, run anywhere”。但是，H5 最为人诟病的就是用户体验不如 native 流畅，特别是对于低端机型和较差的网络环境，在页面加载时通常有较长一段时间的白屏等待时间。H5 开发者想尽办法缩短首屏时间，用户可交互时间，为此使用了一系列的优化手段，比如 ssr，code split，compress，lazy load，preload 等等，其实主要是围绕尽量少这一核心原则。为了平衡跨终端能力和用户体验，现在流行的又有 RN 和 Flutter 解决方案等。咦，感觉跑题了，还是回到标题说的，具体来看看在 IOS 中，H5 是怎么与 native 通信的。文字略长，但是我相信你看完了，会有所收获。说到通信，无非就是两种方式，native 调用 h5，h5 调用 native。H5 在 iOS 中的宿主是 UIWebView 或者 WKWebView，在 IOS8 中，Apple 引入了 WKWebView，将 UIWebView 标记为 Deprecated。现在来说，大部分 app 应该都是使用的 WKWebView，除非那些需要兼容 IOS8 以下系统的才会兼容使用 UIWebView，本文也主要是说说使用 WKWebView 的场景。在实现 H5 与 native 之间的通信，比较流行的库就是WebViewJavascriptBridge，为了真正弄明白原理，我也是通读了它的源码，然后根据它的实现思路，自己用 swift 也实现了一遍。下面就结合一个小例子，谈谈它的实现原理。假如有一个需求，是 H5 在 app 内会有一个截屏按钮，点击这个按钮能对当前 webView 截图，然后显示在我们的 H5 中一个元素里。如图可以看到，有一个截屏按钮，以及一个紫色区域，这个区域内有一个，用来显示我们截屏之后的图片。这个通常需要 H5 与 native 配合才能完成，截屏的功能肯定是 native 那边完成，但是触发时机肯定是 H5 这边来控制。native 需要提供一个 bridge 接口，比如 takeSnapshot，然后在 H5 中就需要调用 takeSnapshot 接口并获得相应数据，这段代码比较简单，就不解释。可以看到在调用 takeSnapshot 的回调中，h5 拿到了 path，然后将 path 赋值给了标签。Bridge 的初始化在完成上面这个例子时，H5 和 native 两边都需要先完成 bridge 的初始化。H5 这边通常会在的 中加载一段 sdk 代码，用来触发生成 H5 端 bridge 对象，每个公司都会自己提供一个对外的 sdk 脚本，比如微信提供的 sdk 等。通常放在 中，是因为它需要最先执行完成，这样你代码中才可以使用。这个 sdk 脚本，其实就是提供了一个函数，bridge 对象完成之后，会调用里面的回调函数，并提供对象作为参数。这是我写的 sdk，用于完成上面那个截屏的例子。最为主要功能是生成一个隐藏的 iframe，来通知 native 注入 bridge 对象到 window 上，注入的 bridge 对象就是 ClientBridge。它本身自己也会生成一个对象，用来提供给开发人员。当然，这个 sdk 的功能比较简单，其他公司的可能比较复杂，但是它绝对包含了最为重要的功能。这个时候 h5 中 ClientBridge 的初始化才算完成了一半，ClientBridge 还没有被真正创建，真正被创建的过程是在 native 中完成的。在 native 端，在 viewController 中创建了 webview 并实现了 navigationDelegate，并且也创建了 NativeBridge。在 navigationDelegate 中，我们可以拦截 h5 中 iframe 发送的请求，理解这点非常重要，h5 与 native 之间的通信就是通过这个拦截操完成的，后面会看到具体拦截细节，我们先看 native 端 NativeBridge 初始化的过程。在 native 端，也会生成一个 bridge 对象，通过这个对象，native 可以注册接口函数给 h5 调用，native 也可以调用 h5 中注册的函数。通过 sdk 中生成的 iframe，触发注入 h5 端 ClientBridge，此时，native 端才开始把 ClientBridge 注入到 h5 中去，在 native 端，可以直接以字符串形式执行 JavaScript 脚本。通常，会先准备好 ClientBridge 的脚本，然后在 native 直接执行，就可以将它注入到 H5 中去了。我准备的 ClientBridge 脚本如下，核心原理也是通过在 h5 中生成一个 iframe，通过 iframe 来充当 h5 与 native 之间的信使。和是暴露给 h5 端使用的，和是提供给 native 端使用的。只有当 native 执行了这一段脚本，h5 中 bridge 才算真正初始化完成。拦截请求在 native 端，通过实现 WkWebView 的 WKNavigationDelegate，可以拦截 h5 中加载 frame 的请求，然后通过请求的 scheme 和 host 来判断是否是我们约定好的，例如上面注入 bridge 的 sdk 中，我们约定的 scheme 是 https，host 是 bridgeinject。上面的 native 中代码可以看到，通过实现了 WKNavigationDelegate 中 decidePolicyForNavigationAction 的方法，我们可以拦截 iframe 以及 mainFrame 的请求，然后做如下处理：如果请求是注入 bridge 到 h5 的请求，则开始处理注入 bridge 对象到 h5 中，并取消本次请求。这个请求就是上面 sdk 中创建的 iframe 触发的。它的请求 url 是如果请求是 h5 与 native 之间通信的请求，则开始处理 h5 中传递的消息，并取消本次请求。这个请求会在后面看到。它的请求 url 是否则，就是正常的 mainFrame 或者 iframe 请求，正常处理请求H5 调用 native 接口先来看看第一种通信方式，就是 h5 调用 native 中的接口，比如例子中，h5 调用 native 提供的 takeSnapshot 接口实现截屏功能。首先，native 端必须先注册好 takeSnapshot 接口，这样 h5 才能使用。native 端注册 takeSnapshot 接口代码如下，至于 native 端的 NativeBridge 实现细节，其实与 ClientBridge 思路一样的，大致也是有一个字典保存注册的函数，然后根据 h5 调用 handlerName 来查找出这个函数，然后执行，具体细节就不说了，感兴趣可以看看这里。可以看到，h5 与 native 两边必须提供相同的 handlerName。通常呢，这个 handlerName 是 native 开发人员定义好的，然后 H5 开发人员按照文档使用。native 定义好了接口，那么 h5 这边就需要调用了，h5 在调用时，生成唯一的 callbackId，并将回调保存在哈希表中，然后通过 iframe 触发通知 native。native 通过拦截 iframe 的请求，判断是否 h5 中通信请求，如果是就开始处理，处理过程如下，获取了 h5 中消息之后，判断消息中是否包含了 callbackId，如果包含了，则说明是 h5 发送的一个 RequestMessage。通过 handlerName 取出 native 注册好的接口函数，然后执行，并返回结果。最后，native 通过执行来将结果返回给 h5。native 调用 h5 接口再来看看第二种通信方式，就是 native 调用 h5 端的接口，比如 h5 中会注册一个监听导航条上的返回按钮的函数，比较叫做 onBackEvent，native 通过调用 h5 中 onBackEvent 的接口函数，决定是否直接关闭当前 webView。类似的，h5 中必须先注册 onBackEvent 接口，然后，在 native 中监听导航条那个返回按钮的点击事件中，调用 h5 的 onBackEvent，根据结果来决定是否关闭当前 webView。NativeBridge 中的 callHandler 函数实现思路和 h5 中的一样，也是生成一个唯一的 callbackId，然后将回调保存在字典表中，再将消息发送到 h5。h5 这边通过 可以接受这个消息，然后根据 handlerName 查找到 h5 已经注册的接口函数，最后执行并返回数据给 native。通信流程图展示截屏图片其实，在 h5 调用 native 中 takeSnapshot 接口后，native 实现了截屏，获得到 UIImage，有两种返回可以返回数据给 h5native 直接返回图片的 base64 数据，h5 端直接展示native 现将图片存在 cache 目录里，生成一个 src，返回给 h5，h5 请求这个 src 的图片其中第一种方式简单，但是图片直接生成的 base64 格式，数据太大，对于传递和调试极为不方便。第二种方式，麻烦一点，生成的 src 又必须是一个约定好的 scheme 格式，native 又通过拦截请求，然后从 cache 目录里拿到图片，作为 response 返回。这次的拦截与 iframe 的拦截方式又不同，是通过来实现的，具体就不详细讨论了，感兴趣可以查看这里。小结通过一个例子，详细的讨论了 h5 与 native 之间的通信方式，核心原理如下native 可以直接执行 JavaScript 字符串形式执行 js 脚本，与 h5 通信native 可以拦截 iframe 的请求，执行 h5 的通信请求h5 通过 iframe 来发送数据给 native","fields":{"slug":"/post/understand_the_details_of_h5_and_native(ios)_communication/"},"frontmatter":{"date":"December 31, 2018","title":"理解h5与native(ios)通信细节","tags":["h5","bridge"],"description":"说到通信，无非就是两种方式，native 调用 h5，h5 调用 native。H5 在 iOS 中的宿主是 UIWebView 或者 WKWebView，在 IOS8 中，Apple 引入了 WKWebView，将 UIWebView 标记为 Deprecated。现在来说，大部分 app 应该都是使用的 WKWebView，除非那些需要兼容 IOS8 以下系统的才会兼容使用 UIWebView，本文也主要是说说使用 WKWebView 的场景。在实现 H5 与 native 之间的通信，比较流行的库就是WebViewJavascriptBridge，为了真正弄明白原理，我也是通读了它的源码，然后根据它的实现思路，自己用 swift 也实现了一遍。下面就结合一个小例子，谈谈它的实现原理。"}}},{"node":{"excerpt":"最近想了解一下 React 和 Vue 框架分别在 virtual dom 部分的实现，以及他们的不同之处。于是先翻开 Vue 的源码去找 virtual dom 的实现，看到开头，它就提到了 Vue 的 virtual dom 更新算法是基于 Snabbdom 实现的。于是，又去克隆了 Snabbdom 的源码，发现它的源码并不是很复杂并且星星 🌟 还很多，所以就仔细看了一遍了，这里就将详细学习一下它是如何实现 virtual dom 的。","fields":{"slug":"/post/understand_the_details_of_vritual_dom_snabbdom/"},"frontmatter":{"date":"December 31, 2018","title":"理解virtual dom的实现细节-snabbdom","tags":["h5","vue","vdom"],"description":null}}},{"node":{"excerpt":"1. Cannot read property ‘catch’ of undefined原因：在调用 play()时，现代浏览器返回的是一个 promise，对于执行失败的，会触发一个 Unhandled Promise Rejection，但是对于低版本的浏览器，调用 play()并不会返回一个 promise。解决：应该在调用 play()时做如下处理，增加对 playPromise 的判断参考资料：HTMLMediaElement.play() Returns a Promise2. InvalidStateError: An attempt was made to use an object that is not, or is no longer, usable原因：对于还没有设置 src 的 audio，就直接设置 currentTime 是会触发一个 INVALID_STATE_ERR 异常的。即使是设置 currentTime = 0 也会触发这个异常解决：在设置 currentTime 之前，必须先设置 audio 的 src参考资料：Offsets into the media resourcemedia .   = value Returns the current playback position, in seconds.Can be set, to seek to the given time.Will throw an  exception if there is no selected media resource. Will throw an  exception if the given time is not within the ranges to which the user agent can seek.3. NotAllowedError原因：在调用 play()时可能会触发一个 NotAllowedError 的 reject，原因是因为浏览器在某些情况下播放失败，常见场景是，未通过点击的情况下调用 play() ，或者点击事件的回调中是在下一个 tick 里调用的 play，例如在 setTimeout 里调用的 play，再或者新创建了很多个 audio 元素，但是并不是每个 audio 都是通过用户点击来调用的 play()等等。场景一未通过点击等事件绑定，直接调用 play()，触发 NotAllowedError。解决方法，把调用 play()的部分放在事件回调里，如下代码：场景二在点击事件回调中的下一个 tick 里调用 play()，这种情况的示例代码如下，这种情况，某些版本「在 iOS12.0.1 亲测有坑」也会触发 NotAllowedError 异常，应该避免这种情况，可以考虑如下 hack 手段解决场景三创建了多个 audio 元素，但是并不是每个 audio 都是通过用户点击来调用的 play()的，这时候某些版本「在 iOS12.0.1 亲测有坑」也会触发 NotAllowedError 异常。对于这种情况，最好的办法就是只创建一个 audio 元素，后面通过改变 src 来播放不同的音乐资源。只要 audio 通过了事件回调里调用过 play，后续都可以直接调用 play 了，而无需再次绑定事件回调里去执行，并且这样也可以避免创建多个 audio 来减少内存使用。4. iOS 中页面隐藏和显示时，播放 audio 行为异常原因：在某些 iOS 版本中「iOS12.0.1 亲测有坑」，当我们监听页面隐藏和显示事件，在隐藏时调用 pause() 暂停，显示时调用 play()恢复播放。当按下 home 键，页面进入系统后台时，pause()正常调用，audio 被正常暂停，但是但再次进入页面，显示事件中调用 play()就会出现异常了，第一种异常，如果我们只是单纯的调用，不会抛出任何错误，但是 audio 实际却没有真正播放，无任何声音；第二种异常，如果我们每次在显示事件中执行如下代码中任意一种场景，都会在很多情况下会抛出一个异常，极少数情况才会正常播放。解决：这两种异常行为应该都是 iOS 12.0.1 系统本身的 bug。我们可以通过如下 2 中方式来避免这种两种异常的发生，方式 1， 显示 load()，并监听 ，推荐使用这种方式方式 2，通过  以及 retry 来 hack 避免这种异常发生","fields":{"slug":"/post/resolve_issue_of_using_audio/"},"frontmatter":{"date":"December 17, 2018","title":"HTML5中Audio使用踩坑汇总","tags":["h5","audio"],"description":"本文汇总了在HTML5中使用Audio时遇到的一些问题，以及解决方案。"}}},{"node":{"excerpt":"最近在项目碰到了一个 vue 组件更新导致 style 异常的问题。下面记录一下我自己的解决思路。问题背景由于公司项目业务复杂，就不具体描述了。简单说一下问题，就是项目使用 vue 框架，在一个页面中根据 a 值来显示不同组件，当时显示 A 组件，否则就显示 B 组件。示例代码如下问题描述如上代码，页面加载时，显示 a 组件，且它的背景样式是设置了和为，一秒之后，a 变为了，这是显示 b 组件，预期之中，它也是应该设置了和为，但是呢，在显示 b 组件，它的样式，并不是，而是默认的，这样导致样式并非我们预期想要的。究竟为什么在显示 b 组件 时，这个不是我们在中返回的 100%呢？","fields":{"slug":"/post/resolve_vue_style_update_problem/"},"frontmatter":{"date":"December 03, 2018","title":"看vue源码解决组件style更新问题","tags":["vue"],"description":null}}},{"node":{"excerpt":"这篇是学习和回顾 canvas 系列笔记的第六篇，完整笔记详见：canvas 核心技术。在上一篇canvas 核心技术-如何实现复杂的动画笔记中，我们详细讨论了在制作复杂动画时，需要考虑时间因素，物理因素等，同时还回顾了如何使用缓动函数来扭曲时间轴实现非线性运动，比如常见的缓入，缓出，缓入缓出等。在游戏或者动画中，运动的物体在变化的过程中，它们是有可能碰撞在一起的，那么这一篇我们就来详细学习下如何进行碰撞检测。","fields":{"slug":"/post/how_to_detect_collision/"},"frontmatter":{"date":"August 26, 2018","title":"canvas-核心技术-如何实现碰撞检测","tags":["canvas"],"description":"使用边界值检测，外接图形检测，光线投射检测，分离轴检测等手段来实现碰撞检测"}}},{"node":{"excerpt":"这篇是学习和回顾 canvas 系列笔记的第五篇，完整笔记详见：canvas 核心技术。在上一篇canvas 核心技术-如何实现简单的动画笔记中，我们详细学习了如何进行 canvas 坐标系的平移，缩放，旋转等操作来实现一些比较简单和单一的动画。但是在实际动画中，影响一个动画的因素是很多的，比如一个小球自由落体运动，我们不仅要考虑小球的初始速度和初始方向，还要考虑重力加速度，空气阻力等外界因素。这一篇笔记，我们会详细学习复杂动画的相关知识。核心逻辑我们理解的动画，应该是在一段时间内，物体的某些属性，比如颜色，大小，位置，透明度等，发生改变。判断动画流程度的单位是动画刷新的速率，在浏览器中一般是浏览器的帧速率。帧速率越大，动画就越流畅。在现代浏览器中，我们一般是使用来执行动画。","fields":{"slug":"/post/how_to_implement_complex_animations/"},"frontmatter":{"date":"August 19, 2018","title":"canavs核心技术-如何实现复杂的动画","tags":["canvas"],"description":null}}},{"node":{"excerpt":"这篇是学习和回顾 canvas 系列笔记的第四篇，完整笔记详见：canvas 核心技术。在前面几篇中，我们回顾了在 canvas 中绘制线段，图形，图片等基本功能，当在制作 2d 游戏或者更为丰富的图表库时，必须提供强大的动画功能。canvas 本身不提供像 css 中属性专门来实现动画，但是 canvas 提供了，，等基本功能，我们可以通过组合使用这些功能来实现动画。跟动画有关的概念中，我们还要理解帧速率。我们通常说一帧，就是浏览器完整绘制一次所经过的时间。现代浏览器的帧速率一般是 60fps，就是在 1s 内可以绘制 60 次。如果帧速率过低，就会觉得明显的卡顿了。一般是帧速率越高，动画越流畅。在 JavaScript 中，我们要在 1s 内绘制 60 次，以前的做法是使用或者来定时执行。","fields":{"slug":"/post/how_to_implement_simple_animations/"},"frontmatter":{"date":"August 11, 2018","title":"canvas核心技术-如何实现简单的动画","tags":["canvas"],"description":null}}},{"node":{"excerpt":"这篇是学习和回顾 canvas 系列笔记的第三篇，完整笔记详见：canvas 核心技术通过上一篇canvas 核心技术-如何绘制图形的学习，我们知道了如何绘制任意多边形以及图片的填充规则。在 canvas 中应用比较多的还有绘制图片和文本。这篇文章，我们就来详细聊聊图片和文本的绘制。图片在 canvas 中，我们可以把一张图片直接绘制到 canvas 上，跟使用标签类似，不同的是，图片是绘制到 canvas 画布上的，而非独立的 html 元素。canvas 提供了方法来绘制图片，这个方法可以有三种形式的用法，如下，直接将图片绘制到指定的 canvas 坐标上，图片由 image 传入，坐标由 dx 和 dy 传入。同上面形式，只不过指定了图片绘制的宽度和高度，宽高由 dw 和 dh 传入。这个是最复杂，最灵活的使用形式，第一参数是待绘制的图片元素，第二个到第五个参数，指定了原图片上的坐标和宽高，这部分区域将会被绘制到 canvas 中，而其他区域将忽略，最后四个参数跟形式二一样，指定了 canvas 目标中的坐标和宽高。","fields":{"slug":"/post/how_to_draw_image_and_text/"},"frontmatter":{"date":"July 27, 2018","title":"canvas核心技术-如何绘制图片和文本","tags":["canvas"],"description":null}}},{"node":{"excerpt":"这篇学习和回顾 canvas 系列笔记的第二篇，完整笔记详见：canvas 核心技术通过上一篇canvas 核心技术-如何绘制线段的学习，我们知道了如何去绘制线段。很多的线段的拼接就组成了图形了，比如常见的三角形，矩形，圆形等。常见图形的绘制可以查看我的在线示例：canvas shape示例项目仓库地址：canvas demo图形三角形先来看看如何绘制一个三角形。三角形就是由三条边组成，我们可以理解为三个线段组成。确定了三角形的三个顶点的坐标位置，然后用线连接起来。","fields":{"slug":"/post/how_to_draw_graphics/"},"frontmatter":{"date":"July 18, 2018","title":"canvas核心技术-如何绘制图形","tags":["canvas"],"description":null}}},{"node":{"excerpt":"这篇是学习和回顾 canvas 系列笔记的第一篇，完整笔记详见：canvas 核心技术\n学习 canvas，首先得知道如何去绘制线段，然后才能通过很多简单的线段去实现比较复杂的图形，比如常见的图表，柱状图，折线图等都是通过一段一段的线段实现的。基础知识canvas 的基础知识不算多，主要掌握如何绘制线段，图形，图片，文本等。canvas 可以在浏览器中绘制，也可以借助 node-canvas在 node 服务端绘制简单的图片。本文只记录在浏览器中绘制，至于在 node 端如何绘制，自己可以去查看相关资料。在浏览器中绘制，就先在 html 中定义 canvas 元素，默认宽高是 300 * 150，可以通过和设置。注意 canvas 元素样式宽高和 canvas 绘图画布宽高不是一个东西，详见知识点 5 中 canvas 宽高。","fields":{"slug":"/post/how_to_draw_line/"},"frontmatter":{"date":"July 09, 2018","title":"canvas核心技术-如何绘制线段","tags":["canvas"],"description":null}}},{"node":{"excerpt":"最近项目需求中要写较多 H5 小游戏，游戏本身体量不是很复杂，主要是承载较多业务逻辑，所以决定用 canvas 来完成游戏部分。之前只是知道 H5 中有 canvas 这个东西，也知道它大概是画图的，但具体怎么用，还是一无所知的。在MDN在看了一些相关资料，一口气也看了HTML 5 Canvas 核心技术和HTML5 2D 游戏编程核心技术，对 canvas H5 游戏编程有了大致的了解，发现 canvas 游戏编程其实挺有趣的。目前也在学习 webgl 相关知识，打算把前端可视化这一块也深入学习。现在先记录一些自己认为 canvas 比较重要的知识，回顾和再学习。后续在记录 webgl 相关知识。主要知识点本系列主要深入学习 canvas 2d 编程中相关比较重要和基础的知识，算是对「HTML 5 Canvas 核心技术」这本书的读后感，大致知识点如下：基础知识，学习如何绘制线段，图形，图片，文本等。动画知识，学习如何用 canvas 实现简单的动画以及相关影响因素碰撞检测，学习如何检测两个物体在运动过程中是否发生碰撞2D 游戏开发，学习用 canvas 开发 2D 游戏canvas 相关小知识点在学习过程中，最好是自己能动手实现，我就专门建了一个 canvas demo 的项目，里面都是自己在学习 canvas 时动手写的一些例子，感兴趣的可以去看看。项目仓库地址：https://github.com/snayan/canvas-demodemo 预览地址：https://snayan.github.io/canvas-demo/我会按照上面的主要知识点，分篇幅来学习和回顾 canvas 相关的核心技术。主要如下：canvas 核心技术-如何绘制线段canvas 核心技术-如何绘制图形canvas 核心技术-如何图片和文本canvas 核心技术-如何实现简单动画canvas 核心技术-如何实现复杂动画canvas 核心技术-如何实现碰撞检测canvas 核心技术-如何实现一个简单的 2D 游戏引擎canvas 核心技术-宽高，渐变，绘制真正 1px 线段canvas 核心技术-向量，三角函数","fields":{"slug":"/post/core_html5_canvas/"},"frontmatter":{"date":"July 09, 2018","title":"canvas核心技术","tags":["canvas"],"description":null}}},{"node":{"excerpt":"现在前端项目的构建一般基本都是基于 webpack 的。项目的技术栈目前比较主流的是 react 全家桶和 vue 全家桶。\n趁空闲，以公司一个项目整理了 webpack 构建常见的流程,这个项目是使用 vue 全家桶开发的。技术栈vuetypescript浏览器支持","fields":{"slug":"/post/process_of_webpack_build_project/"},"frontmatter":{"date":"June 27, 2018","title":"webpack构建常见流程","tags":["webpack"],"description":null}}},{"node":{"excerpt":"目的这个项目主要是用 vue+vuex 实现一个单页面应用，纯粹是熟悉 vue 全家桶相关开发模式，用于练手非常合适。\n着手开发完了之后可以学的东西：熟悉 vue 单文件组件开发方式熟悉如何写一个 vue 插件熟悉如何使用 vue-router 以及挂载路由钩子函数熟悉 vuex 是如何运作的，模块化维护应用状态数据体验 typescript 的开发方式\n如果想学 vue 的不妨进来看看。\n项目源码地址：点击这里技术栈vuevuexvue-routertypescript","fields":{"slug":"/post/vue_technology_stack/"},"frontmatter":{"date":"June 15, 2018","title":"vue 全家桶初探","tags":["vue"],"description":null}}},{"node":{"excerpt":"React 中比较重要的就是React elements了，可以理解为页面中可看到的节点元素。结构一个React element的结构为下面这样，\n","fields":{"slug":"/post/learn_react16_part4/"},"frontmatter":{"date":"April 11, 2018","title":"react 16学习(四)","tags":["react"],"description":null}}},{"node":{"excerpt":"ReactDom 在 16 版本中也新增了一些新的功能，比如createPortal，hydrate。今天主要学习一下createPortal。\n先看下 ReactDom 的大致包含的一些属性和方法。可以看到我们熟悉的，，。这里面新增了两个新的方法和。以 unstable_开头的表示的是当前版本中存在的方法，但可能会在后续版本中改动或移除，所以不建议使用。","fields":{"slug":"/post/learn_react16_part3/"},"frontmatter":{"date":"April 04, 2018","title":"react 16学习(三)","tags":["react"],"description":null}}},{"node":{"excerpt":"上篇大致说了 react16 的结构，今天来看看 react16 中新增的 Fragment。react16 中新增的可以渲染的类型：和。Fragments在 react16 中，的方法现在可以返回一个数组了，而在 react16 之前只能返回一个，一般被包裹着。在实际使用时，页面会输出一些很多没有用处的，增加了 dom 结构的嵌套层数，不利于页面快速的渲染。react16 之前","fields":{"slug":"/post/learn_react16_part2/"},"frontmatter":{"date":"March 02, 2018","title":"React 16学习(二)","tags":["react"],"description":null}}},{"node":{"excerpt":"趁着离职期这段时间，制定了一个计划，再次阅读 React16 的源码，React16 是一个大版本的更新，其中新增了许多的新特性，并且重写了核心模块的架构，叫做Fiber，最令人兴奋的是async rendering。之前也浅显的阅读过 React15 的部分源码，发现这次 React16 与之有很大的不同。核心文件React16 真的是重新梳理了代码结构，并且解耦了很多，下面为 React16 的文件结构可以看到我们熟悉的 react 和 react-dom。react-art 是绘制图形的，比如 Canvas，SVG，VML。react-call-return 是一个试验性的，用于 react 中的多遍渲染。react-reconciler 是 Fiber 的实现。share 中存放着一些公用的方法和属性。","fields":{"slug":"/post/learn_react16_part1/"},"frontmatter":{"date":"March 01, 2018","title":"React 16学习(-)","tags":["react"],"description":null}}},{"node":{"excerpt":"在某次求职过程中，收到了一个笔试题，要求写一个人机对战的五子棋，题目要求如下：请编写一个单机【五子棋】游戏，要求如下：\n使用原生技术实现，兼容 Chrome 浏览器即可。\n实现胜负判断，并给出赢棋提示；任意玩家赢得棋局，锁定棋盘。\n请尽可能的考虑游戏的扩展性，界面可以使用 DOM / Canvas 实现。考虑后续切换界面实现的方式成本最低。（比如选择使用 DOM 实现界面，需求改变为使用 Canvas 实现时尽可能少的改动代码）。\n实现一个悔棋功能\n实现一个撤销悔棋功能\n实现一个人机对战功能\n尽可能的考虑实现的灵活性和扩展性自己收到这个题目之后感觉有点棘手，自己没有开发过游戏，时间也比较紧。下班之后就开始弄了，简单介绍下自己的实现过程。","fields":{"slug":"/post/gomoku/"},"frontmatter":{"date":"January 23, 2018","title":"简单的五子棋","tags":["javascript","game"],"description":null}}},{"node":{"excerpt":"嗯，又到了年末，是时候对 17 年做个了断，好好开始 18 年。\n17 年的年初计划是：找一家靠谱的互联网公司阅读 12 本书报个英语培训班找一家靠谱的互联网公司年初，3 月份从广田智能来到了深圳卷皮，是找到了一家互联网公司，很互联网 😂。\n从 PC 端半路子前端到移动端的纯前端了，恶补各种移动端开发基础知识，移动端布局方案，详见移动端布局方案。\n从 grunt 的使用到 gulp，再到 webpack。用 gulp 也写一个小的脚手架工具，详见web-scaffold。\n从 backbone 的开发框架到 react，也稍微阅读了一下 react15 的部分源码，详见阅读 react 源码部分。\n从 0 到 1 开始开发微信小程序，写了一个小程序组件化开发，详见小程序组件化编程。阅读 12 本书从 3 月份开始，一直都坚持在看书，期间虽也断续停了一段，但幸好的是，现在依然坚持着。数数，应该有 12 本书了，详见2017 书单。好习惯，要坚持啊 ✊。报个英语培训班额，这个计划实在是没有办，之前 6 月份好像在天虹里有个培训班的招生柜台，大致去了解了一下。下半年就一直在加班，真的没有时间（没时间不是理由，好吧！），一直到现在也没有个没有。明年估计也不会报了，没钱啊（吃土了）。额外收获17 年，抽空搭了一个免费的 GitHub 博客，地址三羊同学的 blog。到现在，写了有接近 10 篇了吧，就是随便写写，总结也好，做笔记也好，当书签也好，反正，这是一个好习惯，不能放弃，要坚持。好吧，时间不早了，来小结吧。嗯，17 年确实累了不少，通宵都熬了不少，老了不少，我相信，收获也是不少的。题外话哈，负能量，12 月初也体会了一些凉心的事，但是也收获一些暖心的事。不管怎么样，还是抱着一颗感恩的心，去过 18 年。18 年的计划呢？明年再定。","fields":{"slug":"/post/summary_of_2017/"},"frontmatter":{"date":"December 14, 2017","title":"2017年小结","tags":["2017","summary"],"description":null}}},{"node":{"excerpt":"最近一个月都在忙公司的新项目会过精选，加上双 11 大促，真的是很忙。加上最近的烦心事比较多，心情一直不是很好，做什么事情，都效率低下。收拾收拾心情，继续努力吧。一切都不会那么糟糕。在做会过精选 M 站时，我们前端组选型的技术栈是 React，Redux，TypeScript。一直都知道 decorator 这个东西，但之前在卷皮没有机会用，现在在会过，我就高高兴兴的开始用起来了。\n装饰者的功能实际就是在不改原功能的前提下，对原目标进行额外功能的增强，比如：日志记录，缓存，访问控制等。对类进行装饰decorator 可以作用在类上，达到对类的属性或者原型进行改造。","fields":{"slug":"/post/note_of_decorator/"},"frontmatter":{"date":"November 26, 2017","title":"笔记之decorator","tags":["decorator","javascript"],"description":null}}},{"node":{"excerpt":"在开发微信小程序时，发现缺少了组件化开发体验，在网上找了一波资源，发现都不是很好。其中，有用开发 Vue 的方式去开发小程序，比如，WePY，最后将源代码编译成小程序的官方文件模式。这种方式，开发感觉爽，但是如果小程序版本升级变了之后，不在支持这种方式，那么就得重新开发一套小程序官方支持的代码了，成本代价很大。并且，这次项目时间非常紧，团队成员不熟悉 vue 的情况下，不敢用 WePY。但是，小程序官方又对组件化支持不是很友好。于是，决定自己弄一套，既有组件化开发体验，又是最大限度的接近小程序官方的开发模式。目前项目已经成功上线，小程序：会过精选示例地址第一步，改写 Page由于小程序的页面定义是通过方法去定义的，那么，一定在小程序内可以认为是一个全局变量，我只需要改写这个方法，去可以引用组件，调用组件，触发组件的生命周期方法，维持组件内部的数据状态，那么，是不是就可以接近了组件化的编程体验了，并且可以抽离常用组件，达到复用的目的。","fields":{"slug":"/post/mini_program_component_programming/"},"frontmatter":{"date":"September 17, 2017","title":"小程序组件化编程","tags":["mini program"],"description":null}}},{"node":{"excerpt":"一直想抽时间总结一下现在业界可用的移动端布局方案。需求多，995 模式，身心被掏空，一拖再拖，终于在周六的晚上，做着梦弄完成的，不足之道 😪，请指教改正 🤠。media+百分比直接采用媒体查询加百分比去布局。核心思想：页面主体布局基本采用百分比去设置。然后，其他块内布局,例如 font-size 等可通过设置媒体查询的断点来分设置，已达到兼容其他手机尺寸。","fields":{"slug":"/post/mobile-layout/"},"frontmatter":{"date":"July 31, 2017","title":"移动端布局方案浅谈","tags":["h5","mobile"],"description":null}}},{"node":{"excerpt":"在做响应式图片加载需要使用到的两个关键属性就是和 ，这两个属性是 H5 中新加的，是给 img 标签提供多个不同尺寸的图片，在不同设备，不同分辨率的情况下加载不同的图片。根据屏幕分辨率选择当只需要根据屏幕分辨率去选择不同的图片的时候，有 2 种情况。第 1 种，语法形式为：一般屏幕的分辨率会到 3 倍，例如 iphone6plus，其 dpr=3，这种是直接给出每种图片的分辨率规格，例子如下：上面的示例表示，在 dpr=1 的屏幕下加载 128px 这张图片；在 1<dpr<=2 时，加载 256px 这张图片；当 dpr>2 时就加载 512px 这张图片了。\n注意，srcset 里的x一定要是小写，大写的话，chrome 会无法识别。\n查看 demo","fields":{"slug":"/post/img_srcset_seizes/"},"frontmatter":{"date":"July 24, 2017","title":"响应式图片加载","tags":["resposive","mobile"],"description":null}}},{"node":{"excerpt":"看了这么多框架方面的东西，但注意，基础很重要。今天就来说说 javascipt 中容易忽略的类型转换问题。\n在 javascript 中有 7 种基本类型，它们为：，，，，，，。判断类型的方式是。我们把，，，，，这几类称为原始类型。注意两点，一是，对于函数，实际上也可以认为是，但使用得到的结果是；二是，对于，得到的结果是。","fields":{"slug":"/post/explanatio_of_ToPrimitive/"},"frontmatter":{"date":"July 06, 2017","title":"javascript中ToPrimitive详解","tags":["javascript"],"description":null}}},{"node":{"excerpt":"众所周知，react 的组件是有一个个的钩子函数，构建成的生命周期，在用 es6 的 class 与用 createClass 有所不同，其中 createClass 还包括了与。由于 createClass  将在后续版本中移除，建议使用 class 形式。所以，下面讨论的都是 class 形式下的生命周期方式。初始阶段constructor ，构造函数，在初始化实例时首先触发componentWillMount，组件将渲染出来之前触发，可以调用 setState，简单的合并 state，不会触发 render 重新渲染render ，将组件渲染，不可以调用 setStatecomponentDidMount，组件渲染之后触发，可以调用 setState，会重新触发 render","fields":{"slug":"/post/react_component_life_cycle/"},"frontmatter":{"date":"June 19, 2017","title":"react组件生命周期浅谈","tags":["react"],"description":null}}},{"node":{"excerpt":"ReactMount 为 react-dom 对象提供了和这 2 个方法，其中第一个就是我们常用的输出 react element 到真实的 dom 里。","fields":{"slug":"/post/reactdom_reactmount_source/"},"frontmatter":{"date":"June 10, 2017","title":"阅读react-dom源码--ReactMount部分","tags":["react"],"description":null}}},{"node":{"excerpt":"ReactElement 对象为 React 提供了，，，四个方法。ReactElement 是一个工厂方法，不是类模式，不要使用去调用。检查一个对象是否是 react element 对象，通过检查这个对象的是否等于","fields":{"slug":"/post/reactelement_source/"},"frontmatter":{"date":"May 30, 2017","title":"阅读react源码--ReactElement部分","tags":["react"],"description":null}}},{"node":{"excerpt":"ReactClass 对象为 React 提供了方法，实际上 ReactClass 有 2 个属性，一个是，另外一个是对象。","fields":{"slug":"/post/reactclass_source/"},"frontmatter":{"date":"May 22, 2017","title":"阅读react源码--createClass部分","tags":["react"],"description":null}}},{"node":{"excerpt":"今天主要看下，实际上是对象上一个构造函数。\n构造函数接受三个参数，，，，实际是在中注入的，它是用来实际更新","fields":{"slug":"/post/react_component_source/"},"frontmatter":{"date":"May 09, 2017","title":"阅读react源码--component部分","tags":["react"],"description":null}}},{"node":{"excerpt":"最近打算学习 react 与 redux 的源码，以此记录在学习过程中做的笔记吧。\n先来整体看看 react 的结构吧，实际上 react 就是一个对象，在实际使用的时候是这样的方式查看源码发现，react 对象就是一些包含一些属性的常见对象。常见的属性包括，，，，等。","fields":{"slug":"/post/react_whole_construct/"},"frontmatter":{"date":"May 04, 2017","title":"阅读react源码--react整体结构","tags":["react"],"description":null}}},{"node":{"excerpt":"单例模式，简单的说就是保证一个特定的类仅有一个实例，也就是不管实例化几次，都是返回的同一个实例。在 javascript 中，没有类的概念，每一个对象字面量都可以是认为是一个单例。对象全等，表示引用的同一个内存地址。在 javascript 中实现单例模式，有如下几种方式：全局变量方式，这种方式不好，全局变量可被随意改变，且可能与其他类库命名冲突","fields":{"slug":"/post/singleton/"},"frontmatter":{"date":"May 02, 2017","title":"单例模式","tags":["design patterns"],"description":null}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}