{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"4bf3d7ed-114a-5f1b-b77f-0b55b2047617","excerpt":"在前端性能优化策略中，耳熟能详的手段有，雅虎 35 条军规，使用 cache，减少请求数量，使用cookie-free domain，critical asset，使用 CDN，Lazy load，PreLoad…","html":"<p>在前端性能优化策略中，耳熟能详的手段有，<a href=\"https://developer.yahoo.com/performance/rules.html?guccounter=1\">雅虎 35 条军规</a>，使用 cache，减少请求数量，使用<a href=\"https://www.keycdn.com/support/how-to-use-cookie-free-domains\">cookie-free domain</a>，<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path\">critical asset</a>，使用 CDN，Lazy load，PreLoad 等，这些手段其实主要都是围绕怎么样更快的拿到所需关键资源。当我们把这一步做到很好，没有可优化空间了，其实还可以从另外一个方向去做优化，那就是浏览器渲染方面。浏览器渲染优化是一个很大的主题，今天，我们只谈它一个小角度，动画帧。从动画帧，我们可以怎么样来做一些优化工作呢？本文篇幅较长，图较多，耐心看完，一定会有很多收获的。</p>\n\n          <h2 id='toc-2-1' >\n            基础概念\n          </h2>\n        \n<p>先还是来熟悉基础概念。帧，可以理解为浏览器每一次绘制的快照。1s 内绘制的次数，叫做帧率，也就是我们常说的 fps（frame per second）。帧率越大，浏览器在 1s 内绘制的次数就越多，动画就越流畅。人们视觉系统对帧率的最低要求一般是 24fps，当帧率低于 24 时，就会感觉到明显的卡顿了。不同的移动设备，有不同的帧率，一般默认是 60fps。</p>\n<p><img src=\"./frame.png\" alt=\"frame\"></p>\n<p>我们要追求的理想帧率是 60fps，那么一帧绘制的时间最多是 1 / 60 = 16.7ms，一旦超过这个数，就达不到 60fps 了。为了使得一帧花费的时间控制在 16.7ms 内，我们必须先搞清楚浏览器在一帧会做些什么事情呢？</p>\n\n          <h2 id='toc-2-2' >\n            帧任务\n          </h2>\n        \n<p>html，js，css 是浏览器处理最为常见的三种资源，也是我们前端工程师每天都会打交道的文件。可是我们真正知道浏览器是怎么绘制的吗？稍微思考一下，然后会说，html 解析为 dom tree，css 解析为 cssom tree，然后 dom tree 加上 cssom tree 就合并为 render tree，最后浏览器根据 render tree 绘制到屏幕上。这是我们最为熟知的步骤，但是它只是描述了一个整体大致的过程，并没有具体到一帧的绘制过程。下面看看一帧具体绘制的过程图。</p>\n<p><img src=\"./step.png\" alt=\"step\"></p>\n<p>上图就是浏览器在绘制一帧时，会经过的处理步骤。</p>\n<ul>\n<li>JavaScript，我们会通过 js 来改动一些视觉效果，比如基于 js 的动画，或者响应用户事件等。</li>\n<li>Style，如果通过 js 改变了某一个 dom 的样式，就会重新计算受影响的元素的样式。</li>\n<li>Layout，如果样式改变中涉及了布局属性，例如 top，left，width 等几何位置，还会重新计算它的布局位置，以及受影响的其他元素的布局。当然，如果不涉及布局样式，也不会执行这一步。</li>\n<li>Paint，计算出 Style 和 Layout 后，就可以把元素绘制到它所属的 paint layer 上。</li>\n<li>Composite，最后会将多个 composite layer 输出到屏幕上显示出来。</li>\n</ul>\n<p>要控制一帧的执行时间在 16.7ms 内，就只需要把上述 5 个步骤处理时间总和控制在 16.7ms 内。接下来，我们一个步骤一个步骤来看，有哪些优化建议。</p>\n\n          <h2 id='toc-2-3' >\n            JavaScript\n          </h2>\n        \n\n          <h3 id='toc-3-1' >\n            requestAnimationFrame\n          </h3>\n        \n<p>JavaScript 是前端工程师的利器，有了它，我们可以实现非常复杂的系统，或者非常流畅的游戏等。JavaScript 通常会处理用户输入或者点击等事件，然后做一系列的视觉效果的改变。<strong>当涉及 dom 元素改变时，总是把操作放在 <code>requestAnimationFrame</code>中</strong>。</p>\n<p><code>requestAnimationFrame</code>会有什么神奇之处呢？</p>\n<ul>\n<li>它总是会确保 fn 的执行在浏览器一帧的开头</li>\n<li>浏览器会自动调节帧率，间接调节了 fn 的执行频率</li>\n</ul>\n<p>在不支持 raf 的浏览器中，通常使用<code>setTimeout(fn, 16.7)</code>来实现。但是<code>setTimeout</code>有一些不好的地方，</p>\n<ul>\n<li>它并不是保证 fn 每隔 16.7ms 就执行一次，它只能每 16.7ms 将 fn 加入到<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">MacroTask Queue</a>中，具体什么时候执行，要根据当前执行队列决定</li>\n<li>它不能保证每次执行时机都是一帧的开头，可能某一次执行触发是在帧的中间或者结尾，导致延长当前帧在 16.7ms 内无法执行完成，就会出现丢失当前帧</li>\n<li>不同设备帧率不一样，并不是固定的 60fps，给低帧率（比如 30fps）的设备上执行<code>setTimeout(fn, 16.7)</code>将会导致执行很多无意义的 fn</li>\n</ul>\n<p>我们先使用<code>setTimeout</code>来实现，每 16.7ms 就更新一次小球的位置，这样尽量保证了 1s 内更新 60 次。</p>\n<pre><code class=\"language-typescript\">// 使用setTimeout来实现小球下落的动画\nfunction animtionWithSetTimeout() {\n  setTimeout(() => {\n    updateBoll()\n    animtionWithSetTimeout()\n  }, 16.7)\n}\n</code></pre>\n<p>然后，我们通过 Chrome 的 Performance 来分析当前帧率情况如下，</p>\n<p><img src=\"./setTimeout.png\" alt=\"setTimeout\"></p>\n<p>帧率上会有一些锯齿，表示有部分情况是低于 60fps 的。并且在上图中，某一帧中执行了两次<code>updateBoll</code>，第二次的<code>updateBoll</code>是在帧快结束时触发的，所以拉长了当前帧执行的时间。</p>\n<p><img src=\"./setTimeout2.png\" alt=\"setTimeout2\"></p>\n<p>然后，我们使用<code>requestAnimationFrame</code>来实现它。</p>\n<pre><code class=\"language-typescript\">// 使用requestAnimationFrame来实现小球下落\nfunction animationWithRaf() {\n  updateBoll()\n  requestAnimationFrame(animationWithRaf)\n}\n</code></pre>\n<p>同样，使用 Chrome 的 Performance 来分析当前帧率情况如下，</p>\n<p><img src=\"./raf.png\" alt=\"raf\"></p>\n<p>帧率明显稳定在 60fps 左右，没有上面出现的锯齿了，确保了每一帧中都只会触发一次<code>updateBoll</code>。</p>\n\n          <h3 id='toc-3-2' >\n            分块执行\n          </h3>\n        \n<p>JavaScript 的执行是在一帧的开头，JavaScript 执行的时间越长，那么当前帧花费的时间就越长。当浏览器要开始更新屏幕了，如果当前帧还未完成，那么当前帧就会被丢弃，延迟到一下次更新，表现出来的就是丢帧。我们应该尽可能缩短 JavaScript 的执行时间，通常不要超过 10ms，因为后面的 Style，Layout，Paint，Composite 至少要花费 6ms 的时间。</p>\n<p>当有一个大任务，需要长时间的执行时，我们可以把它分散到每一帧中去完成其中一小部分。这样，可以缩短在每帧中执行的时间。我们来看一个例子，比如要在一帧里绘制 100 个小球，假设需要花费 3s 的时间。</p>\n<pre><code class=\"language-typescript\">function createBoll() {\n  sleep(30) // 模拟30ms操作\n  const boll = document.createElement(\"div\")\n  boll.classList.add(\"boll\")\n  boll.style.background = randomColor()\n  document.body.append(boll)\n}\n\nconst COUNT = 100\n\n/* 直接执行大任务 */\nfunction longTask() {\n  requestAnimationFrame(() => {\n    for (i = 0; i &#x3C; COUNT; i++) {\n      createBoll()\n    }\n  })\n}\n</code></pre>\n<p><img src=\"./longTask.png\" alt=\"longTask\"></p>\n<p>可以明显的看到，这一帧里花费了 3022.7ms，期间页面一直是上一帧的内容（空白）。只有等到任务完成了，才会全部显示小球出来。下面，我们把这个长任务分散到每一帧里执行，每一帧只创建一个小球。</p>\n<pre><code class=\"language-typescript\">/* 分块执行小任务 */\nfunction chunkTask() {\n  let i = 0\n  requestAnimationFrame(function doOne() {\n    // 每一帧，只创建一个小球\n    createBoll()\n    i++\n    if (i &#x3C; COUNT) {\n      requestAnimationFrame(doOne)\n    }\n  })\n}\n</code></pre>\n<p><img src=\"./chunkTask.png\" alt=\"chunkTask\"></p>\n<p>现在每一帧都只花费了 30ms 左右，并且页面不会空等 3s 才显示小球，而是小球逐个绘制出来了，体验明显好多了。</p>\n\n          <h3 id='toc-3-3' >\n            其他最佳实践\n          </h3>\n        \n<p>对于 JavaScript 步骤，还有其他一些很好的建议，下面简单列举出来，就不做 demo 了，</p>\n<ul>\n<li>将一些纯计算型，不涉及 dom 访问的任务，放到<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\">Web Workers</a>中</li>\n<li>对于可以使用 css3 来实现的动画，就不需要用 JavaScript 来实现了</li>\n<li>对于用户事件的响应，同步执行时间不要太长，逻辑尽量简单，复杂的逻辑可以延迟处理或分块处理</li>\n</ul>\n\n          <h2 id='toc-2-4' >\n            Style & Layout\n          </h2>\n        \n\n          <h3 id='toc-3-4' >\n            先读取，后设置\n          </h3>\n        \n<p>使用 JavaScript 来绘制动画时，我们往往需要根据当前 dom 状态（比如位置，大小）来更新它的状态。通常的最佳实践是，<strong>先读取，后设置</strong>。在 raf 中，页面 dom 元素样式都已经在上一帧中计算好了，在读取某一个 dom 样式时，不会触发浏览器重新计算样式和布局。但是，如果我们是先设置，然后在读取，那么这个 dom 样式已经被改变了，为了保证获取到正确的样式值，浏览器必须重新对当前 dom 进行样式计算，如果还涉及布局改变，也会进行重新布局，这种情况就是我们通常说的<strong>触发了 reflow</strong>。</p>\n<p>下面我们来验证一下，在 raf 中，每次都是先设置了小球的 top，然后再读取它的 offsetTop 和屏幕的 offsetHeight。</p>\n<pre><code class=\"language-javascript\">function reflow() {\n  requestAnimationFrame(() => {\n    boll.style.top = boll.offsetTop + 2 + \"px\"\n\n    if (boll.offsetTop &#x3C; document.documentElement.offsetHeight) {\n      reflow()\n    }\n  })\n}\n</code></pre>\n<p><img src=\"./reflow2.png\" alt=\"reflow2\"></p>\n<p>通过分析，可以看到在 JavaScript 中就触发了 Recalculation Forced 和 Layout Forced。现在我们优化一下，先读取它的 offsetTop 和屏幕的 offsetHeight 值，然后在去设置它的 top</p>\n<pre><code class=\"language-javascript\">function optimizeReflow() {\n  requestAnimationFrame(() => {\n    const top = boll.offsetTop\n    const bodyHeight = document.documentElement.offsetHeight\n    if (top >= bodyHeight) {\n      return\n    }\n\n    boll.style.top = top + 2 + \"px\"\n    optimizeReflow()\n  })\n}\n</code></pre>\n<p><img src=\"./reflow4.png\" alt=\"reflow4\"></p>\n<p>通过分析可以看到，在 JavaScript 步骤没有出现上面的 Recalculation Forced 和 Layout Forced。</p>\n\n          <h3 id='toc-3-5' >\n            减少 layout\n          </h3>\n        \n<p>如果我们在没有更改 dom 的几何属性（width，height，top，left，bottom，right 等），就不会触发 layout 步骤。当一个 dom 的 layout 被改变时，通常都会影响到其他关联的 dom 的 layout 也被改变。在设置动画时，能避免直接改变 dom 的 layout，就应该尽力避免。比如我们可以使用 transform 来位移元素，而不必直接改变它的 layout。还是上面的例子，同样的动画，我们改动 transform 来实现。</p>\n<pre><code class=\"language-javascript\">function transform() {\n  let distance = document.documentElement.offsetHeight - boll.offsetTop\n  let dropDistance = 0\n\n  requestAnimationFrame(function drop() {\n    if (dropDistance > distance) {\n      return\n    }\n\n    boll.style.transform = \"translateY(\" + dropDistance + \"px)\"\n    dropDistance = dropDistance + 2\n    requestAnimationFrame(drop)\n  })\n}\n</code></pre>\n<p><img src=\"./relow5.png\" alt=\"relow5\"></p>\n\n          <h2 id='toc-2-5' >\n            Paint\n          </h2>\n        \n\n          <h3 id='toc-3-6' >\n            减少绘制区域\n          </h3>\n        \n<p>通常，对某一个 dom 的改变，都会触发该 dom 所在层的整个重新绘制。为了避免对整个层的重新绘制，我们可以通过把该 dom 提升到一个新的 composite layer，减少对原始层的绘制。</p>\n<p>未提升前，每一帧里都会有对整个 document 的绘制，对整个 document 的绘制会消耗 48us 左右</p>\n<p><img src=\"./paint1.png\" alt=\"paint1\"></p>\n<p>优化之后，我们通过<code>will-change: top</code>把小球提升到一个新的 composite layer 上，没有了对整个 document 的绘制，节省了 48us。</p>\n<p><img src=\"./paint2.png\" alt=\"paint2\"></p>\n\n          <h3 id='toc-3-7' >\n            使用 transform 和 opacity\n          </h3>\n        \n<p>即使在同一层上，我们对某一个 dom 使用 transform 或者 opacity 来实现动画，也不会每帧都触发对整个 layer 的绘制，它只会对当前改变的 dom 的绘制和适当减少对整个 layer 的绘制次数。这个特性其实是浏览器的自身优化策略，transform 和 opacity 被视为合成器属性，它们在默认情况下都会生成新的 paint layer。相比上面的优化方式，使用合成器属性，实现了同样的优化效果，但是可以减少增加 composite layer，每创建一个 composite layer 也是会有性能开销的。</p>\n<p>我们不必直接改变 dom 的 top 或者 width 等几何属性，而是使用 transform 的 translate，scale 等来实现同样的效果，既可以减少绘制区域，也可以避免 layout。</p>\n\n          <h3 id='toc-3-8' >\n            减少绘制的复杂度\n          </h3>\n        \n<p>不同的绘制效果，消耗的时间也是不同的。通常越复杂的效果，消耗的资源和花费的时间越多，比如阴影，渐变，圆角等，就属于比较复杂的样式。这些样式效果，通常都是设计师设计出来的，我们没有理由直接否定。但是，我们可以根据不同设备来做一些不同的降级处理，比如较低设备上，就只用纯色来代替渐变，去掉阴影效果等。通过降级处理，保证了页面功能不受影响，也提高了页面的性能。</p>\n\n          <h2 id='toc-2-6' >\n            Composite\n          </h2>\n        \n<p>处理完了上面这些步骤，终于来到了 Composite 步骤。dom 通过适当条件触发，会提升为新的 composite layer，在 paint 阶段是发生在多个 layer 上的，最后浏览器通过合并多个 layer，根据它们的顺序来正确的显示在屏幕上。composite layer 提升触发条件非常多，这里我只列举几个常见的条件：</p>\n<ol>\n<li>3D 相关的 css 样式</li>\n<li>will-change 设置为 opacity，transform，top，left，bottom，right</li>\n<li>fixed（在高的 DPI 上会默认提升，在低 DPI 上不会）</li>\n<li>Hardware-accelerated video element</li>\n<li>Hardware-accelerated 2D canvas</li>\n<li>3D WebGL</li>\n<li>Overlay（比如 A 覆盖在 B 上，而 B 是提升的 composite layer，则 A 也会提升到新的 composite layer）</li>\n</ol>\n<p>composite layer 有自己的 graphic context，所以在渲染的时候，速度非常快，它是直接在 GPU 上完成的，不需要通过 CPU 处理。但是每新增一个 composite layer 都会消耗额外的内存，也不能盲目的将元素提升为新的 composite layer。</p>\n<p>除了有 Composite layer，还有一种 paint layer。paint layer 是在<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\">stacking context</a>上的，例如我们在使用<code>z-index</code>时就会生成新的 paint layer，在帧处理步骤中，其实还有一步 Update Layer Tree 就是用来更新 paint player 的。</p>\n<p><img src=\"./paintlayer.png\" alt=\"paintlayer\"></p>\n<p>每个 dom node 都会有对应的 layout object。如果 layout object 在同一个坐标系空间中，就会在同一个 paint layer 上。在某些条件下，比如 z-index，absolute 等会生成新的 paint layer。默认情况下，paint layer 都共享同一个 composite layer，但是在某些条件下，比如 animation，will-change 等会把当前 paint layer 提升为新的 composite layer，从而加速渲染。</p>\n<p><img src=\"./composite1.png\" alt=\"composite1\"></p>\n<p>现在，一帧的任务都处理完了，是不是就结束了呢？</p>\n\n          <h2 id='toc-2-7' >\n            requestIdleCallback\n          </h2>\n        \n<p>如果一帧的处理时间少于 16.7ms，多余出来的时间，浏览器会执行<code>requestIdleCallback</code>的任务。这个 API 目前还处在不稳定阶段，某些浏览器还未实现它。我们在使用的时候，一定要加上兼容性检测。</p>\n<pre><code class=\"language-javascript\">if (\"requestIdleCallback\" in window) {\n  // Use requestIdleCallback to schedule work.\n} else {\n  // Do what you’d do today.\n}\n</code></pre>\n<p><img src=\"/ric2.png\" alt=\"ric2\"></p>\n\n          <h3 id='toc-3-9' >\n            一定不能在 requestIdleCallback 里更改 dom 样式\n          </h3>\n        \n<p>rIC 阶段，frame 的样式布局等都己经 commit 了，所以不能在 rIC 里直接改变 dom 的布局或者样式。如果改变了，会导致样式布局计算失效，在下一帧就会触发 forced layout 等。例如下面这个例子，我们直接在 rIC 里改了小球的位置。</p>\n<pre><code class=\"language-javascript\">if (\"requestIdleCallback\" in window) {\n  requestIdleCallback(() => {\n    const left = boll.offsetLeft\n    // 这里，我们直接改了boll的位置\n    boll.style.left = left + 2 + \"px\"\n    moveLeftWithBadRic()\n  })\n}\n</code></pre>\n<p>然后，打开 chrome 调试一下，就会发现问题，在下一帧的开头就会触发了 layout，这是我们不希望的。</p>\n<p><img src=\"/./ric3.png\" alt=\"ric3\"></p>\n<p>更好的方式就是，我们可以在 rIC 里计算好样式，然后在 rAF 里去更新样式。</p>\n<pre><code class=\"language-javascript\">if (\"requestIdleCallback\" in window) {\n  requestIdleCallback(() => {\n    const left = boll.offsetLeft + 2\n    const top = boll.offsetTop + 2\n    // 在rAF里更新位置\n    requestAnimationFrame(() => {\n      boll.style.left = left + \"px\"\n      boll.style.top = top + \"px\"\n    })\n    moveLeftWithGoodRic()\n  })\n}\n</code></pre>\n<p>优化之后，我们再调试一下，发现，帧开头没有了 layout，这是我们想要的结果。</p>\n<p><img src=\"./ric4.png\" alt=\"ric4\"></p>\n\n          <h3 id='toc-3-10' >\n            其他最佳实践\n          </h3>\n        \n<ul>\n<li>\n<p>rIC 里，可用时间是非常有限的，不能一次执行长时间任务。可根据参数 deadline.timeRemaing()来判断当前可用时间，如果时间到了，必须要结束，或者放在下一个 rIC 里执行</p>\n<pre><code class=\"language-javascript\">function myNonEssentialWork(deadline) {\n// Use any remaining time, or, if timed out, just run through the tasks.\nwhile (\n  (deadline.timeRemaining() > 0 || deadline.didTimeout) &#x26;&#x26;\n  tasks.length > 0\n)\n  doWorkIfNeeded()\n\nif (tasks.length > 0) requestIdleCallback(myNonEssentialWork)\n}\n</code></pre>\n</li>\n<li>\n<p>rIC 不能保证一定会执行。所以一般放在 rIC 里的任务是无关核心逻辑或用户体验的，一般比如数据上报或者预处理数据。可用传入 timeout 参数，保证任务一定会执行。</p>\n<pre><code class=\"language-javascript\">// Wait at most two seconds before processing events.\nrequestIdleCallback(processPendingAnalyticsEvents, { timeout: 2000 })\n</code></pre>\n</li>\n</ul>\n\n          <h2 id='toc-2-8' >\n            小结\n          </h2>\n        \n<p>通过完整的学习一帧的绘制过程，然后针对每个过程，我们都采取一些优化手段，那么整个动画都将表现的非常流畅。最好，用一张图来作为结尾吧。</p>\n<p><img src=\"./ric5.png\" alt=\"ric5\"></p>\n\n          <h2 id='toc-2-9' >\n            参考\n          </h2>\n        \n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/rendering/\">渲染性能</a></li>\n<li><a href=\"https://www.alibabacloud.com/blog/front-end-performance-optimization-with-accelerated-compositing-part-1_594194\">Front-End Performance Optimization with Accelerated Compositing Part 1</a></li>\n<li><a href=\"https://aerotwist.com/blog/the-anatomy-of-a-frame/\">The Anatomy of a Frame</a></li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">基础概念</a><ul><li><a href=\"#toc-3-1\">requestAnimationFrame</a></li><li><a href=\"#toc-3-2\">分块执行</a></li><li><a href=\"#toc-3-3\">其他最佳实践</a></li><li><a href=\"#toc-3-4\">先读取，后设置</a></li><li><a href=\"#toc-3-5\">减少 layout</a></li><li><a href=\"#toc-3-6\">减少绘制区域</a></li><li><a href=\"#toc-3-7\">使用 transform 和 opacity</a></li><li><a href=\"#toc-3-8\">减少绘制的复杂度</a></li><li><a href=\"#toc-3-9\">一定不能在 requestIdleCallback 里更改 dom 样式</a></li><li><a href=\"#toc-3-10\">其他最佳实践</a></li></ul></li><li><a href=\"#toc-2-2\">帧任务</a><ul></ul></li><li><a href=\"#toc-2-3\">JavaScript</a><ul></ul></li><li><a href=\"#toc-2-4\">Style &#x26; Layout</a><ul></ul></li><li><a href=\"#toc-2-5\">Paint</a><ul></ul></li><li><a href=\"#toc-2-6\">Composite</a><ul></ul></li><li><a href=\"#toc-2-7\">requestIdleCallback</a><ul></ul></li><li><a href=\"#toc-2-8\">小结</a><ul></ul></li><li><a href=\"#toc-2-9\">参考</a><ul></ul></li></ul>","frontmatter":{"title":"深入浅出动画帧","date":"May 27, 2019","tags":["animation","frame"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019/in_depth_animation_frame/","previous":{"fields":{"slug":"/post/2019/algorithm_basic_data_structure/"},"frontmatter":{"title":"数据结构和算法-基础数据结构"}},"next":{"fields":{"slug":"/post/2019/algorithm_skip_list/"},"frontmatter":{"title":"数据结构和算法-跳表的原理及实现"}}}}