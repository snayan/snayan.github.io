{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"73f82190-d5a9-5121-9a3e-7ba74057d9e1","excerpt":"众所周知，react 的组件是有一个个的钩子函数，构建成的生命周期，在用 es6 的 class 与用 createClass 有所不同，其中 createClass 还包括了与。由于 createClass  将在后续版本中移除，建议使用 class 形式。所以，下面讨论的都是 class…","html":"<p>众所周知，react 的组件是有一个个的钩子函数，构建成的生命周期，在用 es6 的 class 与用 createClass 有所不同，其中 createClass 还包括了<code>getDefaultProps</code>与<code>getInitialState</code>。由于 createClass  将在后续版本中移除，建议使用 class 形式。所以，下面讨论的都是 class 形式下的生命周期方式。</p>\n\n          <h2 id='toc-2-1' >\n            初始阶段\n          </h2>\n        \n<ul>\n<li>constructor ，构造函数，在初始化实例时首先触发</li>\n<li>componentWillMount，组件将渲染出来之前触发，可以调用 setState，简单的合并 state，不会触发 render 重新渲染</li>\n<li>render ，将组件渲染，不可以调用 setState</li>\n<li>componentDidMount，组件渲染之后触发，可以调用 setState，会重新触发 render</li>\n</ul>\n<!--more-->\n\n          <h2 id='toc-2-2' >\n            更新阶段\n          </h2>\n        \n<ul>\n<li>componentWillReceivePorps，组件获取新的 props 时触发</li>\n<li>shouldComponentUpdate，组件在调用 setState 重新更新 render 之前调用，如果返回 false,则不触发后续的生命周期的方法，不会更新组件的渲染，返回 true，则一定会触发后续的生命周期方法，一定会重新更新组件的渲染，在这个方法里不能调用 setState，如果不小心调用，会造成死循环</li>\n<li>componentWillUpdate，组件在更新阶段，即将更新组件之前触发，不可调用 setState，如果不小心调用，会造成死循环</li>\n<li>Render，组件进行更新，不可调用 setState</li>\n<li>componentDidUpdate，组件更新之后触发，</li>\n</ul>\n\n          <h2 id='toc-2-3' >\n            卸载阶段\n          </h2>\n        \n<ul>\n<li>componentWillUnmount，组件即将卸载之前触发，在这里一般做一些清理工作，也不可调用 setState</li>\n</ul>\n<p>说完上面这些方法，就需要实际去验证了，我写了一个最基本的组件，且包含了它所有的生命周期的方法，看各个方法执行的情况。代码如下，其中 Test 与 App 大体类似，就不列出来了。</p>\n<pre><code class=\"language-jsx\">export class App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      name: \"zy\",\n    }\n    console.log(\"main constructor\")\n  }\n  componentWillMount() {\n    console.log(\"main componentWillMount\")\n  }\n  render() {\n    console.log(\"main render\")\n    return &#x3C;Test name={this.state.name} />\n  }\n  componentDidMount() {\n    console.log(\"main ComponentDidMount\")\n  }\n  componentWillReceiveProps() {\n    console.log(\"main componentWillReceiveProps\")\n  }\n  shouldComponentUpdate() {\n    console.log(\"main shouldComponentUpdate\")\n    return true\n  }\n  componentWillUpdate() {\n    console.log(\"main componentWillUpdate\")\n  }\n  componentDidUpdate() {\n    console.log(\"main componentDidUpdate\")\n  }\n  componentWillUnmount() {\n    console.log(\"main componentWillUnmount\")\n  }\n}\n</code></pre>\n<p>初始化时，查看 Console 控制台的打印情况如下，\n<img src=\"./react_init.png\" alt=\"react初始化\">\n可以看到，有 2 个点比较重要；第一个是， sub 组件只有在 main 的 render 方法中实例化时才开始生命周期方法的调用；第二个是，main 组件等 sub 组件实例化完成之后才完成。</p>\n<p>再来看看更新阶段的情况，\n<img src=\"./react_update.png\" alt=\"react更新阶段\">\n上面是完整的更新阶段调用情况，也就是说我把 shouldComponent 都返回的是 true，而实际中，shouldComponentUpdate 可能在控制组件更新时返回 false，那么返回 false 的情况下，后续的生命周期方法都不会调用，例如我把 main 的 shouldComponentUpdate 返回 false，调用情况如下，\n<img src=\"./react_update_false.png\" alt=\"react更新\"></p>\n<p>最后，来看看卸载的调用情况，如下，\n<img src=\"./react_destory.png\" alt=\"react卸载\"></p>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">初始阶段</a><ul></ul></li><li><a href=\"#toc-2-2\">更新阶段</a><ul></ul></li><li><a href=\"#toc-2-3\">卸载阶段</a><ul></ul></li></ul>","frontmatter":{"title":"react组件生命周期浅谈","date":"June 19, 2017","tags":["react"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/react_component_life_cycle/","previous":{"fields":{"slug":"/post/reactdom_reactmount_source/"},"frontmatter":{"title":"阅读react-dom源码--ReactMount部分"}},"next":{"fields":{"slug":"/post/explanatio_of_ToPrimitive/"},"frontmatter":{"title":"javascript中ToPrimitive详解"}}}}