{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","ableZan":true,"menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"5166d4e7-6d3f-51d6-ae88-35be11c17f7f","excerpt":"上一篇文章中，我们学习了 flutter 中三个主要的 widget，分别是 StatelessWidget，StatefulWidget，和 RenderObjectWidget；也简单介绍了 Widget，Element 和 RenderObject 之间的关系。这一篇，将介绍如何在 flutter…","html":"<p><a href=\"/post/2019/flutter-learn-2\">上一篇文章</a>中，我们学习了 flutter 中三个主要的 widget，分别是 StatelessWidget，StatefulWidget，和 RenderObjectWidget；也简单介绍了 Widget，Element 和 RenderObject 之间的关系。这一篇，将介绍如何在 flutter 应用中进行状态管理以及其基本的原理。</p>\n<p>状态管理，实际上就是对数据的管理，这些数据可以是与用户交互的数据，网络请求的数据，或者当前动画的状态数据。在进行状态管理时，需要根据当前状态的影响范围来决定其管理方式。一般是「就近原则」，就是把状态放在距离使用它最近的地方维护。对于组件内部状态（local state），放在组件内部维护就好了；对于多个组件需要共同使用的状态（shared state），就将它放在最近公共祖先中来维护；对于全局状态（global state），一般放在 app 全局状态中维护。现在很多 react 开发者，提到状态管理，就是使用 redux 放在全局管理，也不管这些数据的使用场景。这样做，通常会导致全局状态混乱且不好维护，而且也会造成一些渲染方面的性能问题，是非常不建议的。在 flutter 应用中，基本原则跟 react 是一样的，只不过具体实现方式略有差异而已。</p>\n\n        <h2 id='toc-2-1' >\n          状态管理\n        </h2>\n      \n\n        <h3 id='toc-3-1' >\n          local state\n        </h3>\n      \n<p>对于组件内部的状态，其他地方根本不关心它，也不使用它时，直接将它们放在组件内部维护就好了。这样不仅可以很方便地使用它，也保证了它不被外部污染或者改变。从设计模式上来说，减少了组件的外部依赖，增加组件的内聚性。</p>\n<p>在 flutter 中，使用 StatefulWidget 来创建和维护状态。在上一篇「<a href=\"/post/2019/flutter-learn-2\">flutter 学习小结（二）</a>」中，详细介绍了 StatefulWidget 和 State，以及其生命周期方法，这里我们通过一个简单的例子来说明如何使用。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">StateDemo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StatefulWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token metadata symbol\">@override</span>\n  StateDemoState <span class=\"token function\">createState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">StateDemoState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">StateDemoState</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">State</span><span class=\"token operator\">&lt;</span>StateDemo<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// state</span>\n  int _count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">void</span> <span class=\"token function\">_increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// setState会对当前组件执行rebuild</span>\n    <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      _count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>\n      mainAxisAlignment<span class=\"token punctuation\">:</span> MainAxisAlignment<span class=\"token punctuation\">.</span>center<span class=\"token punctuation\">,</span>\n      children<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">[</span>\n        <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string\">'$_count'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function\">RaisedButton</span><span class=\"token punctuation\">(</span>\n          onPressed<span class=\"token punctuation\">:</span> _increment<span class=\"token punctuation\">,</span>\n          child<span class=\"token punctuation\">:</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>Icons<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 State 内部有一个<code class=\"language-text\">_count</code>数据，每次点击按钮，都会将它加 1。</p>\n\n        <h3 id='toc-3-2' >\n          shared state\n        </h3>\n      \n<p>如果有多个组件需要共享某些状态，那么我们可以将需要共享的状态提升到它们的最近的上层组件中去。</p>\n<p>当组件与上层组件是直接父子关系，那么父组件可以将这些状态以及改变状态的方法传递到子组件中。例如，我们可以将上述例子中<code class=\"language-text\">_count</code>以及<code class=\"language-text\">_increment</code>直接传递给两个子组件。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token comment\">/// 上述StateDemoState</span>\n<span class=\"token metadata symbol\">@override</span>\nWidget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>\n    mainAxisAlignment<span class=\"token punctuation\">:</span> MainAxisAlignment<span class=\"token punctuation\">.</span>center<span class=\"token punctuation\">,</span>\n    children<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">[</span>\n      <span class=\"token function\">Child1</span><span class=\"token punctuation\">(</span>_count<span class=\"token punctuation\">,</span> _increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function\">Child2</span><span class=\"token punctuation\">(</span>_count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当组件与上层组件中间有多层组件，它们是祖先与子孙关系时，如果还是通过上面这样层层传递，就会显得十分繁琐，那我们能不能使得子孙组件可以直接获取祖先的数据，并且祖先数据改变了，自动更新子孙组件呢？</p>\n<p>react 中是提供了 Context 的方式，将共享数据放在 Context 组件中，它的所有子级组件都可以通过<code class=\"language-text\">contextType</code>或者<code class=\"language-text\">Consumer</code>来获得共享数据，具体细节可以查看<a href=\"https://reactjs.org/docs/context.html\">官方文档</a>。在 flutter 中，可以有如下方案可以选择，</p>\n<ol>\n<li>flutter 提供的基础 Widget，包括 InheritedWidget，InheritedModel</li>\n<li>flutter 官方提供的库，Provide，</li>\n<li>社区实现的库，包括 Bloc，Redux，Mobx，Scoped Model 等</li>\n</ol>\n<p>我们会在下面详细讨论 InheritedWidget，InheritedModel，Provider 的实现，至于社区提供的方案，感兴趣的可以自己去了解。</p>\n\n        <h3 id='toc-3-3' >\n          global state\n        </h3>\n      \n<p>全局状态是一种特殊的共享状态，它将状态放在 app 根组件中去维护，使得整个 app 的所有子组件都可以获取到，所以它的处理方案跟 share state 中一样。一般的全局状态有 app 主题，语言，或其他用户自定义设置等。下面我们聊聊 flutter 中状态管理的实现原理。</p>\n\n        <h2 id='toc-2-2' >\n          InheritedWidget\n        </h2>\n      \n<p>我们前面只聊了 flutter 中 StatelessWidget，StatefulWidget，和 RenderObjectWidget。这里，我们来详细聊聊 flutter 另一个比较重要的 Widget，InheritedWidget。</p>\n<p>InheritedWidget 的主要作用就是可以直接将数据传递给子树下面的任意子组件，并且当数据变了时，子组件会自动更新。当在一棵 Widget tree 中，子组件可以通过 BuildContext.dependOnInheritedWidgetOfExactType 来获取最近的 InheritedWidget 数据（在 flutter1.12.1 之前是使用 BuildContext.inheritFromWidgetOfExactType）。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token comment\">/// InheritedWidget源码</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InheritedWidget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ProxyWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">InheritedWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> Key key<span class=\"token punctuation\">,</span> Widget child <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">:</span> child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  InheritedElement <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">InheritedElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  bool <span class=\"token function\">updateShouldNotify</span><span class=\"token punctuation\">(</span>covariant InheritedWidget oldWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>InheritedWidget 与其他 Widget 不同之处是，多出了一个<code class=\"language-text\">updateShouldNotify</code>方法，这个方法需要子类去实现。每当 rebuild 时，则会根据<code class=\"language-text\">updateShouldNotify</code>返回的值去决定是否需要对依赖它的子组件做更新。下面我们使用 InheritedWidget 来实现上面 count 的例子。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token comment\">/// 因为Widget是immutable的，所以需要使用StatefulWidget来存储数据</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CountProvider</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StatefulWidget</span> <span class=\"token punctuation\">{</span>\n  Widget child<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">CountProvider</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  State<span class=\"token operator\">&lt;</span>CountProvider<span class=\"token operator\">></span> <span class=\"token function\">createState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">CountProviderState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/// 通过CountProvider.of(context)就可以获取InheritedWidget上的数据了</span>\n  <span class=\"token keyword\">static</span> ShareDataWidget <span class=\"token function\">of</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> context<span class=\"token punctuation\">.</span>dependOnInheritedWidgetOfExactType<span class=\"token operator\">&lt;</span>ShareDataWidget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/// State用于保存数据，并且更新</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CountProviderState</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">State</span><span class=\"token operator\">&lt;</span>CountProvider<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  int _count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">void</span> <span class=\"token function\">_incrementCounter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      _count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 需要将数据和更新方法传递给InheritedWidget，</span>\n    <span class=\"token comment\">/// 因为子孙组件只能获取到InheritedWidget，而非StatefulWidget和State</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">ShareDataWidget</span><span class=\"token punctuation\">(</span>\n      child<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>widget<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">,</span>\n      count<span class=\"token punctuation\">:</span> _count<span class=\"token punctuation\">,</span>\n      add<span class=\"token punctuation\">:</span> _incrementCounter<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/// 实现InheritedWidget</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ShareDataWidget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InheritedWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> int count<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">final</span> VoidCallback add<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/// 通过构造函数接受需要共享的数据和方法</span>\n  <span class=\"token function\">ShareDataWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    Key key<span class=\"token punctuation\">,</span>\n    <span class=\"token metadata symbol\">@required</span> Widget child<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">:</span> child<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  bool <span class=\"token function\">updateShouldNotify</span><span class=\"token punctuation\">(</span>ShareDataWidget oldWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 当count不想等时，需要通知子孙组件更新，</span>\n    <span class=\"token comment\">/// 如果count相等，则子孙组件不需要更新</span>\n    <span class=\"token keyword\">return</span> oldWidget<span class=\"token punctuation\">.</span>count <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果进一步深究原理，我们需要回答如下 2 个问题，</p>\n<ol>\n<li>dependOnInheritedWidgetOfExactType 是如何找到 InheritedWidget 的？</li>\n<li>updateShouldNotify 是如何控制子孙组件更新的？</li>\n</ol>\n<p>下面，我们来通过分析源码一步一步回答上面的问题。我们知道 context 实际上就是 element，在 element 上调用 dependOnInheritedWidgetOfExactType 就可以取出指定的 InheritedWidget，</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\">  <span class=\"token comment\">/// Element类</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Element</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">DiagnosticableTree</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BuildContext</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// 省略其他</span>\n\n  Map<span class=\"token operator\">&lt;</span>Type<span class=\"token punctuation\">,</span> InheritedElement<span class=\"token operator\">></span> _inheritedWidgets<span class=\"token punctuation\">;</span>\n  Set<span class=\"token operator\">&lt;</span>InheritedElement<span class=\"token operator\">></span> _dependencies<span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  InheritedWidget <span class=\"token function\">dependOnInheritedElement</span><span class=\"token punctuation\">(</span>InheritedElement ancestor<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Object aspect <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">assert</span><span class=\"token punctuation\">(</span>ancestor <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 先实例化一个Set</span>\n    _dependencies <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span> HashSet<span class=\"token operator\">&lt;</span>InheritedElement<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 将祖先InheritedElement加入到_dependencies中</span>\n    _dependencies<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 调用组先updateDependencies，将当前element加入到祖先的_dependencies中</span>\n    ancestor<span class=\"token punctuation\">.</span><span class=\"token function\">updateDependencies</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> aspect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 返回祖先InheritedElement关联的widget</span>\n    <span class=\"token keyword\">return</span> ancestor<span class=\"token punctuation\">.</span>widget<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  T dependOnInheritedWidgetOfExactType<span class=\"token operator\">&lt;</span>T <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InheritedWidget</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>Object aspect<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 先找到祖先InheritedElement</span>\n    <span class=\"token keyword\">final</span> InheritedElement ancestor <span class=\"token operator\">=</span> _inheritedWidgets <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> _inheritedWidgets<span class=\"token punctuation\">[</span>T<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ancestor <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/// 注册依赖项，并返回对应的InheritedWidget</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">dependOnInheritedElement</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">,</span> aspect<span class=\"token punctuation\">:</span> aspect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    _hadUnsatisfiedDependencies <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>它会通过<code class=\"language-text\">_inheritedWidgets</code>取出对应类型的祖先 InheritedElement，接着会执行如下步骤，</p>\n<ol>\n<li>生成一个 Set 实例，存放依赖项</li>\n<li>将组先 InheritedElement 加入到当前的_dependencies 中</li>\n<li>将当前 element 加入到组先 InheritedElement 的_dependencies 中</li>\n<li>返回祖先 InheritedElement 关联的 Widget</li>\n</ol>\n<p>祖先 InheritedElement 和子孙 Element 相互把对方加入到自己的_dependencies 中。那么子孙 Element 是何时将祖先 InheritedElement 加入到自己的<code class=\"language-text\">_inheritedWidgets</code>的呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\">  <span class=\"token comment\">/// Element类</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Element</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">DiagnosticableTree</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BuildContext</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// 省略其他</span>\n\n  <span class=\"token keyword\">void</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// ...</span>\n    <span class=\"token function\">_updateInheritance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">void</span> <span class=\"token function\">activate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// ...</span>\n    <span class=\"token function\">_updateInheritance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/// 一般element，只是使用parent element的_inheritedWidgets</span>\n  <span class=\"token comment\">/// 但是，InheritedElement会重写_updateInheritance方法</span>\n   <span class=\"token keyword\">void</span> <span class=\"token function\">_updateInheritance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _inheritedWidgets <span class=\"token operator\">=</span> _parent<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>_inheritedWidgets<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/// InheritedElement会重写_updateInheritance方法</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">InheritedElement</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ProxyElement</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// 忽略其他</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">_updateInheritance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 先取父级element的_inheritedWidgets</span>\n    <span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>Type<span class=\"token punctuation\">,</span> InheritedElement<span class=\"token operator\">></span> incomingWidgets <span class=\"token operator\">=</span> _parent<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>_inheritedWidgets<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>incomingWidgets <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n      _inheritedWidgets <span class=\"token operator\">=</span> HashMap<span class=\"token operator\">&lt;</span>Type<span class=\"token punctuation\">,</span> InheritedElement<span class=\"token operator\">></span><span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>incomingWidgets<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n      _inheritedWidgets <span class=\"token operator\">=</span> HashMap<span class=\"token operator\">&lt;</span>Type<span class=\"token punctuation\">,</span> InheritedElement<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/// 最后，将自己加进去</span>\n    _inheritedWidgets<span class=\"token punctuation\">[</span>widget<span class=\"token punctuation\">.</span>runtimeType<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>看上面代码，逻辑就很简单了，每次 element 在<code class=\"language-text\">mount</code>和<code class=\"language-text\">activate</code>会更新<code class=\"language-text\">_inheritedWidgets</code>。对于普通的 element，<code class=\"language-text\">_inheritedWidgets</code>就是取的 parent element 的<code class=\"language-text\">_inheritedWidgets</code>。一直这样迭代，直到碰到<code class=\"language-text\">InheritedElement</code>，它会将自己加入进去。如果有相同类型的 InheritedElement 的嵌套关系，则会直接覆盖，这也是为什么子孙 element 只能取得离它最近的一个特定类型的 InheritedElement，如下图所示。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ee960590297f3d3c06a9db6786a5b8cd/b70fd/inherited.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 471px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 51.167728237791934%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABm0lEQVQoz41SDU+jQBDt//895tpqoybnxcRcNFFDoTV3UGDB8rELWAr7wbvdNXD1colOMjvskH3z3szMoC0hCbabLaBgbRgGGxlj2HgbMMo+5Akh8DwPjuPY2Pf99H9WdwzVkYIeSlQdhVACo6lBoWop5GlOqQn4tMgEeH4/x/nPJRZ3c8zvvsH115BCQnCBosnxY/sdCSU2Z5js93skSYIwDLHb7eD7vr2PLGcxjRAWIYIsQFSGeDs2UzUuuc0deTvlzEPjQgjrnHMbR6Yzc8i+xaGm+J+Z/ik14CtmJRfrFdLnS5DHFTLnElnk6p5pdkb2IQf1VugqAiEHzYSjLEtQSlEUBfI8t15VFaSU7wwzZ4lsfYXcvUb6tARLX2AIGVDZlmj9G/AmhcaD0o/quraABtiAZllmt8HIniQPuld9e/hXgD3fmubDJD+VTFiM36+/4O5cEC1tHIrt7SDghS7a/m8xMwTjRuI4EPM9DeXiYYGL+6VenYVemzNsNPDp2ty+3CBlybQ2RmKapojjGFEUIQgCe++6zgL+ASFt/fVAX+0xAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/ee960590297f3d3c06a9db6786a5b8cd/cc182/inherited.webp 148w,\n/static/ee960590297f3d3c06a9db6786a5b8cd/f7e40/inherited.webp 295w,\n/static/ee960590297f3d3c06a9db6786a5b8cd/0c9df/inherited.webp 471w\"\n          sizes=\"(max-width: 471px) 100vw, 471px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/ee960590297f3d3c06a9db6786a5b8cd/cf440/inherited.png 148w,\n/static/ee960590297f3d3c06a9db6786a5b8cd/d2d38/inherited.png 295w,\n/static/ee960590297f3d3c06a9db6786a5b8cd/b70fd/inherited.png 471w\"\n          sizes=\"(max-width: 471px) 100vw, 471px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/ee960590297f3d3c06a9db6786a5b8cd/b70fd/inherited.png\"\n          alt=\"inherited\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>到这里，我们实际上已经回答了第一个问题了。我们再来看看第二个问题，updateShouldNotify 是如何控制子孙组件更新的。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ProxyElement</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ComponentElement</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// 忽略其他的</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>ProxyWidget newWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> ProxyWidget oldWidget <span class=\"token operator\">=</span> widget<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// ...</span>\n    <span class=\"token comment\">/// 会调用InheritedElement的updated</span>\n    <span class=\"token function\">updated</span><span class=\"token punctuation\">(</span>oldWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">updated</span><span class=\"token punctuation\">(</span>covariant ProxyWidget oldWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">notifyClients</span><span class=\"token punctuation\">(</span>oldWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">notifyClients</span><span class=\"token punctuation\">(</span>covariant ProxyWidget oldWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/// InheritedElement</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">InheritedElement</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ProxyElement</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// 忽略其他的</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">notifyDependent</span><span class=\"token punctuation\">(</span>covariant InheritedWidget oldWidget<span class=\"token punctuation\">,</span> Element dependent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 对于StatefulElement，didChangeDependencies方法中会调用State.didChangeDependencies,</span>\n    <span class=\"token comment\">/// 对于其他element，会调用markNeedsBuild，实现rebuild</span>\n    dependent<span class=\"token punctuation\">.</span><span class=\"token function\">didChangeDependencies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/// 重写了Element中updated方法</span>\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">updated</span><span class=\"token punctuation\">(</span>InheritedWidget oldWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 通过updateShouldNotify判断，是否需要更新子孙element</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>widget<span class=\"token punctuation\">.</span><span class=\"token function\">updateShouldNotify</span><span class=\"token punctuation\">(</span>oldWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">/// 再调用ProxyElement的updated，ProxyElement的updated会调用notifyClients</span>\n      <span class=\"token comment\">/// InheritedElement又重写了notifyClients</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">updated</span><span class=\"token punctuation\">(</span>oldWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/// 重写了Element中notifyClients方法</span>\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">notifyClients</span><span class=\"token punctuation\">(</span>InheritedWidget oldWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 我们上面说了InheritedElement和子孙element会相互将自己加入到对方的_dependents中</span>\n    <span class=\"token comment\">/// 这里就是循环所有的子孙element，然后调用其didChangeDependencies</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Element dependent <span class=\"token keyword\">in</span> _dependents<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">notifyDependent</span><span class=\"token punctuation\">(</span>oldWidget<span class=\"token punctuation\">,</span> dependent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Element 每次 rebuild，更新其 Widget 之后，都会调用<code class=\"language-text\">update</code>方法。对于 ProxyElement 而言，它会在<code class=\"language-text\">update</code>方法里通过调用 InheritedElement 的<code class=\"language-text\">updated</code>，从而调用 InheritedWidget 的<code class=\"language-text\">updateShouldNotify</code>来判断是否需要更新子孙 Widget。至此，第二个问题也已尽回答完毕。</p>\n\n        <h2 id='toc-2-3' >\n          InheritedModel\n        </h2>\n      \n<p>InheritedModel 是 InheritedWidget 的子类，它对 InheritedWidget 做了进一步的封装。当<code class=\"language-text\">updateShouldNotify</code>返回<code class=\"language-text\">true</code>时，InheritedWidget 会无条件的对所有依赖它的子组件执行 rebuild。如果我们想当共享的某一部分数据变了，才更新我们的子组件，那么就需要使用 InheritedModel 了。例如，我们共享的数据有 a 和 b，只有当 a 变了，我们才更新子组件 Childa，只有当 b 变了，我们才更新子组件 Childb。如果是用 InheritedWidget 来实现，则不管 a 和 b 哪个变了，Childa 和 Childb 都会更新。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ABModel</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InheritedModel</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">ABModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">,</span> Widget child<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">:</span> child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">final</span> int a<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">final</span> int b<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/// 跟InheritedWidget中updateShouldNotify一样</span>\n  <span class=\"token comment\">/// 当返回true，然后再根据updateShouldNotifyDependent的返回值，去决定是否需要对子组件执行rebuild</span>\n  <span class=\"token metadata symbol\">@override</span>\n  bool <span class=\"token function\">updateShouldNotify</span><span class=\"token punctuation\">(</span>ABModel old<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">!=</span> old<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> b <span class=\"token operator\">!=</span> old<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/// 比InheritedWidget多了一个判断步骤，</span>\n  <span class=\"token comment\">/// 这个就是根据指定条件去判断，是否需要对子组件执行rebuild</span>\n  <span class=\"token metadata symbol\">@override</span>\n  bool <span class=\"token function\">updateShouldNotifyDependent</span><span class=\"token punctuation\">(</span>ABModel old<span class=\"token punctuation\">,</span> Set<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> aspects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">!=</span> old<span class=\"token punctuation\">.</span>a <span class=\"token operator\">&amp;&amp;</span> aspects<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n        <span class=\"token punctuation\">(</span>b <span class=\"token operator\">!=</span> old<span class=\"token punctuation\">.</span>b <span class=\"token operator\">&amp;&amp;</span> aspects<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CountProvider</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StatefulWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// ...</span>\n  <span class=\"token comment\">/// 增加aspect参数，</span>\n  <span class=\"token keyword\">static</span> ABModel <span class=\"token function\">of</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>String aspect<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> InheritedModel<span class=\"token punctuation\">.</span>inheritFrom<span class=\"token operator\">&lt;</span>ABModel<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> aspect<span class=\"token punctuation\">:</span> aspect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Childa</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StatelessWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token metadata symbol\">@override</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 只有当a变了，才会对Childa执行rebuild</span>\n    ABModel state <span class=\"token operator\">=</span> CountProvider<span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> aspect<span class=\"token punctuation\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Childb</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StatelessWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token metadata symbol\">@override</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// 只有当b变了，才会对Childb执行rebuild</span>\n    ABModel state <span class=\"token operator\">=</span> CountProvider<span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> aspect<span class=\"token punctuation\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>接下来，我们从源码实现看看 InheritedModel 是如何做到指定数据变了，才会更新子组件的。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token comment\">/// InheritedModel继承InheritedWidget</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InheritedModel</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InheritedWidget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">InheritedModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> Key key<span class=\"token punctuation\">,</span> Widget child <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">:</span> child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/// 忽略其他的</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  InheritedModelElement<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> InheritedModelElement<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/// Return true if the changes between this model and [oldWidget] match any</span>\n  <span class=\"token comment\">/// of the [dependencies].</span>\n  <span class=\"token metadata symbol\">@protected</span>\n  bool <span class=\"token function\">updateShouldNotifyDependent</span><span class=\"token punctuation\">(</span>covariant InheritedModel<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> oldWidget<span class=\"token punctuation\">,</span> Set<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> dependencies<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>InheritedModel 继承至 InheritedWidget，并提供了<code class=\"language-text\">updateShouldNotifyDependent</code>方法。它会在<code class=\"language-text\">widget.updateShouldNotifyDependent</code>返回<code class=\"language-text\">true</code>时被调用，然后根据其结果，决定是否需要对子组件执行 rebuild。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token comment\">/// InheritedModelElement也继承InheritedElement</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">InheritedModelElement</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InheritedElement</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">/// ...忽略其他的</span>\n\n  <span class=\"token comment\">/// notifyDependent在updateShouldNotify返回true时才执行</span>\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">notifyDependent</span><span class=\"token punctuation\">(</span>InheritedModel<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> oldWidget<span class=\"token punctuation\">,</span> Element dependent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Set<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> dependencies <span class=\"token operator\">=</span> <span class=\"token function\">getDependencies</span><span class=\"token punctuation\">(</span>dependent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dependencies <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 根据updateShouldNotifyDependent决定是否需要对子组件执行rebuild</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dependencies<span class=\"token punctuation\">.</span>isEmpty <span class=\"token operator\">||</span> widget<span class=\"token punctuation\">.</span><span class=\"token function\">updateShouldNotifyDependent</span><span class=\"token punctuation\">(</span>oldWidget<span class=\"token punctuation\">,</span> dependencies<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      dependent<span class=\"token punctuation\">.</span><span class=\"token function\">didChangeDependencies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>InheritedWidget 是较底层的能力，InheritedModel 是在它之上做了一些功能增强。如果我们需要自己去实现一些共享状态逻辑处理，建议优先使用 InheritedModel，而非 InheritedWidget。一般情况下，我们可以直接使用 flutter 提供的状态管理库，Provider。</p>\n\n        <h2 id='toc-2-4' >\n          Provider\n        </h2>\n      \n<p>Provider 的底层实现实际上就是使用的 InheritedWidget，只不过它提供了多种形式的使用方式，比如 Provider，MultiProvider，ProxyProvider，详细使用可以参考<a href=\"https://pub.dev/packages/provider\">官方文档</a>，这里我们说一下它的基本实现。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Provider</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/// 忽略其他的</span>\n\n  <span class=\"token comment\">/// 同样提供了of方法，增加了listen参数，用于控制是否自动更新子组件</span>\n  <span class=\"token keyword\">static</span> T of<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>bool listen <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// this is required to get generic Type</span>\n    <span class=\"token keyword\">final</span> type <span class=\"token operator\">=</span> _typeOf<span class=\"token operator\">&lt;</span>InheritedProvider<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">>></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 如果listen为true，则调用inheritFromWidgetOfExactType，它会注册当前InheritedWidget和子孙组件互为依赖项</span>\n    <span class=\"token comment\">/// 否则，使用ancestorInheritedElementForWidgetOfExactType，它只是简单的获取InheritedWidget的数据，而不会注册依赖项</span>\n    <span class=\"token keyword\">final</span> provider <span class=\"token operator\">=</span> listen\n      <span class=\"token operator\">?</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">inheritFromWidgetOfExactType</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token operator\">as</span> InheritedProvider<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">:</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">ancestorInheritedElementForWidgetOfExactType</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>widget\n        <span class=\"token operator\">as</span> InheritedProvider<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>provider <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token function\">ProviderNotFoundError</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">.</span>widget<span class=\"token punctuation\">.</span>runtimeType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> provider<span class=\"token punctuation\">.</span>_value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n    <span class=\"token metadata symbol\">@override</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/// InheritedProvider就是InheritedWidget的子类</span>\n    <span class=\"token comment\">/// 可以传递自定义的updateShouldNotify</span>\n    <span class=\"token keyword\">return</span> InheritedProvider<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n      value<span class=\"token punctuation\">:</span> delegate<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span>\n      updateShouldNotify<span class=\"token punctuation\">:</span> updateShouldNotify<span class=\"token punctuation\">,</span>\n      child<span class=\"token punctuation\">:</span> child<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n        <h2 id='toc-2-5' >\n          小结\n        </h2>\n      \n<p>flutter 中的状态管理，大部分都是依赖 InheritedWidget 来实现的。我们详细列举了 flutter 中常见的几种状态管理场景，以及在跨层共享数据时的具体实现细节，希望本文对你有所帮助，谢谢。</p>\n\n        <h2 id='toc-2-6' >\n          参考\n        </h2>\n      \n<ul>\n<li>\n<p><a href=\"https://fireship.io/lessons/flutter-state-management-guide/\">Flutter State Management Guide</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.geekyants.com/state-management-in-flutter-7df833e6f3bd\">State Management in Flutter</a></p>\n</li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">状态管理</a></li><li><a href=\"#toc-2-2\">InheritedWidget</a></li><li><a href=\"#toc-2-3\">InheritedModel</a></li><li><a href=\"#toc-2-4\">Provider</a></li><li><a href=\"#toc-2-5\">小结</a></li><li><a href=\"#toc-2-6\">参考</a></li></ul>","frontmatter":{"title":"flutter 学习小结（三）","date":"November 30, 2019","tags":["flutter"],"zan":true}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019/flutter-learn-3/","previous":{"fields":{"slug":"/post/2019/flutter-learn-2/"},"frontmatter":{"title":"flutter 学习小结（二）"}},"next":{"fields":{"slug":"/post/2020/summary_of_2019/"},"frontmatter":{"title":"2019年小结"}}}}