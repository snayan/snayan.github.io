{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"cfa00d61-2a14-5090-bf56-912110583ad9","excerpt":"这篇学习和回顾 canvas 系列笔记的第二篇，完整笔记详见：canvas 核心技术通过上一篇canvas 核心技术-如何绘制线段的学习，我们知道了如何去绘制线段。很多的线段的拼接就组成了图形了，比如常见的三角形，矩形，圆形等。常见图形的绘制可以查看我的在线示例：canvas shape示例项目仓库地址：canvas…","html":"<p>这篇学习和回顾 canvas 系列笔记的第二篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a></p>\n<p>通过上一篇<a href=\"/post/how_to_draw_line/\">canvas 核心技术-如何绘制线段</a>的学习，我们知道了如何去绘制线段。很多的线段的拼接就组成了图形了，比如常见的三角形，矩形，圆形等。</p>\n<p>常见图形的绘制可以查看我的在线示例：<a href=\"https://snayan.github.io/canvas-demo/?module=shape\">canvas shape</a></p>\n<p>示例项目仓库地址：<a href=\"https://github.com/snayan/canvas-demo\">canvas demo</a></p>\n\n          <h3 id='toc-3-1' >\n            图形\n          </h3>\n        \n\n          <h4 id='toc-4-1' >\n            三角形\n          </h4>\n        \n<p>先来看看如何绘制一个三角形。三角形就是由三条边组成，我们可以理解为三个线段组成。确定了三角形的三个顶点的坐标位置，然后用线连接起来。</p>\n<pre><code class=\"language-javascript\">// 顶底1\nlet point1 = [100, 30]\n// 顶点2\nlet point2 = [50, 100]\n// 顶点3\nlet point3 = [180, 120]\n// 开始一段新路径\nctx.beginPath()\n// 移动起点到顶点1\nctx.moveTo(point1[0], point1[1])\n// 连接顶点1与顶点2\nctx.lineTo(point2[0], point2[1])\n// 连接顶点2与顶点3\nctx.lineTo(point3[0], point3[1])\n// 描边\nctx.stroke()\n// 绘制文本水平居中\nctx.textAlign = \"center\"\n// 绘制顶点1文本\nctx.fillText(`(${point1[0]},${point1[1]})`, point1[0], point1[1] - 10)\n// 绘制顶点2文本\nctx.fillText(`(${point2[0]},${point2[1]})`, point2[0] - 25, point2[1] + 5)\n// 绘制顶点3文本\nctx.fillText(`(${point3[0]},${point3[1]})`, point3[0] + 30, point3[1] + 5)\n</code></pre>\n<!--more-->\n<p><img src=\"./triangle1.png\" alt=\"triangle1\"></p>\n<p>从图可以看到，我们还有一条边没有连接起来，这是因为我们只显示的连接了 2 个顶点。要想把第三条边也连接起来，我们有 2 种方式。第一种方式是，我们显示的连接顶点 3 与顶点 1</p>\n<pre><code class=\"language-javascript\">// 第一种方式，显示的连接顶点3于顶点1\nctx.lineTo(point1[0], point1[1])\n</code></pre>\n<p>第二种方式是，我们调用<code>ctx.closePath()</code>来按 canvas 自动帮我们连接未关闭的路径。</p>\n<pre><code class=\"language-javascript\">// 第二种方式，调用ctx.closePath()\nctx.closePath()\n</code></pre>\n<p>无论哪一种都可以实现我们想要三角形。其中第二种方式会用的比较多，因为它会帮我们自动关闭当前路径，也就是使当前路径形成一个闭合的路径，这个在填充时是非常有用的，下面会说的。最终，我们得到三角形图形如下</p>\n<p><img src=\"./triangle2.png\" alt=\"triangle2\"></p>\n\n          <h4 id='toc-4-2' >\n            四边形\n          </h4>\n        \n<p>通过三个顶点，我们可以绘制一个三角形，那么通过四个点，我们当然可以绘制出四边形，我们照例来通过四个点来绘制一个矩形。</p>\n<pre><code class=\"language-javascript\">// p1\nlet point1 = [80, 30]\n// p2\nlet point2 = [180, 30]\n// p3\nlet point3 = [80, 110]\n// p4\nlet point4 = [180, 110]\n// 设置描边颜色为绿色\nctx.strokeStyle = \"green\"\n// 开始新的一段路径\nctx.beginPath()\n// 移动起点到p1\nctx.moveTo(point1[0], point1[1])\n// 连接p1与p2\nctx.lineTo(point2[0], point2[1])\n// 连接p2与p4\nctx.lineTo(point4[0], point4[1])\n// 连接p4与p3\nctx.lineTo(point3[0], point3[1])\n// 关闭当前路径，隐士连接p3与p1\nctx.closePath()\n// 描边\nctx.stroke()\n// 绘制顶点\nctx.textAlign = \"center\"\nctx.fillText(\"p1\", point1[0] - 10, point1[1] - 10)\nctx.fillText(\"p2\", point2[0] + 10, point2[1] - 10)\nctx.fillText(\"p3\", point3[0] - 10, point3[1] + 10)\nctx.fillText(\"p4\", point4[0] + 10, point4[1] + 10)\n</code></pre>\n<p><img src=\"./rect.png\" alt=\"rect\"></p>\n<p>注意，我们的顺序是 p1--> p2--> p4--> P3，由于矩形是一种特殊的四边形，在 canvas 中提供了一种方法可以快速创建一个矩形，如果知道了 p1 的坐标和矩形的宽度和高度，那么我们就可以确定了其他三个点的坐标。</p>\n<pre><code class=\"language-javascript\">// 快速创建矩形\nctx.rect(point1[0], point1[1], 100, 80)\n</code></pre>\n<p>在创建矩形，我们总是使用<code>ctx.rect(left,top,width,height)</code>，但是绘制非矩形的四边形，还是得按照每个点去连接成线段来绘制。</p>\n\n          <h4 id='toc-4-3' >\n            圆与圆弧\n          </h4>\n        \n<p>圆形可以看作是无数个很小的线段连接起来的，但是通过去定顶点来绘制圆形，显然不现实。canvas 中提供了一个专门绘制圆形的方法<code>ctx.arc(left,top,radius,startAngle,endAngle,antiClockwise)</code>。各个参数的顺序意思是，圆心坐标 X 值，圆心坐标 Y 值，半径，开始弧度，结束弧度，是否逆时针。通过指定$startAngle = 0$和$endAngle = Math.PI*2$，就可以绘制一个完整的圆了。最后一个参数<code>antiClockwise</code>对于图片的填充时会非常有用，后面讲填充时会详细说到。</p>\n<pre><code class=\"language-javascript\">// 圆心坐标\nlet center = [100, 75]\n// 半径\nlet radius = 50\n// 开始弧度值\nlet startAngle = 0\n// 结束弧度值，360度=Math.PI * 2\nlet endAngle = Math.PI * 2\n// 是否逆时针\nlet antiClockwise = false\n// 描边颜色\nctx.strokeStyle = \"blue\"\nctx.lineWidth = 1\nctx.arc(center[0], center[1], radius, startAngle, endAngle, antiClockwise)\n// 将圆形描边绘制出来\nctx.stroke()\n// 绘制出圆心和半径示意图,读者可以忽略下半部代码\nctx.beginPath()\nctx.fillStyle = \"red\"\nctx.arc(center[0], center[1], 2, startAngle, endAngle, antiClockwise)\nctx.fill()\nctx.beginPath()\nctx.moveTo(center[0], center[1])\nctx.lineTo(center[0] + radius, center[1])\nctx.stroke()\nctx.fillStyle = \"blue\"\nctx.font = \"24px sans-serif\"\nctx.textAlign = \"center\"\nctx.fillText(\"r\", center[0] + radius / 2, center[1] - 10)\n</code></pre>\n<p><img src=\"./arc.png\" alt=\"arc\"></p>\n<p>我们还可以改变起始和结束弧度的值，来绘制不同角度的弧形。比如八分之一圆弧，四分之圆弧，半圆弧等。</p>\n<pre><code class=\"language-javascript\">// 圆心坐标\nlet center = [50, 75]\n// 半径\nlet radius = 20\n// 起始弧度为0\nlet startAngle = 0\n// 是否逆时针\nlet antiClockwise = false\n// 弧度长度\nlet angles = [1 / 8, 1 / 4, 1 / 2, 3 / 4]\n// 描边颜色\nlet colors = [\"red\", \"blue\", \"green\", \"orange\"]\nfor (let [i, angle] of angles.entries()) {\n  // 计算结束弧度\n  let endAngle = Math.PI * 2 * angle\n  // 设置描边颜色\n  ctx.strokeStyle = colors[i]\n  // 开始新的路径\n  ctx.beginPath()\n  // 绘制圆弧\n  ctx.arc(\n    center[0] + i * radius * 3,\n    center[1],\n    radius,\n    startAngle,\n    endAngle,\n    antiClockwise\n  )\n  // 描边\n  ctx.stroke()\n}\n</code></pre>\n<p><img src=\"./angle.png\" alt=\"angle\"></p>\n\n          <h4 id='toc-4-4' >\n            任意多边形\n          </h4>\n        \n<p>上面说的都是一些比较简单和常见的图形，我们如何可以绘制任意多边形，比如五边形，六边形，八边形等。其实，在绘制四边形的时候就说过了，可以通过确定顶点坐标，然后把这些顶点按照一定顺序连接起来就可以了。下面，来实现一个通用的多边形的绘制方法。</p>\n<pre><code class=\"language-javascript\">class Polygon {\n  constructor(ctx, points) {\n    this.ctx = ctx\n    this.points = points\n  }\n  draw() {\n    if (!this.ctx instanceof CanvasRenderingContext2D) {\n      throw new Error(\n        \"Polygon#ctx must be an CanvasRenderingContext2D instance\"\n      )\n    }\n    if (!Array.isArray(this.points)) {\n      throw new Error(\"Polygon#points must be an Array\")\n    }\n    if (!this.points.length) {\n      return\n    }\n    let firstPoint = this.points[0]\n    let restPoint = this.points.slice(1)\n    ctx.beginPath()\n    ctx.moveTo(firstPoint[0], firstPoint[1])\n    for (let point of restPoint) {\n      ctx.lineTo(point[0], point[1])\n    }\n    ctx.closePath()\n  }\n}\n</code></pre>\n<p>通过实例化这个<code>Polygon</code>，并传入多边形的顶点坐标，我们就可以绘制出不同的多边形。例如下面的代码，分别绘制了五边形，六边形。</p>\n<pre><code class=\"language-javascript\">// 绘制五边形\nlet points = [[30, 40], [80, 40], [100, 80], [55, 120], [10, 80]]\nlet pentagon = new Polygon(ctx, points)\nctx.strokeStyle = \"blue\"\npentagon.draw()\nctx.stroke()\n\n// 绘制六边形\npoints = [[160, 40], [210, 40], [230, 80], [210, 120], [160, 120], [140, 80]]\nlet hexagon = new Polygon(ctx, points)\nctx.strokeStyle = \"green\"\nhexagon.draw()\nctx.stroke()\n</code></pre>\n<p><img src=\"./polygin.png\" alt=\"polygon\"></p>\n\n          <h3 id='toc-3-2' >\n            填充\n          </h3>\n        \n<p>上面，我们都是用描边把图形绘制出来，还有一种用的比较多的就是填充了。填充就是用特定的颜色把图形包围的区域涂满。</p>\n<pre><code class=\"language-javascript\">// 顶底1\nlet point1 = [100, 30]\n// 顶点2\nlet point2 = [50, 100]\n// 顶点3\nlet point3 = [180, 120]\n// 用红色描边\nctx.strokeStyle = \"red\"\n// 用黄色填充\nctx.fillStyle = \"yellow\"\n// 设置线段宽度为2\nctx.lineWidth = 2\n// 开始一段新路径\nctx.beginPath()\n// 移动起点到顶点1\nctx.moveTo(point1[0], point1[1])\n// 连接顶点1与顶点2\nctx.lineTo(point2[0], point2[1])\n// 连接顶点2与顶点3\nctx.lineTo(point3[0], point3[1])\n// 关闭当前路径\nctx.closePath()\n// 描边\nctx.stroke()\n// 填充\nctx.fill()\n</code></pre>\n<p><img src=\"./fill1.png\" alt=\"fill1\"></p>\n<p>需要注意的是，如果当前路径没有关闭，那么会先默认关闭当前路径，然后在进行填充 ，如下，我们把<code>ctx.closePath()</code>注释掉。</p>\n<pre><code class=\"language-javascript\">let point1 = [100, 30]\nlet point2 = [50, 100]\nlet point3 = [180, 120]\nctx.strokeStyle = \"red\"\nctx.fillStyle = \"yellow\"\n// 设置线段宽度为2\nctx.lineWidth = 2\nctx.beginPath()\nctx.moveTo(point1[0], point1[1])\nctx.lineTo(point2[0], point2[1])\nctx.lineTo(point3[0], point3[1])\n// ctx.closePath();\nctx.stroke()\nctx.fill()\n</code></pre>\n<p><img src=\"./fill2.png\" alt=\"fill2\"></p>\n<p>如果当前路径是循环的，或者是包含多个相交的子路径，那么 canvas 何如进行填充呢？比如下面这样的，为何在填充时，中间这一块没有被填充？</p>\n<pre><code class=\"language-javascript\">let point1 = [100, 30]\nlet point2 = [50, 100]\nlet point3 = [180, 120]\nlet point4 = [50, 60]\nlet point5 = [160, 80]\nlet point6 = [70, 120]\nctx.strokeStyle = \"red\"\nctx.fillStyle = \"yellow\"\nctx.lineWidth = 2\nctx.beginPath()\n// 绘制三角形1, 顺序：p1--p2--p3--p1\nctx.moveTo(point1[0], point1[1])\nctx.lineTo(point2[0], point2[1])\nctx.lineTo(point3[0], point3[1])\nctx.lineTo(point1[0], point1[1])\n// 绘制三角形2,顺序：p4--p5--p6--p4\nctx.moveTo(point4[0], point4[1])\nctx.lineTo(point5[0], point5[1])\nctx.lineTo(point6[0], point6[1])\nctx.lineTo(point4[0], point4[1])\nctx.stroke()\nctx.fill()\n</code></pre>\n<p><img src=\"./fill3.png\" alt=\"fill3\"></p>\n<p>我们来具体研究一下<code>fill</code>函数，查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fill\">MDN</a>上的解释，</p>\n<blockquote>\n<p>The <code>CanvasRenderingContext2D</code><strong>.fill()</strong> method of the Canvas 2D API fills the current or given path with the current fill style using the non-zero or even-odd winding rule</p>\n<pre><code class=\"language-typescript\"> void ctx.fill([fillRule]);\n void ctx.fill(path[, fillRule]);\n</code></pre>\n</blockquote>\n<p>fillRule 参数是可选的，可取值为<code>nonzero</code>,<code>evenodd</code>。也就是说，<code>fill</code>函数可以给当前路径或者给定的路径，使用<strong>非零环绕规则</strong>或者<strong>奇偶规规则</strong>来填充。path 参数是一个<code>Path2D</code>对象，是一个给定的路径，canvas 中默认的是当前路径，这个参数并不是所有的浏览器都支持，目前看，还有 IE 系列和移动设备上都没有很好的支持，就不多说了，具体可以查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Path2D\">Path2D</a>。</p>\n\n          <h4 id='toc-4-5' >\n            非零环绕规则\n          </h4>\n        \n<p>对于路径中的任意给定区域，从该区域内部画出一条足够长的线段，使此线段的终点完全落在路径范围之外。接下来，将计数器初始化为 0，然后，每当这条线段与路径上的直线或者曲线相交时，就改变计数器的值。如果是与路径的顺时针部分相交，则加 1，如果是与路径的逆时针部分相交，则减 1。最后，如计数器的值不为 0，则此区域就在路径里面，调用<code>fill</code>时，该区域被填充。如果计数器的最终值为 0，则此区域就不在路径里面，调用<code>fill</code>时，该区域就不被填充。canvas 的<code>fill</code>默认使用的就是这种非零环绕规则。</p>\n<p>再来看看上图，为何中间交叉区域没有被填充。我们绘制了 2 个三角形，第一绘制顺序是 p1 --> p2 --> p3 --> p1，第二个绘制顺序是 p4 --> p5 --> p6 --> p4 。可以看到第一个三角形在绘制是逆时针方向的，第二个三角形绘制是顺时针方向的，中间相交区域的计数器最终值就为 0 了，所以不应该包含在这个路径中。</p>\n<p>非零环绕规则演示可以查看我的示例：<a href=\"https://snayan.github.io/canvas-demo/?module=cutout\">非零环绕示例</a></p>\n\n          <h4 id='toc-4-6' >\n            奇偶规则\n          </h4>\n        \n<p>跟非零环绕规则类似，都是从任意区域画出一条足够长的线，使此线段的终点完全落在路径范围之外。如果这个线段与路径相交的个数是奇数，则此区域包含在路径中，如果是偶数，则表示此区域不包含在路径中。</p>\n<p>例如，我们把上面的例子改下，绘制第二个三角形的顺序改成逆时针 p4 --> p6 --> p5 --> P4，然后分别用非零环绕规则和奇偶规则来填充，看看效果。</p>\n<pre><code class=\"language-javascript\">// 绘制三角形2,注意顺序变了:p4-p6-p5-p4\nctx.moveTo(point4[0], point4[1])\nctx.lineTo(point6[0], point6[1])\nctx.lineTo(point5[0], point5[1])\nctx.lineTo(point4[0], point4[1])\nctx.stroke()\n// 填充,  默认就是非零环绕规则\nctx.fill()\n</code></pre>\n<p><img src=\"./fill4.png\" alt=\"fill4\"></p>\n<p>上面两个三角形的顺序都是逆时针，所以按照非零环绕规则，像个三角形的相交区域的计数器的最终值为-2，不为 0，则包含在路径中改，被填充了。</p>\n<p>同样的顺序，我们在改用奇偶规则来填充。</p>\n<pre><code class=\"language-javascript\">// 填充,  改用奇偶规则\nctx.fill(\"evenodd\")\n</code></pre>\n<p><img src=\"./fill5.png\" alt=\"fill5\"></p>\n\n          <h3 id='toc-3-3' >\n            小结\n          </h3>\n        \n<p>这篇我们主要学习了 canvas 中如何绘制图形，比如常见的三角形，四边形，圆心，以及任意多边形。在绘制图形时，有些比如矩形，圆形等 canvas 已经提供了内置的函数，<code>ctx.rect()</code>和<code>ctx.arc</code>可以直接绘制，但是对于任意多边形，我们则需要自己逐线段的绘制。</p>\n<p>在绘制路径时，是有顺序的。理解 canvas 中路径，和当前绘制的顺序，就可以很好的理解了 canvas 中填充规则了。canvas 中填充有<strong>非零环绕规则</strong>和<strong>奇偶规则</strong>。对于同样的路径，不同的规则可能会产生不同的填充区域，是使用时，注意路径顺序就好了。</p>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">图形</a><ul><li><a href=\"#toc-4-1\">三角形</a></li><li><a href=\"#toc-4-2\">四边形</a></li><li><a href=\"#toc-4-3\">圆与圆弧</a></li><li><a href=\"#toc-4-4\">任意多边形</a></li><li><a href=\"#toc-4-5\">非零环绕规则</a></li><li><a href=\"#toc-4-6\">奇偶规则</a></li></ul></li><li><a href=\"#toc-3-2\">填充</a><ul></ul></li><li><a href=\"#toc-3-3\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"canvas核心技术-如何绘制图形","date":"July 18, 2018","tags":["canvas"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/how_to_draw_graphics/","previous":{"fields":{"slug":"/post/how_to_draw_line/"},"frontmatter":{"title":"canvas核心技术-如何绘制线段"}},"next":{"fields":{"slug":"/post/how_to_draw_image_and_text/"},"frontmatter":{"title":"canvas核心技术-如何绘制图片和文本"}}}}