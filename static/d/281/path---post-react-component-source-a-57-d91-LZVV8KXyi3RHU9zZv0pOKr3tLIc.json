{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"9cd7cfa3-4902-5324-867f-329606a5e8b6","excerpt":"今天主要看下，实际上是对象上一个构造函数。\n构造函数接受三个参数，，，，实际是在中注入的，它是用来实际更新Component…","html":"<p>今天主要看下<code>React.Component</code>，实际上<code>Component</code>是<code>React</code>对象上一个构造函数。\n构造函数接受三个参数，<code>props</code>，<code>context</code>，<code>updater</code>，<code>updater</code>实际是在<code>render</code>中注入的，它是用来实际更新<code>state</code></p>\n<pre><code class=\"language-javascript\">function ReactComponent(props, context, updater) {\n  this.props = props\n  this.context = context\n  // emptyObject 是一个空对象{}\n  this.refs = emptyObject\n  // ReactNoopUpdateQueue is the abstract API for an update queue\n  this.updater = updater || ReactNoopUpdateQueue\n}\n</code></pre>\n<!--more-->\n<p>Component 的原型对象上有这么几个属性，分别是<code>isReactComponent</code>，<code>setState</code>，<code>forceUpdate</code>，<code>isMounted</code>，<code>replaceState</code>。其中，<code>isMounted</code>和<code>replaceState</code>不推荐使用了，后续版本会移除的。</p>\n<ul>\n<li><code>isReactComponent</code>是一个空对象。</li>\n</ul>\n<pre><code class=\"language-javascript\">ReactComponent.prototype.isReactComponent = {}\n</code></pre>\n<ul>\n<li><code>setState()</code>方法，改变组件<code>state</code>时应该总是使用这个方法，把<code>state</code>看成一个不可变对象。当调用<code>setState()</code>方法时，不会保证立即执行<code>setState</code>函数，也不会立即改变<code>state</code>对象，因为它的执行是一个异步的。它可以有两个参数，第一个参数是对象或者函数，这个函数返回一个对象，第二个参数是一个<code>callback</code>，当<code>setState</code>实际执行完成时会回调这个<code>callback</code></li>\n</ul>\n<pre><code class=\"language-javascript\">ReactComponent.prototype.setState = function(partialState, callback) {\n  !(\n    typeof partialState === \"obejct\" ||\n    typeof partialState === \"function\" ||\n    partialState == null\n  )\n    ? \"警告或者直接报错.....\"\n    : void 0\n  // 将当前更新入队\n  this.updater.enqueueSetState(this, partialState)\n  if (callback) {\n    // 将当前callback入队\n    this.updater.enqueueCallback(this, callback, \"setState\")\n  }\n}\n</code></pre>\n<ul>\n<li><code>forceUpdate()</code>方法，强制更新，谨慎使用，当你知道某些深成次的<code>state</code>已经发生变化了，但没有调用<code>setState()</code>时，你可以调用<code>forceUpdate()</code>。调用<code>forceUpdate()</code>不会触发<code>shouldComponent</code>，会触发<code>componentWillUpdate</code>和<code>componentDidUpdate</code>方法。</li>\n</ul>\n<pre><code class=\"language-javascript\">ReactComponent.prototype.forceUpdate = function(callback) {\n  this.updater.enqueueForceUpdate(this)\n  if (callback) {\n    this.updater.enqueueCallback(this, callback, \"forceUpdate\")\n  }\n}\n</code></pre>\n<p>再来看一下<code>PureComponent</code>，它与<code>Component</code>结构一样，只不过在其原型对象上增加一个<code>isPureComponent=true</code>的属性。</p>\n<pre><code class=\"language-javascript\">function ComponentDummy() {}\nComponentDummy.prototype = ReactComponent.prototype\nReactPureComponent.prototype = new ComponentDummy()\nReactPureComponent.prototype.constructor = ReactPureComponent\n// Avoid an extra prototype jump for these methods.\n_assign(ReactPureComponent.prototype, ReactComponent.prototype)\nReactPureComponent.prototype.isPureReactComponent = true\n</code></pre>\n<p>「react 版本 15.5.4」</p>","tableOfContents":"<ul></ul>","frontmatter":{"title":"阅读react源码--component部分","date":"May 09, 2017","tags":["react"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/react_component_source/","previous":{"fields":{"slug":"/post/react_whole_construct/"},"frontmatter":{"title":"阅读react源码--react整体结构"}},"next":{"fields":{"slug":"/post/reactclass_source/"},"frontmatter":{"title":"阅读react源码--createClass部分"}}}}