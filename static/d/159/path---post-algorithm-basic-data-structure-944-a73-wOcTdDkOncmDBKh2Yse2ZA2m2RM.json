{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"044f2f9a-13a8-5845-8211-3133b4c5d816","excerpt":"…","html":"<p>基础数据结构，最基础的就只有两种，一个是数组，一个是链表。其他的数据结构都是在它们之上抽象出来的，比如，栈，队列，散列表，树，图等。</p>\n<p>基础数据结构，最基础的就只有两种，一个是数组，一个是链表。其他的数据结构都是在它们之上抽象出来的，比如，栈，队列，散列表，树，图等。</p>\n<h3>数组</h3>\n<p>数组在内存中是申请的一组连续的内存空间，在一些强类型语言中，初始化数组时是要事先指定数组大小和类型的，一旦完成，则数组大小和类型不可改变。我们常说的对数组的动态扩容等，其实也是申请更大的数组，然后把旧数组里的数据搬移到新数组里。在 Javascript 中，数组却没有这样的限制，可以随意增加内容，随意改变数组的大小，且数组里元素类型可以不一样。JavaScript 底层中实现数组时，如果元素是同类型的，则使用的是连续的内存空间，如果是不同类型的元素，则应该使用的是类似哈希结构。Javascript 中的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">TypeArray</a>就是使用的连续的内存空间。</p>\n<p>对数组中任意位置元素的访问，是十分高效的。我们可以根据下标值，很快就可以在 O(1)时间内完成访问，而链表则需要移动多次 head 指针才能完成。由于它是一组连续的内存空间，计算机可以一次性把它全部读入内存缓冲区中，下次访问其他位置元素，只需要计算偏移量就可以从内存缓冲区中读取，速度是非常快的。但是对于频繁的插入和删除操作，可能就涉及动态扩容或者维护数据的有序性，那么就会存在额外的数据搬移工作，额外花费的时间可能是 O(n)。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b2aa4baa87ba9f1106e36cb96578c412/fa92b/array.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 14.285714285714285%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAXElEQVQI122O0Q6AIAhF/f+vLX0QELkJaa2m7uzIBZ3JzOAb7nl+DLxe/R+YvbVSFHZfEmbQWSBEoFxAR446XCvI8wGPORFB733/4Aq6KhoLtLXwB88mOuac3Q8voZrtCkiO+O4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"array\"\n        title=\"\"\n        src=\"/static/b2aa4baa87ba9f1106e36cb96578c412/b9e4f/array.png\"\n        srcset=\"/static/b2aa4baa87ba9f1106e36cb96578c412/cf440/array.png 148w,\n/static/b2aa4baa87ba9f1106e36cb96578c412/d2d38/array.png 295w,\n/static/b2aa4baa87ba9f1106e36cb96578c412/b9e4f/array.png 590w,\n/static/b2aa4baa87ba9f1106e36cb96578c412/f9b6a/array.png 885w,\n/static/b2aa4baa87ba9f1106e36cb96578c412/2d849/array.png 1180w,\n/static/b2aa4baa87ba9f1106e36cb96578c412/fa92b/array.png 1400w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<h3>链表</h3>\n<p>链表是由一个一个节点链接起来的，每个节点会存储当前节点的值，还会有一个 next 指针，指向下一个节点。对于第一个节点，会有一个 head 指针指向它，最后一个节点的 next 指向 null。它天生就支持动态扩容或者缩容，由于对内存空间不要求连续，对内存利用率更高。如果需要扩容，就增加节点，插入到链表的某一个节点后面。如果要缩容，就删除释放掉部分不用的节点。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">/*\n  链表节点\n  链表节点用于组成单向链表，双向链表，循环链表等。\n*/</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LinkedNode</span><span class=\"token operator\">&lt;</span>Item<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> val<span class=\"token punctuation\">:</span> Item\n  <span class=\"token keyword\">public</span> next<span class=\"token punctuation\">:</span> LinkedNode<span class=\"token operator\">&lt;</span>Item<span class=\"token operator\">></span>\n  <span class=\"token keyword\">public</span> pre<span class=\"token punctuation\">:</span> LinkedNode<span class=\"token operator\">&lt;</span>Item<span class=\"token operator\">></span>\n  <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">val<span class=\"token punctuation\">:</span> Item<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">:</span> LinkedNode<span class=\"token operator\">&lt;</span>Item<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> pre<span class=\"token punctuation\">:</span> LinkedNode<span class=\"token operator\">&lt;</span>Item<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> next\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pre <span class=\"token operator\">=</span> pre\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>由于它的不连续性，我们在访问链表中某个位置的节点数据时，需要从头开始遍历 head 指针，直到 head 指向要访问的节点，需要的时间复杂度为 O(n)。对于删除或者插入数据，只需要简单的改变上一个节点和当前节点的 next 指针即可，不需要额外的搬移其他节点，时间复杂度一般为 O(1)。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d04fec2743b7ceda6cee6c27fa79a69a/e9603/linkedList.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 14.326647564469914%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAcklEQVQI112OgQ6DMAhE+/+fumSprlBdbXkrVTcnCbmXOwIELmWtYWYdnG2wdzv8b+YKP49hu0EwWbDHxLsUcpxREbIqqyjSVZ8RSQmdZnJXee3smc9LVraYIK9jabDar5e6f3H0+VG78F92162Ca1/4ASR37BwCcluqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"linkedList\"\n        title=\"\"\n        src=\"/static/d04fec2743b7ceda6cee6c27fa79a69a/b9e4f/linkedList.png\"\n        srcset=\"/static/d04fec2743b7ceda6cee6c27fa79a69a/cf440/linkedList.png 148w,\n/static/d04fec2743b7ceda6cee6c27fa79a69a/d2d38/linkedList.png 295w,\n/static/d04fec2743b7ceda6cee6c27fa79a69a/b9e4f/linkedList.png 590w,\n/static/d04fec2743b7ceda6cee6c27fa79a69a/f9b6a/linkedList.png 885w,\n/static/d04fec2743b7ceda6cee6c27fa79a69a/2d849/linkedList.png 1180w,\n/static/d04fec2743b7ceda6cee6c27fa79a69a/e9603/linkedList.png 1396w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>链表有多种变体，比如双向链表，循环链表，双向循环链表等。双向链表，就是节点不仅有一个 next 指针，还有一个 pre 指针，指向前一个节点。由于单向链表只有一个 next 指针，所以只能往后遍历，而双向链表，既可以往后遍历，也可以根据 pre 指针往前遍历，使用非常方便，并且只需要多存储一个 pre 指针即可。在实际应用中，更多的是使用双向链表。循环链表，就是最后一个节点的 next 不指向 null，而是指向第一个节点，从而形成了一个环。</p>\n<p>由于链表中每个节点不仅存储了值，还需要额外的空间存储 next 指针（双向链表还需要存储 pre 指针），所以对于相同数据而言，链表花费的内存空间比数组要大。</p>\n<p>对于链表的掌握，我做了如下一些练习，你可以看看，</p>\n<ul>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/index.ts\">链表-删除链表倒数第 k 个结点</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E9%93%BE%E8%A1%A8-%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/index.ts\">链表-判断回文字符串</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E9%93%BE%E8%A1%A8-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/index.ts\">链表-单向链表的反转</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E9%93%BE%E8%A1%A8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/index.ts\">链表-合并两个有序链表</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E9%93%BE%E8%A1%A8-%E6%A3%80%E6%B5%8B%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/index.ts\">链表-检测链表中是否有环</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E9%93%BE%E8%A1%A8-%E6%B1%82%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/index.ts\">链表-求链表的中间结点</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>访问任意位置元素</th>\n<th>插入或者删除某一个元素</th>\n<th>内存空间</th>\n<th>使用内存大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数组</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>连续</td>\n<td>较小</td>\n</tr>\n<tr>\n<td>链表</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>不连续</td>\n<td>较大</td>\n</tr>\n</tbody>\n</table>\n<h3>栈</h3>\n<p>栈是一种抽象的 LIFO（last in , first out）数据结构。用数组实现的栈，一般称为顺序栈，用链表实现的栈，一般称为链式栈；实际应用中，顺序栈使用较多。栈一般暴露出来的操作，只有出栈和入栈，可能还会有清空，查找等其他辅助操作。它遵循后进，先出的策略，只有通过不停的出栈操作才能遍历或者访问它最开始加入的数据。</p>\n<p>函数调用栈，就是用的这种结构，在一个函数 A 中调用另外一个函数 B，就会先把函数 B 压入到执行栈里，当函数 B 执行完毕之后，就会把函数 B 出栈，继续执行栈顶函数 A。特别是对于递归调用，我们要控制终止条件，不然就会出现递归次数过多，抛出<em>maximum-call-stack-size-exceeded-error</em> 的错误。解决办法可以将递归转化为迭代，或者使用尾递归优化。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9cdb2c82da0f54aced7333fb05fc0373/c236c/stack.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 34.2896174863388%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1ElEQVQoz21RC27FIAzr/W86adLT1LUlH/Cz6aBsWmhEm8TGuBsYjas/rWGE3keGO2om/osVo9gGSJHmiNeOiECtFcm9kCw/XqjHhco51ZLkmhm4Scp9m2puqWhHQbECFxGBZtYH1YuMqVo9HYpFkPZtfnxfaJ9fIKST2HnBmUZizQg8VGmJsInw1jFJH0IN2A1wAqMY8iqdcJDpoFCyp3o/jHa0/XwUrh4Me0VoxwnfD3pos6G600vV7ccSZH2U/rry+nM46FThVOjD/PbUY63/ufIbaVUpfhVgiq8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"stack\"\n        title=\"\"\n        src=\"/static/9cdb2c82da0f54aced7333fb05fc0373/b9e4f/stack.png\"\n        srcset=\"/static/9cdb2c82da0f54aced7333fb05fc0373/cf440/stack.png 148w,\n/static/9cdb2c82da0f54aced7333fb05fc0373/d2d38/stack.png 295w,\n/static/9cdb2c82da0f54aced7333fb05fc0373/b9e4f/stack.png 590w,\n/static/9cdb2c82da0f54aced7333fb05fc0373/f9b6a/stack.png 885w,\n/static/9cdb2c82da0f54aced7333fb05fc0373/2d849/stack.png 1180w,\n/static/9cdb2c82da0f54aced7333fb05fc0373/c236c/stack.png 1464w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>对于栈的掌握，我做了如下一些练习，你可以看看，</p>\n<ul>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/DataStructure/Stack/ArrayStack.ts\">顺序栈</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/DataStructure/Stack/LinkedStack.ts\">链式栈</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E6%A0%88-%E5%AE%9E%E7%8E%B0%E5%9B%9B%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97/index.ts\">栈-实现四则表达式运算</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/Algorithm/%E6%A0%88-%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/index.ts\">栈-实现浏览器的前进后退功能</a></li>\n</ul>\n<h3>队列</h3>\n<p>队列是一种抽象的 FIFO（first in, first out）数据结构。同理，队列也可以用数组或者链表实现。实际应用中，顺序队列使用比较多。队列一般暴露出来的操作，只有入队列和出队列，可能还有清空队列，查找等其他辅助操作。它遵循先进，先出的策略，后加入的元素放在队尾，类似于我们生活中排队买票一样。</p>\n<p>JavaScript 中常说的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop\">event loop</a>，就是队列的应用之一。它会不断的从可执行队列中出队列，取出一个可执行的函数，然后将它放入执行栈中执行。我们在实现 IO 操作，事件监听，或者<code class=\"language-text\">setTimeout</code>时就会入队列操作，将执行函数放入队列末尾。如果更加深入，JavaScript 的 event loop 分为两种队列，一个是 macrotask，一个是 microtask，这里不做更加深入的探讨。</p>\n<p>在使用广度优先搜素（BFS）遍历图时，队列也是常用的数据结构。初始时，随机选择一个节点入队列，然后通过每次从队列里出队列一个节点，访问它，然后把它所有的关联节点都入队列。这样当队列为空时，整个图所有节点就都被访问到了。</p>\n<p>队列也有变体，循环队列，优先级队列。循环队列，跟循环链表类似，循环队列只是我们思维抽象上的环。由于队列入队列时，只能加到队尾，当一个固定大小的队列的尾部有元素时，我们就无法再执行入队列了，即使队列前面有空的位置，这将导致内存空间的浪费。解决办法之一就是我们每次执行出队列时，都移动队列中元素，填充第一个空的位置，这样虽然可以防止队列空间的浪费，但是每次搬移队列中数据，将导致性能急剧下降。解决办法之二就是使用我们的循环队列，计算队尾位置时，并不是我们固定的数组最后一个位置，而是结合队首空的位置来计算。优先级队列，出队列逻辑并不是先入队列的元素出队列，而是优先级高的元素先出队列，如果优先级相同，则先入队列的元素先出队列。堆的应用之一就是优先级队列。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/569a0f69cec24308880fbbb56abf62d1/a4662/queue.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 61.63265306122449%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABF0lEQVQoz31T0ZKDIAz0/7+xTzfTl95D76pFkgB7CQcMCjYzKxriulnighIpJbSIURMYo9asDiAZ39NYWlJhW0nJ4uMHcafynPJ+g+bk+UL0/P/Nkh8JNUIIYGaQ93DOwa0biAjkdtC+g9+6bm84r/fCEBlVHgijqjNSKxRbdw+53SH375wPrHliBN23Z6ufEs68aHZ6QlDEi/1rD8vag1VJhtqQEVSZ80jqceq9nyk8f1EKkbVW/aXNZX/thFMnYFB4VtkTHnLmqbb/yaLlrK6WSWmzZuzKRkh0sAdXHjaFzxXxV8dFx8JGhu1QTK2S2fjEC78rlia9FkrIqL5Zi0Zs7YbJmExbPv8JqffUTvTrgUT8UVnFH8ZftlIgsUYbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"queue\"\n        title=\"\"\n        src=\"/static/569a0f69cec24308880fbbb56abf62d1/b9e4f/queue.png\"\n        srcset=\"/static/569a0f69cec24308880fbbb56abf62d1/cf440/queue.png 148w,\n/static/569a0f69cec24308880fbbb56abf62d1/d2d38/queue.png 295w,\n/static/569a0f69cec24308880fbbb56abf62d1/b9e4f/queue.png 590w,\n/static/569a0f69cec24308880fbbb56abf62d1/f9b6a/queue.png 885w,\n/static/569a0f69cec24308880fbbb56abf62d1/2d849/queue.png 1180w,\n/static/569a0f69cec24308880fbbb56abf62d1/a4662/queue.png 1470w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>对于队列的掌握，我做了如下一些练习，你可以看看，</p>\n<ul>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/DataStructure/Queue/ArrayQueue.ts\">顺序队列</a></li>\n<li><a href=\"https://github.com/snayan/algorithm-demo/blob/master/DataStructure/Queue/LinkedQueue.ts\">链式队列</a></li>\n</ul>\n<h3>散列表</h3>\n<p>散列表又叫哈希表，通常是通过键（key）来存储一个值（value），也就是常用的 key-value 结构。散列表是基于数组抽象出来的，不过它是通过一个 key 来访问一个 value 的，时间复杂度也是 O(1)。当我们存储一个 key-value 时，会先通过散列函数和 key 计算出一个非负整数 index，再把 value 存在下标为 index 的位置。通过 key 查询 value 时，过程也是类似的，也是先通过散列函数和 key 计算出下标 index，然后返回数组中下标为 index 的位置值。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> index <span class=\"token operator\">=</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span></code></pre></div>\n<p>一个好的散列函数，既要计算过程简单，不能消耗太多时间，也要满足生成的下标 index 随机且分布均匀。如果散列函数计算过程非常复杂，每次插入或者查询时都将花费更多的时间，影响性能。如果散列函数生成的 index 不够随机分布，就会增加发生散列冲突的概率，解决散列冲突也会花费额外的时间，也会影响性能。</p>\n<p>如果 k1 通过散列函数得到 i1，我们把 v1 存在数组下标为 i1 的位置；如果 k2 通过散列函数也到 i1，由于 i1 的位置已经被 v1 使用了，v2 不能直接存在 i1 的位置，这个时候就发生了散列冲突。散列冲突的概率不仅受散列函数的影响，也受当前装载因子大小的影响。当装载因子过高时，可以启动动态扩容，减少散列冲突，当装载因子过低时，可以启动动态缩容，释放没有使用的内存空间。</p>\n<blockquote>\n<p>装载因子 = 数组已经使用的元素个数 / 数组的长度</p>\n</blockquote>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fa0fe6b1a80c9e64239425740cae7c60/e9603/hash.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 39.684813753581665%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA20lEQVQoz4WSwQ6CMAyGef838urZgycTEw8eDcoQROhYu99uOEVFaNKwdX+/tawZ1Lz30b/XP3vRr+MQBNsenuWlSZZhZFOgl2uMTQ13voK6DpQbcGengeMkf22ikEUg8qxA3TkHYR7AGic7aGaBca0teRUGfNu2MMagrirt9p0ULiIisF6w2HI6CoDjbo/9ao3DZoueHVK5kiqcBaYKR/B706C8FLhVdUyW1L7CqbmDHc+0/BT7QpPJahJ/CMP/4rwE66NYrY5ORdQtA3UU/o5RGBMZzgNUJh7lASwUd8edNLFoAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"hash\"\n        title=\"\"\n        src=\"/static/fa0fe6b1a80c9e64239425740cae7c60/b9e4f/hash.png\"\n        srcset=\"/static/fa0fe6b1a80c9e64239425740cae7c60/cf440/hash.png 148w,\n/static/fa0fe6b1a80c9e64239425740cae7c60/d2d38/hash.png 295w,\n/static/fa0fe6b1a80c9e64239425740cae7c60/b9e4f/hash.png 590w,\n/static/fa0fe6b1a80c9e64239425740cae7c60/f9b6a/hash.png 885w,\n/static/fa0fe6b1a80c9e64239425740cae7c60/2d849/hash.png 1180w,\n/static/fa0fe6b1a80c9e64239425740cae7c60/e9603/hash.png 1396w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>解决散列冲突常见的方法一种是开放寻址法，一种是链表法。开放寻找法中有一种是线性探测，简单点说就是如果当前位置 i1 已经被使用了，就继续遍历数组后面的位置，直到找到一个为空的位置，然后将 v2 放入。链表法就是数组中存储的是一个链表的地址，通过散列函数得到的下标 index，然后将数组插入当前链表的尾部。这里不做深入说明了，想继续深入的，可以看下面的资料，</p>\n<ul>\n<li><a href=\"https://cs.nyu.edu/courses/fall17/CSCI-UA.0102-001/Notes/HashTableImplementation.html\">散列表</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Hash_table#Open_addressing\">开发寻址法</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Hash_table#Separate_chaining\">链表法</a></li>\n</ul>","frontmatter":{"title":"数据结构和算法-基础数据结构","date":"May 08, 2019","tags":["algorithm","javascript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/algorithm_basic_data_structure/","previous":{"fields":{"slug":"/post/optimize_map_page/"},"frontmatter":{"title":"性能优化篇-地图页面"}},"next":null}}