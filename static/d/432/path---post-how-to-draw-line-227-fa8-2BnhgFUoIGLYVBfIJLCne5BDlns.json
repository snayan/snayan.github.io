{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"572e4885-d2de-5e91-99bf-3eef42216401","excerpt":"这篇是学习和回顾 canvas 系列笔记的第一篇，完整笔记详见：canvas 核心技术\n学习 canvas，首先得知道如何去绘制线段，然后才能通过很多简单的线段去实现比较复杂的图形，比如常见的图表，柱状图，折线图等都是通过一段一段的线段实现的。基础知识canvas…","html":"<p>这篇是学习和回顾 canvas 系列笔记的第一篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>\n学习 canvas，首先得知道如何去绘制线段，然后才能通过很多简单的线段去实现比较复杂的图形，比如常见的图表，柱状图，折线图等都是通过一段一段的线段实现的。</p>\n\n          <h3 id='toc-3-1' >\n            基础知识\n          </h3>\n        \n<p>canvas 的基础知识不算多，主要掌握如何绘制线段，图形，图片，文本等。canvas 可以在浏览器中绘制，也可以借助 <a href=\"https://github.com/Automattic/node-canvas\">node-canvas</a>在 node 服务端绘制简单的图片。本文只记录在浏览器中绘制，至于在 node 端如何绘制，自己可以去查看相关资料。</p>\n<p>在浏览器中绘制，就先在 html 中定义 canvas 元素，默认宽高是 300 * 150，可以通过<code>width</code>和<code>height</code>设置。注意 canvas 元素样式宽高和 canvas 绘图画布宽高不是一个东西，详见<em>知识点 5 中 canvas 宽高</em>。</p>\n<pre><code class=\"language-html\">&#x3C;canvas id=\"canvas\">\n  &#x3C;p>当前浏览器不支持canvas，请升级浏览器&#x3C;/p>\n&#x3C;/canvas>\n</code></pre>\n<!--more-->\n<p>在绘制之前，我们要先获取当前 canvas 的 2d 绘制上下文 context，后续总是通过操作 context 来进行绘制。</p>\n<pre><code class=\"language-javascript\">let canvas = document.querySelector(\"#canvas\")\nif (!canvas) {\n  throw new Error(\"can not find canvas element\")\n}\n// 注意2d.参数必须是小写的；\n// 通过设置参数为webgl，可以获取3d绘制上下文\nlet ctx = canvas.getContext(\"2d\")\n</code></pre>\n<p><em>注：后续示例中会忽略上面的代码片段，直接使用 <code>ctx</code> 变量表示 canvas 的 2d 绘制上下文。</em></p>\n<p>再来看看 canvas 2d 绘制中的坐标系统，当前 canvas 元素左上角为坐标原点(0,0)，水平向右为 X 轴正方向，垂直向下为 Y 轴正方向，如下图。可以通过平移(translate)，旋转(rotate)，缩放(scale)来操作坐标系，实现一些动画，这部分将在动画知识部分详细讲解。</p>\n<p><img src=\"./coordinate.png\" alt=\"坐标系统\"></p>\n\n          <h3 id='toc-3-2' >\n            线段\n          </h3>\n        \n<p>在绘制一条简单的线段时，一般会先设置线段的样式，比如，颜色，线条宽度，线条端点样式等，我们通过设置<code>strokeStyle</code>来设置<code>ctx</code>的全局绘制样式，可以是<code>rgba</code>或合法的 16 进制颜色值，或者渐变对象等。如下代码简单的绘制了一条从(10,10)到(50,60)的，宽度为 10 的，红色的线段。</p>\n<pre><code class=\"language-javascript\">ctx.strokeStyle = \"red\"\nctx.lineWidth = 10\nctx.moveTo(10, 10)\nctx.lineTo(50, 60)\nctx.stroke()\n</code></pre>\n<p><img src=\"./line.jpg\" alt=\"line\"></p>\n<p>先看看与绘制线段相关的方法以及属性，</p>\n<p>相关属性：</p>\n<ul>\n<li>lineCap，该值告诉浏览器如何绘制线段的端点，可选值为以下三个之一：butt，round，square。默认为 butt。</li>\n<li>lineWidth，该值决定了线段的像素宽度。必须为非负，非无穷，默认为 1.0。</li>\n<li>lineJoin，决定了两条线段相交时如何绘制焦点，只有当两条线段方向不同时，才会生效。可取值：bevel，round，miter。默认值是 miter。</li>\n<li>miterLimit，告诉浏览器如何绘制 miter 形式的线段焦点，只有当<code>lineJoin='miter'</code>有效，默认为 10.0。</li>\n<li>lineDashOffset，设置虚线偏移量，默认为 0.0。</li>\n</ul>\n<p>相关方法：</p>\n<ul>\n<li>beginPath，将当前路径之中的所有子路径都要清除掉，以此来重置当前路径。一般在绘制闭合图形时要先调用。</li>\n<li>closePath ,显示的封闭某段路径。该方法用于封闭圆弧路径以及由曲线或线段所创建的开放路径。</li>\n<li>moveTo，移动当前绘制点到指定的坐标。</li>\n<li>lineTo，从上一个点绘制一条到指定坐标点的线段。</li>\n<li>setLineDash，用来设置虚线的方法，参数是一个数组，表明绘制实线的长度，以及实线之间的间隙的长度。</li>\n</ul>\n<p>试试用设置不同的<code>lineCap</code>值来绘制同样的线段</p>\n<pre><code class=\"language-javascript\">ctx.lineWidth = 10\nctx.textAlign = \"center\"\nlet colors = [\"red\", \"green\", \"blue\"]\nlet lineCaps = [\"butt\", \"round\", \"square\"]\nfor (let [index, lc] of lineCaps.entries()) {\n  // 设置线段的颜色\n  ctx.strokeStyle = colors[index]\n  // 设置lineCap\n  ctx.lineCap = lc\n  // 清空当前路径\n  ctx.beginPath()\n  ctx.moveTo(10, 20 + 20 * index)\n  ctx.lineTo(50, 20 + 20 * index)\n  ctx.stroke()\n  ctx.fillText(lc, 80, 25 + 20 * index)\n}\n</code></pre>\n<p><img src=\"./lineCap.jpg\" alt=\"lineCap\"></p>\n<p>从上图结果可以看出，再将<code>lineCap</code>设置为<strong>round</strong> 和<strong>square</strong>时会在原线段的两端加上一定长度的端点，只不过<strong>round</strong>是圆弧样式，<strong>square</strong>是矩形样式。需要注意的一点是，在 canvas 绘制上下文中同一时刻只能存在一个当前路径，为了绘制不同的线段，必须在每次绘制之前调用<code>beginPath()</code>来清空当前路线，开始新的路径。</p>\n<p>再来试试用不同的<code>lineJoin</code>值来绘制两个线段焦点处的样式</p>\n<pre><code class=\"language-javascript\">ctx.lineWidth = 20\nctx.textAlign = \"center\"\nctx.lineCap = \"butt\"\nlet colors = [\"red\", \"green\", \"blue\"]\nlet lineJoins = [\"bevel\", \"round\", \"miter\"]\nfor (let [index, lj] of lineJoins.entries()) {\n  // 设置线段的颜色\n  ctx.strokeStyle = colors[index]\n  // 设置lineJoin\n  ctx.lineJoin = lj\n  // 清空当前路径\n  ctx.beginPath()\n  ctx.moveTo(10 + 80 * index, 20)\n  ctx.lineTo(50 + 80 * index, 20)\n  ctx.lineTo(50 + 80 * index, 60)\n  ctx.stroke()\n  ctx.fillText(lj, 40 + 80 * index, 80)\n}\n</code></pre>\n<p><img src=\"./lineJoin.jpg\" alt=\"lineJoin\"></p>\n<p>可以看到，三种<code>lineJoin</code>在处理两条线段的焦点处的不同。其中，在设置<code>lineJoin=\"miter\"</code>时，通过设置<code>miterLimit</code>属性可以设置斜接线的长度与二分之一线宽的最大比值，当超过这个比值时，则<code>lineJoin</code>会采用<strong>bevel</strong>方式。</p>\n<p>canvas 不仅可以绘制实线，还可以绘制虚线。绘制虚线，通过设置<code>lineDashOffset</code>属性和调用<code>setLineDash()</code>方式。</p>\n<pre><code class=\"language-javascript\">ctx.lineWidth = 10\nctx.textAlign = \"center\"\n// 表示实线部分8个像素，间隙部分8个像素\nctx.setLineDash([8, 8])\nlet colors = [\"red\", \"green\", \"blue\"]\nlet lineDashOffsets = [1, 2, 4]\nfor (let [index, ldOffset] of lineDashOffsets.entries()) {\n  // 线段颜色\n  ctx.strokeStyle = colors[index]\n  // 设置了偏移量\n  ctx.lineDashOffset = ldOffset\n  ctx.beginPath()\n  ctx.moveTo(10, 20 + 20 * index)\n  ctx.lineTo(100, 20 + 20 * index)\n  ctx.stroke()\n  ctx.fillText(`lineDashOffset:${ldOffset}`, 160, 25 + 20 * index)\n}\n</code></pre>\n<p><img src=\"./lineDashOffset.jpg\" alt=\"lineDashOffset\"></p>\n<p>从图可以看到<code>lineDashOffset</code>就是设置的开始绘制虚线的偏移量。<code>setLineDash()</code>方法，接受一个数组参数，如果数组个数是奇数，则会默认把当前数组元素复制一份，使之变成偶数。从第 0 个元素，表示实线部分长度，第 1 个元素，表示间隙部分长度，第 2 个元素，表示实线部分长度，第 3 个元素，表示间隙部分长度，如果到数组最后一个元素了，又会从头开始，以此类推。</p>\n<pre><code class=\"language-javascript\">ctx.lineWidth = 10\nctx.textAlign = \"center\"\nlet colors = [\"red\", \"green\", \"blue\", \"gray\"]\nlet lineDashes = [[20, 20], [40, 40], [20, 40], [20, 40, 20]]\nfor (let [index, ld] of lineDashes.entries()) {\n  ctx.strokeStyle = colors[index]\n  // 设置lineDash\n  ctx.setLineDash(ld)\n  ctx.beginPath()\n  ctx.moveTo(10, 20 + 20 * index)\n  ctx.lineTo(171, 20 + 20 * index)\n  ctx.stroke()\n  ctx.fillText(`lineDashes:[${ld}]`, 240, 25 + 20 * index)\n}\n</code></pre>\n<p><img src=\"./setLineDash.jpg\" alt=\"setLineDash\"></p>\n<p>可以通过动态设置<code>lineDashOffset</code>来实现蚁线，比如选择 PS 中选区边缘的蚁线。</p>\n<pre><code class=\"language-javascript\">// 初始lineDashOffset\nlet lineDashOffset = 0\nctx.strokeStyle = \"green\"\nfunction animate() {\n  if (lineDashOffset > 25) {\n    lineDashOffset = 0\n  }\n  // 清空当前canvas\n  ctx.clearRect(0, 0, width, height)\n  // 设置lineDashOffset\n  ctx.lineDashOffset = -lineDashOffset\n  // 设置实线长度和间隙长度\n  ctx.setLineDash([4, 4])\n  //绘制一个矩形\n  ctx.rect(20, 20, 100, 100)\n  // 对canvas当前路径描边\n  ctx.stroke()\n  // lineDashOffset偏移加1\n  lineDashOffset += 1\n  // 用浏览器帧速率来反复执行animate函数\n  window.requestAnimationFrame(animate)\n}\nanimate()\n</code></pre>\n<p><img src=\"./dynamicLineDashOffset.jpg\" alt=\"dynamicLineDashOffset\"></p>\n\n          <h3 id='toc-3-3' >\n            小结\n          </h3>\n        \n<p>绘制线段时，要理解 canvas 当前路径概念，某一时刻，canvas 中当前路径只有一条，在开始新的路径时，必须调用<code>beginPath()</code>。可以通过设置<code>lineWidth</code>，<code>lineCap</code>，<code>lineJoin</code>设置线段的绘制样式。在描边线段时，可以通过<code>strokeStyle</code>来设置线段的颜色。</p>\n<p>canvas 中不仅可以绘制实线，还可以通过<code>lineDashOffset</code>和<code>setLineDash()</code>来绘制虚线。</p>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">基础知识</a><ul></ul></li><li><a href=\"#toc-3-2\">线段</a><ul></ul></li><li><a href=\"#toc-3-3\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"canvas核心技术-如何绘制线段","date":"July 09, 2018","tags":["canvas"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/how_to_draw_line/","previous":{"fields":{"slug":"/post/core_html5_canvas/"},"frontmatter":{"title":"canvas核心技术"}},"next":{"fields":{"slug":"/post/how_to_draw_graphics/"},"frontmatter":{"title":"canvas核心技术-如何绘制图形"}}}}