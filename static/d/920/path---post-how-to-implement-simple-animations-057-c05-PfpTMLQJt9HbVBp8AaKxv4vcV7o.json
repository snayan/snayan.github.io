{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"7bf9cbfa-51a6-5af5-b2c0-937278069900","excerpt":"这篇是学习和回顾 canvas 系列笔记的第四篇，完整笔记详见：canvas 核心技术。在前面几篇中，我们回顾了在 canvas 中绘制线段，图形，图片等基本功能，当在制作 2d 游戏或者更为丰富的图表库时，必须提供强大的动画功能。canvas 本身不提供像 css 中属性专门来实现动画，但是 canvas…","html":"<p>这篇是学习和回顾 canvas 系列笔记的第四篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>。</p>\n<p>在前面几篇中，我们回顾了在 canvas 中绘制线段，图形，图片等基本功能，当在制作 2d 游戏或者更为丰富的图表库时，必须提供强大的动画功能。canvas 本身不提供像 css 中<code>animation</code>属性专门来实现动画，但是 canvas 提供了<code>translate</code>，<code>scale</code>，<code>rotate</code>等基本功能，我们可以通过组合使用这些功能来实现动画。</p>\n<p>跟动画有关的概念中，我们还要理解<strong>帧速率</strong>。我们通常说一帧，就是浏览器完整绘制一次所经过的时间。现代浏览器的帧速率一般是 60fps，就是在 1s 内可以绘制 60 次。如果帧速率过低，就会觉得明显的卡顿了。一般是帧速率越高，动画越流畅。在 JavaScript 中，我们要在 1s 内绘制 60 次，以前的做法是使用<code>setTimeout</code>或者<code>setInterval</code>来定时执行。</p>\n<pre><code class=\"language-javascript\">setInterval(() => {\n  // 执行绘制操作\n}, 1000 / 60)\n</code></pre>\n<!--more-->\n<p>这种通过定时器的方式，虽然可以实现，但不是最好的方式，它只是以固定的时间间隔向执行队列中添加绘制代码，并不一定能跟浏览器的更新频率同步，并且严重依赖当前执行栈的情况，如果某一次执行栈里执行了复杂大量的运算，那么我们添加的绘制代码可能就不会在我们设置的时间间隔内执行了。在 H5 中，现代浏览器都提供了<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\">requestAnimationFrame</a>这个方法来执行动画更新逻辑，它会在浏览器的下一次更新时执行传递给它的函数，我们完全不必考虑浏览器的帧速率了，可以更加专注于动画更新的逻辑上。</p>\n<pre><code class=\"language-javascript\">const animate = () => {\n  // 执行绘制操作\n  requestAnimationFrame(animate)\n}\nanimate()\n</code></pre>\n<p>当然，如果要兼容以前的浏览器，我们一般需要结合<code>requestAnimationFrame</code>和 <code>setTimeout</code>或者<code>setInterval</code>来实现 polyfill，简单的处理方式大致如下，更好的实现方式可以查看<a href=\"https://gist.github.com/paulirish/1579671\">rAF.js</a>。</p>\n<pre><code class=\"language-javascript\">function myRequestAnimationFrame(callback) {\n  if (requestAnimationFrame) {\n    return requestAnimationFrame(callback)\n  } else {\n    return setTimeout(() => {\n      if (performance &#x26;&#x26; performance.now) {\n        return callback(performance.now())\n      } else {\n        return callback(Date.now())\n      }\n    }, 1000 / 60)\n  }\n}\n\nfunction cancelMyRequestAnimationFrame(id) {\n  if (cancelAnimationFrame) {\n    cancelAnimationFrame(id)\n  } else {\n    clearTimeout(id)\n  }\n}\n</code></pre>\n\n          <h3 id='toc-3-1' >\n            平移\n          </h3>\n        \n<p>在动画处理中，css 可以针对某一个具体的元素来执行平移操作，在 canvas 中，只能平移坐标系，从而间接的改变了 canvas 中元素的位置。在<a href=\"/post/how_to_draw_line/\">canvas 核心技术-如何绘制线段</a>中，详细讲解了 canvas 坐标系相关知识，有兴趣的同学可以先去看看。canvas 坐标系默认原点是在左上角，水平向右为 X 正方向，垂直向下为 Y 正方向。可以通过平移 canvas 坐标系，可以把坐标原点移动到 canvas 中某一块区域，或者 canvas 可见区域外。</p>\n<pre><code class=\"language-javascript\">// 平移坐标系之前\nctx.strokeStyle = \"grey\"\nctx.setLineDash([2, 2])\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke()\n// 平移坐标系\nctx.translate(120, 20) // 平移坐标系，往右平移120px,往下平移20px\nctx.beginPath() // 开始新的路径\nctx.strokeStyle = \"blue\"\nctx.setLineDash([])\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke()\n</code></pre>\n<p><img src=\"./translate.png\" alt=\"translate1\"></p>\n<p>我们在平移之前，在坐标（10，10）处绘制了一个边长都为 100 的矩形，如图灰色虚线矩形，接着，我们调用<code>ctx.translate(120,20)</code>把坐标系向左平移 120 个像素，向下平移了 20 个像素，之后，我们有同样的在坐标（10，10）处绘制了一个边长为 100 的矩形，如图蓝色实线矩形。这两个矩形，我们绘制的坐标和边长都没有改变，但是坐标系被平移了，所以绘制出来的位置也发生了变化。</p>\n<p>坐标系平移示意图如下，</p>\n<p><img src=\"./Canvas_grid_translate.png\" alt=\"Canvas_grid_translate\"></p>\n\n          <h3 id='toc-3-2' >\n            缩放\n          </h3>\n        \n<p>坐标系不仅可以平移，还可以被缩放，canvas 提供了<code>ctx.scale(x,y)</code> 来缩放 X 轴和 Y 轴。在默认情况下，canvas 的缩放因子都是 1.0，表示在 canvas 坐标系中，1 个单位就表示绘制的 1px 长度，如果通过<code>scale</code>函数改变缩放因子为 0.5，则在 canvas 坐标系中，1 个单位就表示绘制 0.5px 长度了，原来的图形被绘制出来就只有一半大小了。</p>\n<pre><code class=\"language-javascript\">ctx.strokeStyle = \"grey\"\nctx.fillStyle = \"yellow\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height) // 填充当前canvas整个区域\nctx.globalAlpha = 1\nctx.setLineDash([2, 2])\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke()\nctx.scale(0.5, 0.5) // 缩放坐标系，X轴和Y轴都同时缩放为0.5\nctx.beginPath() // 开始新的路径\nctx.fillStyle = \"green\"\nctx.strokeStyle = \"red\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height) // 填充缩放之后的canvas整个区域\nctx.globalAlpha = 1\nctx.setLineDash([])\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke()\n</code></pre>\n<p><img src=\"./scale1.png\" alt=\"scale1\"></p>\n<p>可以看到，我们将 X 轴和 Y 轴同时都缩小为原来的一半，新绘制出来的矩形（红色实线）不仅宽高都缩小为原来的一半了，且左上角坐标位置也发生了变化。这里要理解的是，我们在缩放，是针对坐标系缩放的，黄色区域为缩放之前的 canvas 坐标系区域，绿色区域为缩放 0.5 之后的 canvas 坐标系区域。</p>\n<pre><code class=\"language-javascript\">ctx.scale(0.5, 1) // 缩放坐标系，X轴缩放为0.5,Y轴不变\n</code></pre>\n<p><img src=\"./scale2.png\" alt=\"scale2\"></p>\n<p>可以对 X 轴和 Y 轴的缩放因子设置为不一样，如上面示例，对 X 轴缩小为 0.5，而 Y 轴不变，缩放之后的 Canvas 区域在 X 轴上就变为原来的一半了。</p>\n<p>还有一些其他的技巧，比如制作镜像，设置缩放<code>ctx.scale(-1,1)</code>就可以绘制出 Y 轴的对称镜像了。同理，设置缩放<code>ctx.scale(1,-1)</code>就可以绘制出 X 轴的对称镜像了。</p>\n<pre><code class=\"language-javascript\">ctx.font = \"18px sans-serif\"\nctx.textAlign = \"center\"\nctx.translate(width / 2, 0) // 先将坐标系向X轴平移到中间\nctx.strokeStyle = \"grey\" // 设置描边样式\nctx.fillStyle = \"yellow\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([2, 2]) // 设置虚线\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke() // 描边\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nctx.scale(-1, 1) // 缩放坐标系，X轴和Y轴都同时缩放为0.5\nctx.beginPath() // 开始新的路径\nctx.fillStyle = \"green\"\nctx.strokeStyle = \"red\" // 设置描边样式\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke() // 描边\n</code></pre>\n<p><img src=\"./scale3.png\" alt=\"scale3\"></p>\n<p>如图，我们实现了在 Y 轴对称的镜像，在设置缩放之前先平移了坐标系到 X 轴的中间，因为不这样的话，我们缩放之后，绘制出来的部分就在 canvas 可见区域外面了，就看不到了。</p>\n\n          <h3 id='toc-3-3' >\n            旋转\n          </h3>\n        \n<p>在 canvas 中可以通过<code>ctx.rotate(angle)</code>来实现坐标系的旋转，参数<strong>angle</strong>是弧度值，而不是角度值。1 角度等于$\\frac\\pi{180}$，在调用之前需要先进行角度转弧度，计算公式如下，</p>\n<pre><code class=\"language-javascript\">// 角度转换为弧度\nfunction toAngle(degree) {\n  return (degree * Math.PI) / 180\n}\n</code></pre>\n<p>我们来看一个将坐标系旋转 15 角度的示例，如下，</p>\n<pre><code class=\"language-javascript\">ctx.font = \"18px sans-serif\"\nctx.textAlign = \"center\"\nctx.strokeStyle = \"grey\" // 设置描边样式\nctx.fillStyle = \"yellow\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([2, 2]) // 设置虚线\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke() // 描边\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nctx.rotate((15 * Math.PI) / 180) // 将坐标系旋转15角度\nctx.beginPath() // 开始新的路径\nctx.fillStyle = \"green\"\nctx.strokeStyle = \"red\" // 设置描边样式\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke() // 描边\n</code></pre>\n<p><img src=\"./rotate1.png\" alt=\"rotate1\"></p>\n<p>黄色区域是旋转原默认 canvas 坐标系区域，绿色区域就是旋转之后的坐标系区域了，可以看到，旋转操作的实际也是把整个 canvas 坐标都旋转了，canvas 里面的内容都会跟着被旋转。传入的参数<code>angle</code>不仅可以是正数，也可以是负数，正数是顺时针旋转，负数表示逆时针旋转。</p>\n<pre><code class=\"language-javascript\">ctx.rotate((-15 * Math.PI) / 180) // 逆时针旋转15角度\n</code></pre>\n<p><img src=\"./rotate2.png\" alt=\"rotate2\"></p>\n<p>这些使用都比较简单，也好理解。在实际中，可以需要同时对 canvas 坐标系进行平移，缩放和旋转。在这种情况下，我们可以分别单独的使用上面这些方法进行对应的操作，他们的效果是叠加的。在 canvas 中，实际还提供了一个方法，可以同时实现平移，缩放，旋转。下面，我们就来看看这个方法的神奇之处。</p>\n\n          <h3 id='toc-3-4' >\n            transform\n          </h3>\n        \n<p>在进行坐标系数据变换时，最常用的手段就是先建模成单位矩阵，然后对单位矩阵做变换。实际上，上面说的平移，缩放，旋转都是通过变换矩阵实现的，只不过 canvas 给我们封装成具体好用的方法了。canvas 中<code>ctx.transform(a,b,c,d,e,f)</code>提供了 6 个参数，在 canvas 中矩阵是纵向存储的，代表的矩阵为，</p>\n<p>$$\n\\begin{pmatrix}\na&#x26;c&#x26;e\\\nb&#x26;d&#x26;f\\\n0&#x26;0&#x26;1\n\\end{pmatrix} *\n\\begin{pmatrix}\nx\\\ny\\\nz\n\\end{pmatrix} =\n\\begin{pmatrix}\nx^i\\\ny^i\\\nz^i\n\\end{pmatrix}\n$$</p>\n<p>在 2 维坐标系中，表示一个点为$(x,y)$，为了做矩阵变换，我们需要将标准的 2 维坐标扩展到 3 维，需要增加一维<strong>w</strong>，这就是 2 维齐次坐标系$(x,y,w)$。齐次坐标上一点$(x,y,w)$映射到实际的 2 维坐标系中就是$(x/w,y/w)$。如果将点$(x,y,w)$映射在实际 2 维坐标系是$(x,y)$,我们只需要设置 w = 1 就可以了，更多可查看<a href=\"https://blog.csdn.net/janestar/article/details/44244849\">齐次坐标</a>。然后根据矩阵相乘得到的公式如下，</p>\n<p>$$\nx^i=ax+cy+e \\\ny^i=bx+dy+f\n$$</p>\n<p>先来看看平移，我们看看把一个点$(x,y)$平移到另外一个点$(x^i,y^i)$。公式如下，</p>\n<p>$$\nx^i=x+d<em>x \\\ny^i=y+d</em>y\n$$</p>\n<p>将平移公式代入到上面我们推到出来的矩阵变换公式中可以得到，$a=1$，$c=0$，$e=d<em>x$，$b=0$，$d=1$，$f=d</em>y$。我们用<code>transform</code>实现平移，只需要调用$ctx.transform(1,0,0,1,d<em>x,d</em>x)$，效果跟调用$ctx.translate(d<em>x,d</em>y)$一样的。</p>\n<pre><code class=\"language-javascript\">// 平移坐标系之前\nctx.strokeStyle = \"grey\"\nctx.setLineDash([2, 2])\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke()\n// 平移坐标系\n// ctx.translate(120,20);\n// 平移坐标系，往右平移120px,往下平移20px\nctx.transform(1, 0, 0, 1, 120, 20) // 使用transform来平移\nctx.beginPath() // 开始新的路径\nctx.strokeStyle = \"blue\"\nctx.setLineDash([])\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke()\n</code></pre>\n<p><img src=\"./transform1.png\" alt=\"transform1\"></p>\n<p>可以看到，<code>ctx.translate(120,20)</code>与<code>ctx.transform(1, 0, 0, 1, 120, 20)</code>得到的效果是一样的。</p>\n<p>再来看看缩放，我们把一个点$(x,y)$ 通过缩放坐标系 k 之后，得到的新的点的坐标为$(x^i,y^i)$。公式如下，</p>\n<p>$$\nx^i=k<em>x \\\ny^i=k</em>y\n$$</p>\n<p>我们也将缩放公式代入到矩阵变换公式中，可以得到$a = k$，$c = 0$，$e = 0$，$b = 0$，$d = k$，$f = 0$。我们用<code>transform</code>来实现缩放，只需要调用<code>ctx.transform(k,0,0,k,0,0)</code>，效果跟调用<code>ctx.scale(k,k)</code>一样的。</p>\n<pre><code class=\"language-javascript\">ctx.strokeStyle = \"grey\"\nctx.fillStyle = \"yellow\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height) // 填充当前canvas整个区域\nctx.globalAlpha = 1\nctx.setLineDash([2, 2])\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke()\n// ctx.scale(0.5, 0.5);\n// 缩放坐标系，X轴和Y轴都同时缩放为0.5\nctx.transform(0.5, 0, 0, 0.5, 0, 0) // 使用transform来缩放\nctx.beginPath() // 开始新的路径\nctx.fillStyle = \"green\"\nctx.strokeStyle = \"red\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height) // 填充缩放之后的canvas整个区域\nctx.globalAlpha = 1\nctx.setLineDash([])\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke()\n</code></pre>\n<p><img src=\"./transform2.png\" alt=\"transform2\"></p>\n<p>可以看到，调用<code>ctx.transform(0.5,0,0,0.5,0,0)</code>与<code>ctx.scale(0.5,0.5)</code>效果是一样的。</p>\n<p>最后来看看旋转，我们把一个坐标$(x,y)$在旋转坐标角度$\\beta$之后得到新的坐标$(x^i,y^i)$，公式如下，</p>\n<p>$$\nx^i=cos(\\beta)<em>x-sin(\\beta)</em>y \\\ny^i=sin(\\beta)<em>x+cos(\\beta)</em>y\n$$</p>\n<p>上面的公式，是根据三角形两角和差公式计算出来的，推导详见<a href=\"https://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/2drota.htm\">2D Rotation</a>。同理，我们将旋转公式代入到矩阵变换公式可以得到$a=\\cos(\\beta)$，$c=-\\sin(\\beta)$，$e=0$，$b=\\sin(\\beta)$，$d=\\cos(\\beta)$，$f=0$。我们调用<code>ctx.transform(cos(β),sin(β),-sin(β),cos(β),0,0)</code>与$ctx.rotate(\\beta)$是一样的。注意，我们这里的$\\beta$是弧度值。</p>\n<pre><code class=\"language-javascript\">ctx.font = \"18px sans-serif\"\nctx.textAlign = \"center\"\nctx.strokeStyle = \"grey\" // 设置描边样式\nctx.fillStyle = \"yellow\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([2, 2]) // 设置虚线\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke() // 描边\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\n// ctx.rotate(15* Math.PI/180); // 将坐标系旋转15角度\nlet angle = (15 * Math.PI) / 180 // 计算得到弧度值\nlet cosAngle = Math.cos(angle) // 计算余弦\nlet sinAngle = Math.sin(angle) // 计算正弦\nctx.transform(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0) // 使用transform旋转\nctx.beginPath() // 开始新的路径\nctx.fillStyle = \"green\"\nctx.strokeStyle = \"red\" // 设置描边样式\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke() // 描边\n</code></pre>\n<p><img src=\"./transform3.png\" alt=\"transform3\"></p>\n<p>可以看到调用<code>ctx.transform(cosAngle,sinAngle,-sinAngle,cosAngle,0,0)</code>与<code>ctx.rotate(angle)</code>是一样的效果。</p>\n<p>上面三种基本的操作坐标系的方式，我们都可以通过<code>transform</code>实现，通过组合，我们可以一次性设置坐标系的平移，旋转，缩放，只需要计算出正确的 a，b，c，d，e，f。例如，我们将上面三种操作同时实现，先平移，再缩放，最后再旋转，分别给出<code>translate</code>+<code>scale</code>+<code>rotate</code>来实现，和<code>transform</code>来实现，</p>\n<ul>\n<li><code>translate</code>+<code>scale</code>+<code>rotate</code>组合实现</li>\n</ul>\n<pre><code class=\"language-javascript\">ctx.font = \"18px sans-serif\"\nctx.textAlign = \"center\"\nctx.strokeStyle = \"grey\" // 设置描边样式\nctx.fillStyle = \"yellow\"\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([2, 2]) // 设置虚线\nctx.rect(10, 10, 100, 100) // 绘制矩形\nctx.stroke() // 描边\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nlet angle = (15 * Math.PI) / 180\nctx.translate(120, 20) // 先平移\nctx.scale(0.5, 0.5) // 再缩放\nctx.rotate(angle) // 最后再旋转\nctx.beginPath() // 开始新的路径\nctx.fillStyle = \"green\"\nctx.strokeStyle = \"red\" // 设置描边样式\nctx.globalAlpha = 0.5\nctx.fillRect(0, 0, width, height)\nctx.globalAlpha = 1\nctx.setLineDash([]) // 设置实线\nctx.strokeText(\"我是文字\", 60, 60)\nctx.rect(10, 10, 100, 100) // 绘制同样的矩形\nctx.stroke() // 描边\n</code></pre>\n<p><img src=\"./transform4.png\" alt=\"transform4\"></p>\n<ul>\n<li><code>transform</code>一次性实现</li>\n</ul>\n<pre><code class=\"language-javascript\">let angle = (15 * Math.PI) / 180\n// ctx.translate(120, 20);\n// ctx.scale(0.5, 0.5);\n// ctx.rotate(angle);\nlet cosAngle = Math.cos(angle)\nlet sinAngle = Math.sin(angle)\nctx.transform(\n  0.5 * cosAngle,\n  0.5 * sinAngle,\n  -0.5 * sinAngle,\n  0.5 * cosAngle,\n  120,\n  20\n)\n</code></pre>\n<p><img src=\"./transform5.png\" alt=\"transform5\"></p>\n<p>这两种方式最终得到的效果是一样的，其实在将<code>translate</code>+<code>scale</code>+<code>rotate</code>组合用<code>transform</code>一次性实现时，就是在做矩阵的变换计算，</p>\n<p>$$\n\\begin{pmatrix}\n1&#x26;0&#x26;120 \\\n0&#x26;1&#x26;20 \\\n0&#x26;0&#x26;1\n\\end{pmatrix} *\n\\begin{pmatrix}\n0.5&#x26;0&#x26;0 \\\n0&#x26;0.5&#x26;0 \\\n0&#x26;0&#x26;1\n\\end{pmatrix} *\n\\begin{pmatrix}\ncos(\\beta)&#x26;-sin(\\beta)&#x26;0 \\\nsin(\\beta)&#x26;cos(\\beta)&#x26;0 \\\n0&#x26;0&#x26;1\n\\end{pmatrix} =\n\\begin{pmatrix}\n0.5<em>cos(\\beta)&#x26;-0.5</em>sin(\\beta)&#x26;120 \\\n0.5<em>sin(\\beta)&#x26;0.5</em>cos(\\beta)&#x26;20 \\\n0&#x26;0&#x26;1\n\\end{pmatrix}\n$$</p>\n<p>三个矩阵相乘，分别是「平移矩阵 * 缩放矩阵 * 旋转矩阵」，根据计算出来的矩阵，最后代入到公式中，可以得到$a=0.5<em>\\cos(\\beta)$，$b=0.5</em>\\sin(\\beta)$，$c=-0.5<em>\\sin(\\beta)$，$d=0.5</em>\\cos(\\beta)$，$e=120$，$f=20$。</p>\n<p><code>transform</code>如果多次调用，它的效果也是叠加的，例如，我们也可以分开用<code>transform</code>来实现上面的平移，缩放，旋转，</p>\n<pre><code class=\"language-javascript\">ctx.transform(1, 0, 0, 1, 120, 20) // 使用transform来平移\nctx.transform(0.5, 0, 0, 0.5, 0, 0) // 使用transform来缩放\nctx.transform(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0) // 使用transform旋转\n</code></pre>\n<p>第二次调用<code>transform</code>来缩放，是在第一次平移之后的坐标系上进行的，第三次调用<code>transform</code>来旋转，是在第一次和第二次结果上来进行的。canvas 中提供了<code>setTransform</code>函数，它类似于<code>transform</code>函数，同样接受 a，b，c，d，e，f 这 6 个参数，且参数含义与<code>transform</code>中一摸一样，跟<code>transform</code>不同之处在于，<strong>它不会叠加矩阵变换的效果，它会先重置当前坐标系矩阵为默认的单元矩阵</strong>，之后再执行跟<code>transform</code>一样的矩阵变换。所以，如果我们在调用<code>transform</code>变换矩阵时，不想多次调用叠加，那么可以替换使用<code>setTransform</code>。实际上还有一个实验性的函数<code>resetTransform</code>，它的作用就是重置当前坐标系矩阵为默认的单元矩阵，去掉了作用在默认坐标系上的变换效果，注意它是一个实验性的函数，还有很多浏览器都没有提供支持，不建议使用。通过分析，我们可以得到，</p>\n<p>$$\nsetTransform(a,b,c,d,e,f)=resetTransform() + transform(a,b,c,d,e,f)\n$$</p>\n\n          <h3 id='toc-3-5' >\n            小结\n          </h3>\n        \n<p>这篇文章主要是学习和回顾了 canvas 中坐标系的变换，我们是通过矩阵变换来实现 canvas 坐标系的变化，包括<code>translate</code>，<code>scale</code>，<code>rotate</code>，<code>transform</code>，<code>setTransform</code>，通过组合使用，可以实现强大的动画效果。实际上，动画效果应该在一段时间内持续变化，这篇文章，只学习了单一的变化，还没有涉及时间等动画因素，下一篇准备学习和回顾动画的高级知识，包括时间因素，物理因素，时间扭曲变化函数等。</p>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">平移</a><ul></ul></li><li><a href=\"#toc-3-2\">缩放</a><ul></ul></li><li><a href=\"#toc-3-3\">旋转</a><ul></ul></li><li><a href=\"#toc-3-4\">transform</a><ul></ul></li><li><a href=\"#toc-3-5\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"canvas核心技术-如何实现简单的动画","date":"August 11, 2018","tags":["canvas"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/how_to_implement_simple_animations/","previous":{"fields":{"slug":"/post/how_to_draw_image_and_text/"},"frontmatter":{"title":"canvas核心技术-如何绘制图片和文本"}},"next":{"fields":{"slug":"/post/how_to_implement_complex_animations/"},"frontmatter":{"title":"canavs核心技术-如何实现复杂的动画"}}}}