{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"592210ae-8402-593c-b6ed-06b7e8d0546c","excerpt":"上一篇文章中，学习了 flutter 跨平台的特性，以及 dart 的包管理器 pub。这一篇，我们将详细了解 flutter 很重要的一个概念，widget。组件flutter 是响应式的，它通过编程方式去写 UI 页面，而不是像 html 或者 android 中的 xml 等模版语言去定义 UI…","html":"<p><a href=\"/post/2019/flutter-learn-1\">上一篇文章</a>中，学习了 flutter 跨平台的特性，以及 dart 的包管理器 pub。这一篇，我们将详细了解 flutter 很重要的一个概念，widget。</p>\n<h2>组件</h2>\n<p>flutter 是响应式的，它通过编程方式去写 UI 页面，而不是像 html 或者 android 中的 xml 等模版语言去定义 UI。它借鉴了 React，也是以组件的方式去定义一个一个 UI 部件。</p>\n<blockquote>\n<p>Flutter widgets are built using a modern framework that takes inspiration from <a href=\"https://reactjs.org/\">React</a>.</p>\n</blockquote>\n<h3>分类</h3>\n<p>在 flutter 中一切皆是 widget。按照状态划分，可以分为 StatelessWidget 和 StatefulWidget，与 React 中的 Stateful Class Component 和 Stateless Function Component 比较类似；按照功能划分，又有 layout widget，style widget，content widget；按照 child 接受单个 widget，或者多个 widget，又有 SingleChildRenderObjectWidget 和 MultiChildRenderObjectWidget。常见 widget 如下，</p>\n<ol>\n<li>layout widget，例如<code class=\"language-text\">Scaffold</code>，<code class=\"language-text\">Row</code>，<code class=\"language-text\">Column</code>，<code class=\"language-text\">Container</code>等；</li>\n<li>style widget，例如<code class=\"language-text\">Container</code>，<code class=\"language-text\">Padding</code>，<code class=\"language-text\">Center</code>等；</li>\n<li>content widget，例如<code class=\"language-text\">Text</code>，<code class=\"language-text\">Image</code>，<code class=\"language-text\">RaisedButton</code>等；</li>\n</ol>\n<p>在开发 flutter 页面时，可以通过组合多个 widget，实现一个复杂或者独立功能的自定义 widget。对于描述一个 widget 的样式时，需要使用样式 widget 进行包装，或者更改 widget 提供的某些样式属性，比如<code class=\"language-text\">Container</code>的<code class=\"language-text\">padding</code>属性等。</p>\n<h3>实现</h3>\n<p>在开发自定义 widget 时，一般都是继承自 StatelessWidget，或者 StatefulWidget。StatelessWidget 和 StatefulWidget 又都是继承自 Widget。下面我们通过源码来看看它们的实现。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token comment\">/// 列出主要实现，去掉了其他不重要的属性或者方法</span>\n<span class=\"token metadata symbol\">@immutable</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">DiagnosticableTree</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">final</span> Key key<span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  Element <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">static</span> bool <span class=\"token function\">canUpdate</span><span class=\"token punctuation\">(</span>Widget oldWidget<span class=\"token punctuation\">,</span> Widget newWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> oldWidget<span class=\"token punctuation\">.</span>runtimeType <span class=\"token operator\">==</span> newWidget<span class=\"token punctuation\">.</span>runtimeType\n      <span class=\"token operator\">&amp;&amp;</span> oldWidget<span class=\"token punctuation\">.</span>key <span class=\"token operator\">==</span> newWidget<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Widget 是一个抽象类，主要有一个<code class=\"language-text\">createElement</code>的抽象方法和<code class=\"language-text\">canUpdate</code>的静态方法。<code class=\"language-text\">createElement</code>需要由继承它的子类来实现，必须返回一个 Element 对象，每一个 widget 都会有一个关联的 element 对象；在 Widget 上面有<code class=\"language-text\">@immutable</code>声明，描述 widget 对象是不可变的，它的属性都应该使用<code class=\"language-text\">final</code>标记，每次做 rebuild 时，都只会重新创建新的 widget 对象。widget 是不可变的，但是 element 是可变的，可以把 widget 看成是 element 的静态配置信息，最终是用 element 信息来完成渲染的。为了尽可能复用 element 对象，每次更新时都会先调用<code class=\"language-text\">canUpdate</code>，通过<code class=\"language-text\">runtimeType</code>和<code class=\"language-text\">key</code>来比较新旧 widget，如果返回 true，则复用旧的 element，并更新 element 的 widget 为新的 widget，否则调用新的 widget 的<code class=\"language-text\">createElement</code>来生成新的 element。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StatelessWidget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">StatelessWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> Key key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  StatelessElement <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">StatelessElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>对于 StatelessWidget 的实现，它继承 Widget，重写了<code class=\"language-text\">createElement</code>用于生成一个<code class=\"language-text\">StatelessElement</code>。它还声明了一个<code class=\"language-text\">build</code>方法，接受一个<code class=\"language-text\">BuildContext</code>参数，并返回一个 Widget。实际上，这个<code class=\"language-text\">BuildContext</code>就是上面通过<code class=\"language-text\">createElement</code>创建的 Element 对象，下面将会解释到。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StatefulWidget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">StatefulWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> Key key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  StatefulElement <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">StatefulElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  State <span class=\"token function\">createState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>对于 StatefulWidget，就复杂一些了。它跟 StatelessWidget 一样，继承 Widget，提供一个<code class=\"language-text\">createElement</code>方法，但是返回是<code class=\"language-text\">StatefulElement</code>对象；跟 StatelessWidget 不一样的是，它没有声明<code class=\"language-text\">build</code>方法，而是有一个<code class=\"language-text\">createState</code>方法，生成一个 State 对象。前面说过，Widget 是不可变的，每次 rebuild 都会销毁和重建，所以状态不能直接放在 widget 中，而是需要独立出来，关联到 element 上，这样状态才不会丢失。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RenderObjectWidget</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function\">RenderObjectWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> Key key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  RenderObjectElement <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  RenderObject <span class=\"token function\">createRenderObject</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">updateRenderObject</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">,</span> covariant RenderObject renderObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">didUnmountRenderObject</span><span class=\"token punctuation\">(</span>covariant RenderObject renderObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>RenderObjectWidget，是比较特殊的一类 widget。它声明了<code class=\"language-text\">createRenderObject</code>去创建一个 RenderObject，而在 flutter 中真正被渲染的对象就是 RenderObject。上面提到的 StatelessWidget，StatefulWidget，它们都没有直接提供 RenderObject 的实现，而是通过组合其他 RenderObjectWidget，从而实现渲染出某一个部分组合 UI。根据接受的参数个数，它有两个子类，</p>\n<ol>\n<li>\n<p>SingleChildRenderObjectWidget，仅接受一个 child，比如 Padding；</p>\n</li>\n<li>\n<p>MultiChildRenderObjectWidget，可以接受多个 child，比如 Row；</p>\n</li>\n</ol>\n<h2>State</h2>\n<p>StatefulWidget 会通过<code class=\"language-text\">createState</code>生成一个 State 对象，它会被关联到对应的 StatefulElement 上。State 不会随着 widget 的销毁而销毁，而是会保持其生命期跟随着 element。一个 State 对象，在整个生命周期内，会有不同的阶段，为了方便开发者针对不同阶段处理一些事情，它会暴露出相应的钩子函数，类似生命周期方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token metadata symbol\">@optionalTypeArgs</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">State</span><span class=\"token operator\">&lt;</span>T <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StatefulWidget</span><span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Diagnosticable</span> <span class=\"token punctuation\">{</span>\n  T <span class=\"token keyword\">get</span> widget <span class=\"token operator\">=</span><span class=\"token operator\">></span> _widget<span class=\"token punctuation\">;</span>\n  T _widget<span class=\"token punctuation\">;</span>\n\n  _StateLifecycle _debugLifecycleState <span class=\"token operator\">=</span> _StateLifecycle<span class=\"token punctuation\">.</span>created<span class=\"token punctuation\">;</span>\n\n  BuildContext <span class=\"token keyword\">get</span> context <span class=\"token operator\">=</span><span class=\"token operator\">></span> _element<span class=\"token punctuation\">;</span>\n  StatefulElement _element<span class=\"token punctuation\">;</span>\n\n  bool <span class=\"token keyword\">get</span> mounted <span class=\"token operator\">=</span><span class=\"token operator\">></span> _element <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token metadata symbol\">@mustCallSuper</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">initState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@mustCallSuper</span>\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">didUpdateWidget</span><span class=\"token punctuation\">(</span>covariant T oldWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>VoidCallback fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">dynamic</span> result <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">as</span> <span class=\"token keyword\">dynamic</span><span class=\"token punctuation\">;</span>\n    _element<span class=\"token punctuation\">.</span><span class=\"token function\">markNeedsBuild</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token metadata symbol\">@mustCallSuper</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">deactivate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token metadata symbol\">@mustCallSuper</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">dispose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  Widget <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>BuildContext context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token metadata symbol\">@mustCallSuper</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">didChangeDependencies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>State 对象会持有 StatefulWidget 的引用_widget，还有一个_StateLifecycle 状态。在不同的阶段，会调用不同的方法，然后_StateLifecycle 的值也会不一样，类似 react 中的生命周期方法。这里主要有如下生命周期方法，</p>\n<ol>\n<li><code class=\"language-text\">initState</code>，初始化时执行，一般用于执行申请资源等操作，不可以执行<code class=\"language-text\">setState</code>，在 state 的生命里只会调用一次。</li>\n<li><code class=\"language-text\">didChangeDependencies</code>，如果在<code class=\"language-text\">build</code>中有调用<code class=\"language-text\">BuildContext.inheritFromWidgetOfExactType</code>，而且 inherited widgets 有变化，则会触发此方法。可以根据变化，调用<code class=\"language-text\">setState</code>来更新当前 children widgets。</li>\n<li><code class=\"language-text\">didUpdateWidget</code>，当 element 上调用的<code class=\"language-text\">canUpdate</code>返回 true 时，也就是复用 element，更新 element 关联的 widget 时会触发此方法。state 需要根据新的 widget 来作出改变。在执行完<code class=\"language-text\">didUpdateWidget</code>时，框架紧接着会执行 statet 的<code class=\"language-text\">build</code>方法来更新 UI，所以不应该在此方法中执行<code class=\"language-text\">setState</code> 。</li>\n<li><code class=\"language-text\">deactivate</code>，当 element 上调用的<code class=\"language-text\">canUpdate</code>返回 false 时，会卸载当前的 element，随即也会卸载当前的 element 关联的 state，则会触发此方法。State 会被从树中移除，应该在此方法里解除它与其他 element 的引用关系。</li>\n<li><code class=\"language-text\">dispose</code>，销毁时执行，一般用于释放在<code class=\"language-text\">initState</code>中申请的资源，不可以执行<code class=\"language-text\">setState</code></li>\n</ol>\n<p>State 会有一个 context 的属性，它实际就是 widget 的 element 对象。State 有一个比较重要的方法<code class=\"language-text\">setState</code>，每次调用它，都会触发当前 widget 的更新。在上面的实现中，可以看到它调用了<code class=\"language-text\">_element.markNeedsBuild()</code>，将当前 element 标记为 dirty，然后在下一个 frame 中会重新执行 rebuild。如果直接更改 state 中的值，是不会触发 widget 的更新的。</p>\n<h2>Element Tree</h2>\n<p>通过上面的部分源码分析，真正负责渲染的 widget 对象是 RenderObjectWidget，它会生成 Element 和 RenderObject，关系如下</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7f0a5f9d8b3da015b39376e14523d299/4f3bc/internals_element.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 42.58720930232558%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAA6UlEQVQoz3WS2wqEMAxE+/9fqA+K6JOI9/s1yylkyXZ3B4YUEyfJtO55HlECjYr7vmVZFtm2zcc8z6UsS/9d6y2d/dmKIgCnaZJxHOU4DlnX1eeu65J9338O4OhEgU0gdJ7nR2fq4DzPXpi83ULpKGAVIlMgzhnwE+JMowJ938swDL5Oa9lC6bqu8weKiIiyIqjrWqIokjiOvW8AARrQiEmbppG2baWqKh8dAiSJui5FoTcKRCyYnAba5ONS1HioXmEH1O+c7e2GcGHCmm2bqPnh8/p6NlYsyzIpikKSJJE0Td9Gh03+2QFeqH7B9I8Y60wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/7f0a5f9d8b3da015b39376e14523d299/cc182/internals_element.webp 148w,\n/static/7f0a5f9d8b3da015b39376e14523d299/f7e40/internals_element.webp 295w,\n/static/7f0a5f9d8b3da015b39376e14523d299/1a2f4/internals_element.webp 590w,\n/static/7f0a5f9d8b3da015b39376e14523d299/99208/internals_element.webp 688w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/7f0a5f9d8b3da015b39376e14523d299/cf440/internals_element.png 148w,\n/static/7f0a5f9d8b3da015b39376e14523d299/d2d38/internals_element.png 295w,\n/static/7f0a5f9d8b3da015b39376e14523d299/b9e4f/internals_element.png 590w,\n/static/7f0a5f9d8b3da015b39376e14523d299/4f3bc/internals_element.png 688w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/7f0a5f9d8b3da015b39376e14523d299/b9e4f/internals_element.png\"\n          alt=\"internals_element\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>把它们与 React 中元素来做类似关联，应该就比较明白它们的作用了，</p>\n<ol>\n<li>widget，类似于 React 中 Component，用于定义 UI 应该展示什么样子，在最上层。</li>\n<li>element，类似于 React 中 Component 生成的 vdom 对象，这里会做一些复用逻辑和渲染优化，用于为真正渲染对象提供数据，位于中间层。</li>\n<li>renderObject，类似于真正的 DOM 了，真正的渲染对象，在最底层了。</li>\n</ol>\n<p>react 会形成一颗虚拟的 dom 树，flutter 中也在 element 这一层生成一颗 element 树。</p>\n<p>flutter 框架会帮我们处理好 element 和 renderObject 层，对于一般业务开发，我们只需要在 widget 层去实现功能即可。框架会在三个地方帮我们调用<code class=\"language-text\">createElement</code>去生成对应的 element 对象，下面我们分别来看看这三个地方。</p>\n<p>第一个地方就是生成 element 树的根节点。flutter 是通过调用<code class=\"language-text\">runApp</code>来启动的，如下</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">runApp</span><span class=\"token punctuation\">(</span><span class=\"token function\">MyApp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在<code class=\"language-text\">runApp</code>中会做很多初始化的工作，其中就包含了生成 element 树的根节点并挂载。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">runApp</span><span class=\"token punctuation\">(</span>Widget app<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  WidgetsFlutterBinding<span class=\"token punctuation\">.</span><span class=\"token function\">ensureInitialized</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">/// 这里就会生成element树的根节点</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token function\">scheduleAttachRootWidget</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token function\">scheduleWarmUpFrame</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>沿着<code class=\"language-text\">scheduleAttachRootWidget</code>调用栈一路找下去，最后会生成一个<code class=\"language-text\">RenderObjectToWidgetAdapter</code>对象，并调用它的<code class=\"language-text\">attachToRenderTree</code>方法，</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RenderObjectToWidgetAdapter</span><span class=\"token operator\">&lt;</span>T <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RenderObject</span><span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RenderObjectWidget</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  RenderObjectToWidgetElement<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> RenderObjectToWidgetElement<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  RenderObjectToWidgetElement<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">attachToRenderTree</span><span class=\"token punctuation\">(</span>BuildOwner owner<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span> RenderObjectToWidgetElement<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> element <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>element <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      owner<span class=\"token punctuation\">.</span><span class=\"token function\">lockState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 如果root element为空，则调用createElement生成root element</span>\n        element <span class=\"token operator\">=</span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">assert</span><span class=\"token punctuation\">(</span>element <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        element<span class=\"token punctuation\">.</span><span class=\"token function\">assignOwner</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      owner<span class=\"token punctuation\">.</span><span class=\"token function\">buildScope</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 并挂载在element树上</span>\n        element<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// This is most likely the first time the framework is ready to produce</span>\n      <span class=\"token comment\">// a frame. Ensure that we are asked for one.</span>\n      SchedulerBinding<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span><span class=\"token function\">ensureVisualUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      element<span class=\"token punctuation\">.</span>_newWidget <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n      element<span class=\"token punctuation\">.</span><span class=\"token function\">markNeedsBuild</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>先判断当前 root element 存不存在，如果不存在，就会调用<code class=\"language-text\">createElement</code>生成新的 root element，并调用<code class=\"language-text\">element.mount(null, null)</code>进行挂载</p>\n<p>第二个地方就是进行 mount 时，如果当前 element 是 MultiChildRenderObjectElement，则会为它的 widget 的 children widget 生成对应的 element，并挂载。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\">  <span class=\"token keyword\">void</span> <span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>Element parent<span class=\"token punctuation\">,</span> <span class=\"token keyword\">dynamic</span> newSlot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> newSlot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    _children <span class=\"token operator\">=</span> List<span class=\"token operator\">&lt;</span>Element<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>widget<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Element previousChild<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>int i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> _children<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/// inflateWidget就是调用createElement并进行mount</span>\n      <span class=\"token keyword\">final</span> Element newChild <span class=\"token operator\">=</span> <span class=\"token function\">inflateWidget</span><span class=\"token punctuation\">(</span>widget<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> previousChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      _children<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newChild<span class=\"token punctuation\">;</span>\n      previousChild <span class=\"token operator\">=</span> newChild<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\">  Element <span class=\"token function\">inflateWidget</span><span class=\"token punctuation\">(</span>Widget newWidget<span class=\"token punctuation\">,</span> <span class=\"token keyword\">dynamic</span> newSlot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">assert</span><span class=\"token punctuation\">(</span>newWidget <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> Key key <span class=\"token operator\">=</span> newWidget<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">is</span> GlobalKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/// ...</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">final</span> Element newChild <span class=\"token operator\">=</span> newWidget<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    newChild<span class=\"token punctuation\">.</span><span class=\"token function\">mount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> newSlot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> newChild<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>第三个地方就是进行 rebuild 时，更新 child element，如果 child element 为 null，且新的 widget 不为 null，则也会调用<code class=\"language-text\">inflateWidget</code>来新建 element 且挂载。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\">Element <span class=\"token function\">updateChild</span><span class=\"token punctuation\">(</span>Element child<span class=\"token punctuation\">,</span> Widget newWidget<span class=\"token punctuation\">,</span> <span class=\"token keyword\">dynamic</span> newSlot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// newWidget为null，则直接返回null</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newWidget <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/// ...</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n   <span class=\"token comment\">//child不为null，且newWidget也不为null</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>child <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 如果widget相等，则直接用之前的element</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">.</span>widget <span class=\"token operator\">==</span> newWidget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/// ...</span>\n        <span class=\"token keyword\">return</span> child<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 如果canUpdate返回true，也直接用之前的element</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Widget<span class=\"token punctuation\">.</span><span class=\"token function\">canUpdate</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">.</span>widget<span class=\"token punctuation\">,</span> newWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/// ...</span>\n        child<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>newWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> child<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n   <span class=\"token comment\">// child element为null，且newWidget不为null，则生成新的child element</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">inflateWidget</span><span class=\"token punctuation\">(</span>newWidget<span class=\"token punctuation\">,</span> newSlot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>在维护更新 element 树的同时，会每次将更新点同步到 RenderObject 上。最后，flutter 根据 RenderObject 来渲染出页面。为了更高效的渲染，在 layout 阶段会通过 RelayoutBoundary 来控制 relayout 的范围，在 paint 阶段会通过 RepaintBoundary 只重新绘制受响应的部分。</p>\n<h2>结构图</h2>\n<p>从 Widget，Element，RenderObject 角度分别列举了它们的父类和子类，</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ef851692a408435ff5ad219739abc2de/fd995/structure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 51.73228346456693%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQoz32RyVLDMAyG+/6vAxcOnWEphV6YAgMzbZpmT+wmbhJv8RI7OGSgB1o0PtiSP+mXNBv+NSNElyUCleZcdHYJs8b21uIC+VdP5Xo3JjJG931vTD9ejLWXYamUFB1ou0XC5mH9jhhXZg2bh7hcxOUrODr8BGut2xZPhxDqajhnTdEqXAY1ABh5xccWRjnhUUMAZtb+wE6JQ4oC5gUoADiU1QTrXtYESMl0r+DOy+ZL5kWnnqdPQgjOu1PDw6D0aGPUWKfKuZJwf39zDaNUaAKbAPNqho711vP9IGqadpqK0zN8wy4jk/KzZi8VjYksKZrv3x7j9NYP73abmrczpVQnhOuScf53bMqYoGEbRDLMhTZRIzYV2SKaYmF/V+UKYkKzvEiyHABIhHqG2G84onyVHNxz6uXinp2EadSUUql1SrpjJ6lU+5q6mmfX+QXXGD4KF78emAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/ef851692a408435ff5ad219739abc2de/cc182/structure.webp 148w,\n/static/ef851692a408435ff5ad219739abc2de/f7e40/structure.webp 295w,\n/static/ef851692a408435ff5ad219739abc2de/1a2f4/structure.webp 590w,\n/static/ef851692a408435ff5ad219739abc2de/4837b/structure.webp 885w,\n/static/ef851692a408435ff5ad219739abc2de/2f819/structure.webp 1180w,\n/static/ef851692a408435ff5ad219739abc2de/c3475/structure.webp 2540w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/ef851692a408435ff5ad219739abc2de/cf440/structure.png 148w,\n/static/ef851692a408435ff5ad219739abc2de/d2d38/structure.png 295w,\n/static/ef851692a408435ff5ad219739abc2de/b9e4f/structure.png 590w,\n/static/ef851692a408435ff5ad219739abc2de/f9b6a/structure.png 885w,\n/static/ef851692a408435ff5ad219739abc2de/2d849/structure.png 1180w,\n/static/ef851692a408435ff5ad219739abc2de/fd995/structure.png 2540w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/ef851692a408435ff5ad219739abc2de/b9e4f/structure.png\"\n          alt=\"structure\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<h2>注意点</h2>\n<ol>\n<li>flutter 渲染分为三层，框架会自动处理好 Element 层和 RenderObject 层，大部分时候只需要编写 Widget 层即可。</li>\n<li>Widget 是不可变的，总应该将它的属性标记为<code class=\"language-text\">final</code>。</li>\n<li>对于无状态的 Widget，总是应该使用 StatelessWidget，避免额外的创建和维护 State。</li>\n<li>在更新 element 时，会直接判断 new widget 与 old widget 是否相等，如果相等则直接复用旧的 element。所以我们可以通过 state 来提前保存生成好的子 widget，而不必每次都在 build 中生成新的子 widget。</li>\n<li>对于在整个渲染树中复用的 element，可以给它对应的 widget 增加一个 global key。这样在更新时，会通过<code class=\"language-text\">Widget.canUpdate</code>来判断是否可以复用 element。</li>\n<li>RenderObject 并没有定义节点的布局模型，它有 2 个子类，一个是 RenderBox，定义了节点在笛卡尔坐标系中的布局方式，一个是 RenderSliver，定义了节点在滚动时的布局方式。</li>\n</ol>\n<h2>小结</h2>\n<p>我们大部分时候都是直接与 Widget 在打交道，而很少关心底层的 Element 和 RenderObject。Widget 在 flutter 中承担了非常多的功能，而不仅仅只是组合 UI，例如 flutter 中的路由管理 Navigator 就是 StatefulWidget，样式主题 Theme 是 StatelessWidget 等。flutter 提供了非常丰富的 Widget，有 Material Design 风格的 material widget，有 IOS 风格的 cupertino widget。</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://www.didierboelens.com/2019/09/flutter-internals/\">flutter-internals</a></li>\n</ul>","frontmatter":{"title":"flutter 学习小结（二）","date":"November 26, 2019","tags":["flutter"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019/flutter-learn-2/","previous":{"fields":{"slug":"/post/2019/flutter-learn-1/"},"frontmatter":{"title":"flutter 学习小结（一）"}},"next":null}}