{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"592210ae-8402-593c-b6ed-06b7e8d0546c","excerpt":"上一篇文章中，学习了 flutter 跨平台的特性，以及 dart 的包管理器 pub。这一篇，我们将详细了解 flutter 很重要的一个概念，widget。组件flutter 是响应式的，它通过编程方式去写 UI 页面，而不是像 html 或者 android 中的 xml 等模版语言去定义 UI…","html":"<p><a href=\"/post/2019/flutter-learn-1\">上一篇文章</a>中，学习了 flutter 跨平台的特性，以及 dart 的包管理器 pub。这一篇，我们将详细了解 flutter 很重要的一个概念，widget。</p>\n\n          <h2 id='toc-2-1' >\n            组件\n          </h2>\n        \n<p>flutter 是响应式的，它通过编程方式去写 UI 页面，而不是像 html 或者 android 中的 xml 等模版语言去定义 UI。它借鉴了 React，也是以组件的方式去定义一个一个 UI 部件。</p>\n<blockquote>\n<p>Flutter widgets are built using a modern framework that takes inspiration from <a href=\"https://reactjs.org/\">React</a>.</p>\n</blockquote>\n\n          <h3 id='toc-3-1' >\n            分类\n          </h3>\n        \n<p>在 flutter 中一切皆是 widget。按照状态划分，可以分为 StatelessWidget 和 StatefulWidget，与 React 中的 Stateful Class Component 和 Stateless Function Component 比较类似；按照功能划分，又有 layout widget，style widget，content widget；按照 child 接受单个 widget，或者多个 widget，又有 SingleChildRenderObjectWidget 和 MultiChildRenderObjectWidget。常见 widget 如下，</p>\n<ol>\n<li>layout widget，例如<code>Scaffold</code>，<code>Row</code>，<code>Column</code>，<code>Container</code>等；</li>\n<li>style widget，例如<code>Container</code>，<code>Padding</code>，<code>Center</code>等；</li>\n<li>content widget，例如<code>Text</code>，<code>Image</code>，<code>RaisedButton</code>等；</li>\n</ol>\n<p>在开发 flutter 页面时，可以通过组合多个 widget，实现一个复杂或者独立功能的自定义 widget。对于描述一个 widget 的样式时，需要使用样式 widget 进行包装，或者更改 widget 提供的某些样式属性，比如<code>Container</code>的<code>padding</code>属性等。</p>\n\n          <h3 id='toc-3-2' >\n            实现\n          </h3>\n        \n<p>在开发自定义 widget 时，一般都是继承自 StatelessWidget，或者 StatefulWidget。StatelessWidget 和 StatefulWidget 又都是继承自 Widget。下面我们通过源码来看看它们的实现。</p>\n<pre><code class=\"language-dart\">/// 列出主要实现，去掉了其他不重要的属性或者方法\n@immutable\nabstract class Widget extends DiagnosticableTree {\n  const Widget({ this.key });\n\n  final Key key;\n\n  @protected\n  Element createElement();\n\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n      &#x26;&#x26; oldWidget.key == newWidget.key;\n  }\n}\n</code></pre>\n<p>Widget 是一个抽象类，主要有一个<code>createElement</code>的抽象方法和<code>canUpdate</code>的静态方法。<code>createElement</code>需要由继承它的子类来实现，必须返回一个 Element 对象，每一个 widget 都会有一个关联的 element 对象；在 Widget 上面有<code>@immutable</code>声明，描述 widget 对象是不可变的，它的属性都应该使用<code>final</code>标记，每次做 rebuild 时，都只会重新创建新的 widget 对象。widget 是不可变的，但是 element 是可变的，可以把 widget 看成是 element 的静态配置信息，最终是用 element 信息来完成渲染的。为了尽可能复用 element 对象，每次更新时都会先调用<code>canUpdate</code>，通过<code>runtimeType</code>和<code>key</code>来比较新旧 widget，如果返回 true，则复用旧的 element，并更新 element 的 widget 为新的 widget，否则调用新的 widget 的<code>createElement</code>来生成新的 element。</p>\n<pre><code class=\"language-dart\">abstract class StatelessWidget extends Widget {\n  const StatelessWidget({ Key key }) : super(key: key);\n\n  @override\n  StatelessElement createElement() => StatelessElement(this);\n\n  @protected\n  Widget build(BuildContext context);\n}\n</code></pre>\n<p>对于 StatelessWidget 的实现，它继承 Widget，重写了<code>createElement</code>用于生成一个<code>StatelessElement</code>。它还声明了一个<code>build</code>方法，接受一个<code>BuildContext</code>参数，并返回一个 Widget。实际上，这个<code>BuildContext</code>就是上面通过<code>createElement</code>创建的 Element 对象，下面将会解释到。</p>\n<pre><code class=\"language-dart\">abstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  @protected\n  State createState();\n}\n</code></pre>\n<p>对于 StatefulWidget，就复杂一些了。它跟 StatelessWidget 一样，继承 Widget，提供一个<code>createElement</code>方法，但是返回是<code>StatefulElement</code>对象；跟 StatelessWidget 不一样的是，它没有声明<code>build</code>方法，而是有一个<code>createState</code>方法，生成一个 State 对象。前面说过，Widget 是不可变的，每次 rebuild 都会销毁和重建，所以状态不能直接放在 widget 中，而是需要独立出来，关联到 element 上，这样状态才不会丢失。</p>\n<pre><code class=\"language-dart\">abstract class RenderObjectWidget extends Widget {\n  const RenderObjectWidget({ Key key }) : super(key: key);\n\n  @override\n  RenderObjectElement createElement();\n\n  @protected\n  RenderObject createRenderObject(BuildContext context);\n\n  @protected\n  void updateRenderObject(BuildContext context, covariant RenderObject renderObject) { }\n\n  @protected\n  void didUnmountRenderObject(covariant RenderObject renderObject) { }\n}\n</code></pre>\n<p>RenderObjectWidget，是比较特殊的一类 widget。它声明了<code>createRenderObject</code>去创建一个 RenderObject，而在 flutter 中真正被渲染的对象就是 RenderObject。上面提到的 StatelessWidget，StatefulWidget，它们都没有直接提供 RenderObject 的实现，而是通过组合其他 RenderObjectWidget，从而实现渲染出某一个部分组合 UI。根据接受的参数个数，它有两个子类，</p>\n<ol>\n<li>\n<p>SingleChildRenderObjectWidget，仅接受一个 child，比如 Padding；</p>\n</li>\n<li>\n<p>MultiChildRenderObjectWidget，可以接受多个 child，比如 Row；</p>\n</li>\n</ol>\n\n          <h2 id='toc-2-2' >\n            State\n          </h2>\n        \n<p>StatefulWidget 会通过<code>createState</code>生成一个 State 对象，它会被关联到对应的 StatefulElement 上。State 不会随着 widget 的销毁而销毁，而是会保持其生命期跟随着 element。一个 State 对象，在整个生命周期内，会有不同的阶段，为了方便开发者针对不同阶段处理一些事情，它会暴露出相应的钩子函数，类似生命周期方法。</p>\n<pre><code class=\"language-dart\">@optionalTypeArgs\nabstract class State&#x3C;T extends StatefulWidget> extends Diagnosticable {\n  T get widget => _widget;\n  T _widget;\n\n  _StateLifecycle _debugLifecycleState = _StateLifecycle.created;\n\n  BuildContext get context => _element;\n  StatefulElement _element;\n\n  bool get mounted => _element != null;\n\n  @protected\n  @mustCallSuper\n  void initState() {}\n\n  @mustCallSuper\n  @protected\n  void didUpdateWidget(covariant T oldWidget) { }\n\n  @protected\n  void setState(VoidCallback fn) {\n    final dynamic result = fn() as dynamic;\n    _element.markNeedsBuild();\n  }\n\n  @protected\n  @mustCallSuper\n  void deactivate() { }\n\n  @protected\n  @mustCallSuper\n  void dispose() {}\n\n  @protected\n  Widget build(BuildContext context);\n\n  @protected\n  @mustCallSuper\n  void didChangeDependencies() { }\n}\n</code></pre>\n<p>State 对象会持有 StatefulWidget 的引用_widget，还有一个_StateLifecycle 状态。在不同的阶段，会调用不同的方法，然后_StateLifecycle 的值也会不一样，类似 react 中的生命周期方法。这里主要有如下生命周期方法，</p>\n<ol>\n<li><code>initState</code>，初始化时执行，一般用于执行申请资源等操作，不可以执行<code>setState</code>，在 state 的生命里只会调用一次。</li>\n<li><code>didChangeDependencies</code>，如果在<code>build</code>中有调用<code>BuildContext.inheritFromWidgetOfExactType</code>，而且 inherited widgets 有变化，则会触发此方法。可以根据变化，调用<code>setState</code>来更新当前 children widgets。</li>\n<li><code>didUpdateWidget</code>，当 element 上调用的<code>canUpdate</code>返回 true 时，也就是复用 element，更新 element 关联的 widget 时会触发此方法。state 需要根据新的 widget 来作出改变。在执行完<code>didUpdateWidget</code>时，框架紧接着会执行 statet 的<code>build</code>方法来更新 UI，所以不应该在此方法中执行<code>setState</code> 。</li>\n<li><code>deactivate</code>，当 element 上调用的<code>canUpdate</code>返回 false 时，会卸载当前的 element，随即也会卸载当前的 element 关联的 state，则会触发此方法。State 会被从树中移除，应该在此方法里解除它与其他 element 的引用关系。</li>\n<li><code>dispose</code>，销毁时执行，一般用于释放在<code>initState</code>中申请的资源，不可以执行<code>setState</code></li>\n</ol>\n<p>State 会有一个 context 的属性，它实际就是 widget 的 element 对象。State 有一个比较重要的方法<code>setState</code>，每次调用它，都会触发当前 widget 的更新。在上面的实现中，可以看到它调用了<code>_element.markNeedsBuild()</code>，将当前 element 标记为 dirty，然后在下一个 frame 中会重新执行 rebuild。如果直接更改 state 中的值，是不会触发 widget 的更新的。</p>\n\n          <h2 id='toc-2-3' >\n            Element Tree\n          </h2>\n        \n<p>通过上面的部分源码分析，真正负责渲染的 widget 对象是 RenderObjectWidget，它会生成 Element 和 RenderObject，关系如下</p>\n<p><img src=\"./internals_element.png\" alt=\"internals_element\"></p>\n<p>把它们与 React 中元素来做类似关联，应该就比较明白它们的作用了，</p>\n<ol>\n<li>widget，类似于 React 中 JSX，用于定义 UI 应该展示什么样子，在最上层。</li>\n<li>element，类似于 React 中 Component 生成的 vdom 对象，这里会做一些复用逻辑和渲染优化，用于为真正渲染对象提供数据，位于中间层。</li>\n<li>renderObject，类似于真正的 DOM 了，真正的渲染对象，在最底层了。</li>\n</ol>\n<p>react 会形成一颗虚拟的 dom 树，flutter 中也在 element 这一层生成一颗 element 树。</p>\n<p>flutter 框架会帮我们处理好 element 和 renderObject 层，对于一般业务开发，我们只需要在 widget 层去实现功能即可。框架会在三个地方帮我们调用<code>createElement</code>去生成对应的 element 对象，下面我们分别来看看这三个地方。</p>\n<p>第一个地方就是生成 element 树的根节点。flutter 是通过调用<code>runApp</code>来启动的，如下</p>\n<pre><code class=\"language-dart\">void main() => runApp(MyApp());\n</code></pre>\n<p>在<code>runApp</code>中会做很多初始化的工作，其中就包含了生成 element 树的根节点并挂载。</p>\n<pre><code class=\"language-dart\">void runApp(Widget app) {\n  WidgetsFlutterBinding.ensureInitialized()\n    /// 这里就会生成element树的根节点\n    ..scheduleAttachRootWidget(app)\n    ..scheduleWarmUpFrame();\n}\n</code></pre>\n<p>沿着<code>scheduleAttachRootWidget</code>调用栈一路找下去，最后会生成一个<code>RenderObjectToWidgetAdapter</code>对象，并调用它的<code>attachToRenderTree</code>方法，</p>\n<pre><code class=\"language-dart\"> class RenderObjectToWidgetAdapter&#x3C;T extends RenderObject> extends RenderObjectWidget {\n\n  @override\n  RenderObjectToWidgetElement&#x3C;T> createElement() => RenderObjectToWidgetElement&#x3C;T>(this);\n\n  RenderObjectToWidgetElement&#x3C;T> attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&#x3C;T> element ]) {\n    if (element == null) {\n      owner.lockState(() {\n        // 如果root element为空，则调用createElement生成root element\n        element = createElement();\n        assert(element != null);\n        element.assignOwner(owner);\n      });\n      owner.buildScope(element, () {\n        // 并挂载在element树上\n        element.mount(null, null);\n      });\n      // This is most likely the first time the framework is ready to produce\n      // a frame. Ensure that we are asked for one.\n      SchedulerBinding.instance.ensureVisualUpdate();\n    } else {\n      element._newWidget = this;\n      element.markNeedsBuild();\n    }\n    return element;\n  }\n}\n\n</code></pre>\n<p>先判断当前 root element 存不存在，如果不存在，就会调用<code>createElement</code>生成新的 root element，并调用<code>element.mount(null, null)</code>进行挂载</p>\n<p>第二个地方就是进行 mount 时，如果当前 element 是 MultiChildRenderObjectElement，则会为它的 widget 的 children widget 生成对应的 element，并挂载。</p>\n<pre><code class=\"language-dart\">  void mount(Element parent, dynamic newSlot) {\n    super.mount(parent, newSlot);\n    _children = List&#x3C;Element>(widget.children.length);\n    Element previousChild;\n    for (int i = 0; i &#x3C; _children.length; i += 1) {\n      /// inflateWidget就是调用createElement并进行mount\n      final Element newChild = inflateWidget(widget.children[i], previousChild);\n      _children[i] = newChild;\n      previousChild = newChild;\n    }\n  }\n</code></pre>\n<pre><code class=\"language-dart\">  Element inflateWidget(Widget newWidget, dynamic newSlot) {\n    assert(newWidget != null);\n    final Key key = newWidget.key;\n    if (key is GlobalKey) {\n      /// ...\n    }\n    final Element newChild = newWidget.createElement();\n    newChild.mount(this, newSlot);\n    return newChild;\n  }\n</code></pre>\n<p>第三个地方就是进行 rebuild 时，更新 child element，如果 child element 为 null，且新的 widget 不为 null，则也会调用<code>inflateWidget</code>来新建 element 且挂载。</p>\n<pre><code class=\"language-dart\">Element updateChild(Element child, Widget newWidget, dynamic newSlot) {\n    // newWidget为null，则直接返回null\n   if (newWidget == null) {\n      /// ...\n      return null;\n    }\n   //child不为null，且newWidget也不为null\n    if (child != null) {\n      // 如果widget相等，则直接用之前的element\n      if (child.widget == newWidget) {\n        /// ...\n        return child;\n      }\n      // 如果canUpdate返回true，也直接用之前的element\n      if (Widget.canUpdate(child.widget, newWidget)) {\n        /// ...\n        child.update(newWidget);\n        return child;\n      }\n    }\n   // child element为null，且newWidget不为null，则生成新的child element\n    return inflateWidget(newWidget, newSlot);\n  }\n</code></pre>\n<p>在维护更新 element 树的同时，会每次将更新点同步到 RenderObject 上。最后，flutter 根据 RenderObject 来渲染出页面。为了更高效的渲染，在 layout 阶段会通过 RelayoutBoundary 来控制 relayout 的范围，在 paint 阶段会通过 RepaintBoundary 只重新绘制受响应的部分。</p>\n\n          <h2 id='toc-2-4' >\n            结构图\n          </h2>\n        \n<p>从 Widget，Element，RenderObject 角度分别列举了它们的父类和子类，</p>\n<p><img src=\"./structure.png\" alt=\"structure\"></p>\n\n          <h2 id='toc-2-5' >\n            注意点\n          </h2>\n        \n<ol>\n<li>flutter 渲染分为三层，框架会自动处理好 Element 层和 RenderObject 层，大部分时候只需要编写 Widget 层即可。</li>\n<li>Widget 是不可变的，总应该将它的属性标记为<code>final</code>。</li>\n<li>对于无状态的 Widget，总是应该使用 StatelessWidget，避免额外的创建和维护 State。</li>\n<li>在更新 element 时，会直接判断 new widget 与 old widget 是否相等，如果相等则直接复用旧的 element。所以我们可以通过 state 来提前保存生成好的子 widget，而不必每次都在 build 中生成新的子 widget。</li>\n<li>对于在整个渲染树中复用的 element，可以给它对应的 widget 增加一个 global key。这样在更新时，会通过<code>Widget.canUpdate</code>来判断是否可以复用 element。</li>\n<li>RenderObject 并没有定义节点的布局模型，它有 2 个子类，一个是 RenderBox，定义了节点在笛卡尔坐标系中的布局方式，一个是 RenderSliver，定义了节点在滚动时的布局方式。</li>\n</ol>\n\n          <h2 id='toc-2-6' >\n            小结\n          </h2>\n        \n<p>我们大部分时候都是直接与 Widget 在打交道，而很少关心底层的 Element 和 RenderObject。Widget 在 flutter 中承担了非常多的功能，而不仅仅只是组合 UI，例如 flutter 中的路由管理 Navigator 就是 StatefulWidget，样式主题 Theme 是 StatelessWidget 等。flutter 提供了非常丰富的 Widget，有 Material Design 风格的 material widget，有 IOS 风格的 cupertino widget。</p>\n\n          <h2 id='toc-2-7' >\n            参考\n          </h2>\n        \n<ul>\n<li><a href=\"https://www.didierboelens.com/2019/09/flutter-internals/\">flutter-internals</a></li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">组件</a><ul><li><a href=\"#toc-3-1\">分类</a></li><li><a href=\"#toc-3-2\">实现</a></li></ul></li><li><a href=\"#toc-2-2\">State</a><ul></ul></li><li><a href=\"#toc-2-3\">Element Tree</a><ul></ul></li><li><a href=\"#toc-2-4\">结构图</a><ul></ul></li><li><a href=\"#toc-2-5\">注意点</a><ul></ul></li><li><a href=\"#toc-2-6\">小结</a><ul></ul></li><li><a href=\"#toc-2-7\">参考</a><ul></ul></li></ul>","frontmatter":{"title":"flutter 学习小结（二）","date":"November 26, 2019","tags":["flutter"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019/flutter-learn-2/","previous":{"fields":{"slug":"/post/2019/flutter-learn-1/"},"frontmatter":{"title":"flutter 学习小结（一）"}},"next":{"fields":{"slug":"/post/2019/flutter-learn-3/"},"frontmatter":{"title":"flutter 学习小结（三）"}}}}