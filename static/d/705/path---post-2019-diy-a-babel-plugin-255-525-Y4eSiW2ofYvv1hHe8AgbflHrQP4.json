{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"846c1ca7-ad92-5c93-a7c3-cb1252b71f52","excerpt":"Babel，是一个 JavaScript 的编译工具，它可以将 es6+语法的代码，转换为浏览器兼容的低版本的代码。它简直就是一个神兵利器，前端工程师拥有了它，就可以在项目中使用一些较新的 es 语法。笔者决定弄懂它，并实现一个自己的 Babel 插件。Babel…","html":"<p>Babel，是一个 JavaScript 的编译工具，它可以将 es6+语法的代码，转换为浏览器兼容的低版本的代码。它简直就是一个神兵利器，前端工程师拥有了它，就可以在项目中使用一些较新的 es 语法。笔者决定弄懂它，并实现一个自己的 Babel 插件。</p>\n<p>Babel 的工作原理，可以用如下公式表述。它实际上就是接受输入的源代码，然后对它做一些处理和转换，最后输出为目标版本的代码。</p>\n<pre><code class=\"language-javascript\">const babel = sourceCode => distCode\n</code></pre>\n<p>在将输入的源码做处理或者转换时，这就需要用到了它的插件系统。一个插件只负责处理一件事，比如<code>@babel/plugin-transform-arrow-functions</code> ，就是负责将箭头函数转换为普通函数的插件。Babel 提供了非常多的插件，这样就足以保证可以将新的 es 语法转换为旧版本的代码形式。想了解详细的 Babel 插件系统，可以查看<a href=\"https://babeljs.io/docs/en/plugins\">Babel#Plugins</a>。</p>\n<p>如果不配置任何的插件，Babel 将不会对源码做任何的处理，它只会照原样输出。下面举个例子，</p>\n<pre><code class=\"language-javascript\">const babel = require(\"@babel/core\")\n\nconst code = `\n  const a = () => {\n    console.log(1);\n  }\n`\n\n// 没有配置任何plugin，那么转换之后的code将没有任何变化\nbabel.transform(code, undefined, (err, result) => {\n  if (err) {\n    throw err\n  }\n  console.log(result.code)\n})\n</code></pre>\n<p>我们将箭头函数使用 Babel 来转换，但是没有配置任何的插件，最后转换之后的结果将和输入的代码一摸一样。</p>\n<pre><code class=\"language-bash\">➜  babel node scripts/index.ts\nconst a = () => {\n  console.log(1);\n};\n</code></pre>\n<p>如果配置了<code>@babel/plugin-transform-arrow-functions</code>，Babel 就能正常将我们的箭头函数转换为普通函数的形式了。如下，</p>\n<pre><code class=\"language-javascript\">// 配置@babel/plugin-transform-arrow-functions\nbabel.transform(\n  code,\n  { plugins: [\"@babel/plugin-transform-arrow-functions\"] },\n  (err, result) => {\n    if (err) {\n      throw err\n    }\n    console.log(result.code)\n  }\n)\n</code></pre>\n<p>转换之后的代码如下，</p>\n<pre><code class=\"language-bash\">➜  babel node scripts/index.ts\nconst a = function () {\n  console.log(1);\n};\n</code></pre>\n<p>对于其他的语法形式的转换，可以添加其他的插件。如果仅仅这样，对于一个实际项目代码的转换，将要配置非常多的插件。为了简化这种形式，Babel 又提供了 Presets，简单的说，就是将很多个插件集合重新命名为一个新名称。这样，只需要配置了这个 Presets，那么就相对于配置它所包含的所有的插件。Babel 定义了常用的 Presets，详细可以查看<a href=\"https://babeljs.io/docs/en/presets\">Babel#Presets</a>。</p>\n<p>通过加入插件处理的方式，Babel 将会有非常好的可扩展性和可插拔性，比如 esNext 中又添加了一个新的语法糖，那么 Babel 只需要单独提供这个新语法处理的插件，并将它配置进去就可以了。对于前端工程师们，也可以根据实际业务需求，写自己的插件，将输入的源码处理成自己想要的输出。</p>\n<p>为了能写出自己的 Babel 插件，我们就需要知道 Babel 将输入的代码转换成什么样子，插件接受的参数又是什么样子，最后需要返回的值是什么样子。</p>\n\n          <h3 id='toc-3-1' >\n            AST\n          </h3>\n        \n<p>Babel 会将输入的源代码先转换成 AST(Abstract Syntax Tree)，然后将 AST 作为参数传给插件，插件将在 AST 上做处理，可以添加，删除或者改变节点。例如，我们上面例子中箭头函数 a，生成的 AST 大致结构如下,</p>\n<pre><code class=\"language-bash\">  \"program\": {\n    \"type\": \"Program\",\n    \"body\": [\n      {\n        \"type\": \"VariableDeclaration\",\n        \"declarations\": [\n          {\n            \"type\": \"VariableDeclarator\",\n            \"id\": {\n              \"type\": \"Identifier\",\n              \"name\": \"a\"\n            },\n            \"init\": {\n              \"type\": \"ArrowFunctionExpression\",\n              \"params\": [],\n              \"body\": {\n                \"type\": \"BlockStatement\",\n                \"body\": [\n                  { ↔ }\n                ],\n              }\n            }\n          }\n        ],\n        \"kind\": \"const\"\n      }\n    ],\n  },\n</code></pre>\n<p>AST 可以看成一棵树，它包含了很多的节点，每个节点都会包含一个 type 字段，这个 type 字段就是用来表明当前节点的类型，比如上面的<code>Identifier</code>表明是标识符，<code>ArrowFunctionExpression</code>表明是箭头函数表达式。想详细了解 AST 结构，可以查看<a href=\"https://astexplorer.net/\">astexplorer</a>。</p>\n<p>要处理 AST 树，就得遍历这颗树，找到我们要处理的节点位置。对于一棵树的遍历，有 DFS(深度优先搜索)和 BFS(广度优先搜索)两种方式。对于 AST 的遍历，使用的是 DFS 方式。Babel 提供了<code>@babel/traverse</code>来遍历它，可以很方便的找到需要处理的节点位置。例如上面的例子，我们可以像下面这样找到<code>console.log(1)</code>中<code>1</code>这个节点位置，</p>\n<pre><code class=\"language-javascript\">const babel = require(\"@babel/core\")\nconst traverse = require(\"@babel/traverse\")\n\nconst code = `\n  const a = () => {\n    console.log(1);\n  }\n`\n\nbabel.parse(code, null, (err, ast) => {\n  if (err) {\n    throw err\n  }\n  traverse(ast, {\n    NumericLiteral(path) {\n      console.log(JSON.stringify(path.node, null, 4))\n    },\n  })\n})\n</code></pre>\n<p>由于<code>console.log(1)</code>接受的参数是一个数字字面量，所以它对应的<code>type</code>就是<code>NumericLiteral</code>。最后找到这个节点的信息如下，</p>\n<pre><code class=\"language-bash\">➜  babel node scripts/index.ts\n{\n    \"type\": \"NumericLiteral\",\n    \"start\": 37,\n    \"end\": 38,\n    \"loc\": {\n        \"start\": {\n            \"line\": 3,\n            \"column\": 16\n        },\n        \"end\": {\n            \"line\": 3,\n            \"column\": 17\n        }\n    },\n    \"extra\": {\n        \"rawValue\": 1,\n        \"raw\": \"1\"\n    },\n    \"value\": 1\n}\n</code></pre>\n<p>可以看到，节点包含了 type，loc 信息，以及 value 等信息。更多关于 traverse 的使用，可以查看这里<a href=\"https://babeljs.io/docs/en/babel-traverse\">Babel#traverse</a>。</p>\n\n          <h3 id='toc-3-2' >\n            Plugin\n          </h3>\n        \n<p>根据上面的思路，我们可以得出如下结论，</p>\n<blockquote>\n<p>Babel 中插件接受 AST 作为参数，然后可以在 AST 上做一些自定义的处理，最后返回处理之后的 AST。</p>\n</blockquote>\n<p>为了验证这个结论正确性，我们来看看官方的<a href=\"https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-arrow-functions\"><code>@babel/plugin-transform-arrow-functions</code></a>的源码，源码只有 28 行代码，我贴出来，并做一些自己的注释，一起看看。</p>\n<pre><code class=\"language-javascript\">import { declare } from \"@babel/helper-plugin-utils\";\nimport type NodePath from \"@babel/traverse\";\n\nexport default function declare((api, options) {\n  // 判断当前Babel版本是否是v7.x\n  api.assertVersion(7);\n\n  // 接受我们传入的参数\n  const { spec } = options;\n\n  // 返回一个对象\n  return {\n    name: \"transform-arrow-functions\",\n\n    visitor: {\n      ArrowFunctionExpression(\n        path: NodePath&#x3C;BabelNodeArrowFunctionExpression>,\n      ) {\n        // 先判断是不是箭头函数表达式，不是就直接返回\n        if (!path.isArrowFunctionExpression()) return;\n\n        // 将箭头函数转为函数表达式\n        path.arrowFunctionToExpression({\n          allowInsertArrow: false,\n          specCompliant: !!spec,\n        });\n      },\n    },\n  };\n});\n</code></pre>\n<p>从源码可以看出，它返回一个<code>declare</code>函数。这个函数接受两个参数，一个<code>api</code>，一个是<code>options</code>。函数处理步骤如下，</p>\n<ol>\n<li>判断是否 Babel v7 的版本</li>\n<li>返回一个对象，包括<code>name</code>和<code>visitor</code>；其中，<code>visitor</code>又是一个对象，它才真正包含对肩头函数表达式的处理。</li>\n</ol>\n<p>实际上，<code>path.arrowFunctionToExpression</code> 就是使用<code>@babel/types</code>中<code>arrowfunctionexpression</code>，详细可以查看<a href=\"https://babeljs.io/docs/en/babel-types#arrowfunctionexpression\">babel-types#arrowfunctionexpression</a>。</p>\n<p>跟我们猜想的 Babel 插件样子有点出入，但是它包含了我们猜想的内容。最后，我们可以总结出写一个 Babel 插件的样子应该是这样的，</p>\n<pre><code class=\"language-javascript\">export default function declare(api, options) {\n  // api可以做一些版本兼容性判断，或者缓存相关的。\n  // options就是我们配置插件时，传入的参数，这里插件内部就可以使用了\n\n  return {\n    name: \"my-custorm-plugin\",\n    visitor: {\n      // 遍历AST做处理\n    },\n  }\n}\n</code></pre>\n\n          <h3 id='toc-3-3' >\n            DIY\n          </h3>\n        \n<p>清楚了 Babel 插件的模版形式，就可以按照这个模版写我们自定义的功能插件。假设，我们要写的一个 Babel 插件，就是去掉所有的<code>console.log</code>相关调试信息的代码。</p>\n<pre><code class=\"language-javascript\">// 源代码\nconst a = () => {\n  console.log(1)\n}\n</code></pre>\n<p>例如上面的代码经过我们的 Babel 插件处理之后，输出的代码应该是一个空的箭头函数 a，</p>\n<pre><code class=\"language-javascript\">// 转换之后\nconst a = () => {}\n</code></pre>\n<p>根据 Babel 插件模版代码，我们可以这样实现如下，</p>\n<pre><code class=\"language-javascript\">// plugins/remove-console-log.js\nconst types = require(\"@babel/types\")\n\nmodule.exports = function declare(api, options) {\n  api.assertVersion(7)\n\n  return {\n    name: \"remove-console-log\",\n    visitor: {\n      ExpressionStatement(path) {\n        const expression = path.node.expression\n        if (types.isCallExpression(expression)) {\n          const callee = expression.callee\n          if (types.isMemberExpression(callee)) {\n            const objName = callee.object.name\n            const methodName = callee.property.name\n            if (objName === \"console\" &#x26;&#x26; methodName === \"log\") {\n              path.remove()\n            }\n          }\n        }\n      },\n    },\n  }\n}\n</code></pre>\n<p>然后在 babel.config.js 中配置如下，</p>\n<pre><code class=\"language-javascript\">module.exports = {\n  plugins: [\"./plugins/remove-console-log.js\"],\n}\n</code></pre>\n<p>最后，我们通过 Babel 转换之后就可以得到我们期望的结果了。</p>\n\n          <h3 id='toc-3-4' >\n            小结\n          </h3>\n        \n<p>通过自己实现一个 Babel 插件，然后贯穿整个过程把 Babel 原理弄清楚。上面其实还有一个小知识点，就是 Babel 怎么将源码转换成 AST 的。其实，它的过程也不难理解，只是在转换为 AST 之前，需要先进行词法分析，把源码字符串转换成 Token 数组；然后根据词法分析得到的结果，转换成 AST。完整的 Babel 原理过程可以简单的表述为如下，</p>\n<p><img src=\"./compiler.png\" alt=\"compiler\"></p>\n<pre><code class=\"language-javascript\">let tokens = tokenizer(input) // 词法分析\nlet ast = parser(tokens) // 转换为AST\nlet newAst = transformer(ast) // 调用插件，进行转换\nlet output = codeGenerator(newAst) // 最后，生成新的目标代码\n</code></pre>\n<p>如果想更加详细研究 Babel 的过程，可以看看这个简易的编译器<a href=\"https://github.com/jamiebuilds/the-super-tiny-compiler\">the-super-tiny-compiler</a>，它实现了完整的流程过程，代码也非常简单易懂。</p>\n\n          <h3 id='toc-3-5' >\n            参考\n          </h3>\n        \n<ul>\n<li><a href=\"https://babeljs.io/docs/en/\">babeljs</a></li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook\">babel-handbook</a></li>\n<li><a href=\"https://github.com/jamiebuilds/the-super-tiny-compiler\">the-super-tiny-compiler</a></li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">AST</a><ul></ul></li><li><a href=\"#toc-3-2\">Plugin</a><ul></ul></li><li><a href=\"#toc-3-3\">DIY</a><ul></ul></li><li><a href=\"#toc-3-4\">小结</a><ul></ul></li><li><a href=\"#toc-3-5\">参考</a><ul></ul></li></ul>","frontmatter":{"title":"DIY 一个 Babel 插件","date":"August 06, 2019","tags":["babel"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019/diy_a_babel_plugin/","previous":{"fields":{"slug":"/post/2019/algorithm_skip_list/"},"frontmatter":{"title":"数据结构和算法-跳表的原理及实现"}},"next":{"fields":{"slug":"/post/2019/flutter-learn-1/"},"frontmatter":{"title":"flutter 学习小结（一）"}}}}