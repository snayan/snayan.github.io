{"data":{"site":{"siteMetadata":{"title":"三羊的小站","postLimit":10,"menu":{"search":{"name":"搜索","link":"/search"}}}},"allMarkdownRemark":{"totalCount":34,"edges":[{"node":{"excerpt":"<p>基础数据结构，最基础的就只有两种，一个是数组，一个是链表。其他的数据结构都是在它们之上抽象出来的，比如，栈，队列，散列表，树，图等。</p>\n","fields":{"slug":"/post/algorithm_basic_data_structure/"},"frontmatter":{"date":"May 08, 2019","title":"数据结构和算法-基础数据结构","tags":["algorithm","javascript"],"description":"基础数据结构，最基础的就只有两种，一个是数组，一个是链表。其他的数据结构都是在它们之上抽象出来的，比如，栈，队列，散列表，树，图等。"}}},{"node":{"excerpt":"<h2>背景</h2>\n<p>最近老板来了一个新需求，地理位置组团。其中一个功能点，就是用户可以进入地图页面，查看当前自身位置，且扫描圈内和圈外其他玩家，将玩家头像显示在地图页面上，标明玩家在哪个位置。老板说，在地图上要可以同时显示 200 个玩家头像，且保证页面流畅；Android6 的手机上，在拖拽，缩小放大时，不能出现明显的卡顿，必须保证用户体验。在拖拽，缩小或者放大等改变地图可视范围时，或则停留时间超过 60s，需要更新当前地图上的用户头像。</p>\n","fields":{"slug":"/post/optimize_map_page/"},"frontmatter":{"date":"April 13, 2019","title":"性能优化篇-地图页面","tags":["performance","javascript"],"description":null}}},{"node":{"excerpt":"<p>好快，2018 没了。</p>\n","fields":{"slug":"/post/summary_of_2018/"},"frontmatter":{"date":"January 02, 2019","title":"2018年小结","tags":["2018","summary"],"description":null}}},{"node":{"excerpt":"<p>在跨平台客户端开发中，H5 是使用最为广泛的方式，它既可以运行在 iOS 中，也可以运行在 Android 中，还可以运行在 web 浏览器中，可以说是”write once, run anywhere”。但是，H5 最为人诟病的就是用户体验不如 native 流畅，特别是对于低端机型和较差的网络环境，在页面加载时通常有较长一段时间的白屏等待时间。</p>","fields":{"slug":"/post/understand_the_details_of_h5_and_native(ios)_communication/"},"frontmatter":{"date":"December 31, 2018","title":"理解h5与native(ios)通信细节","tags":["h5","bridge"],"description":null}}},{"node":{"excerpt":"<p>最近想了解一下 React 和 Vue 框架分别在 virtual dom 部分的实现，以及他们的不同之处。于是先翻开 Vue 的源码去找 virtual dom 的实现，看到开头，它就提到了 Vue 的 virtual dom 更新算法是基于 Snabbdom 实现的。于是，又去克隆了 Snabbdom 的源码，发现它的源码并不是很复杂并且星星 🌟 还很多，所以就仔细看了一遍了，这里就将详细学习一下它是如何实现 virtual dom 的。</p>\n","fields":{"slug":"/post/understand_the_details_of_vritual_dom_snabbdom/"},"frontmatter":{"date":"December 31, 2018","title":"理解virtual dom的实现细节-snabbdom","tags":["h5","vue","vdom"],"description":null}}},{"node":{"excerpt":"<h3>1. Cannot read property ‘catch’ of undefined</h3>\n<p>原因：在调用 play()时，现代浏览器返回的是一个 promise，对于执行失败的，会触发一个 Unhandled Promise Rejection，但是对于低版本的浏览器，调用 play()并不会返回一个 promise。</p>\n<p>解决：应该在调用 play()时做如下处理，增加对 playPromise 的判断</p>\n<p>参考资料：<a href=\"https://developers.google.com/web/updates/2016/03/play-returns-promise\">HTMLMediaElement.play() Returns a Promise</a></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> playPromise <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">play</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// In browsers that don’t yet support this functionality,</span>\n<span class=\"token comment\">// playPromise won’t be defined.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>playPromise <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  playPromise\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Automatic playback started!</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Automatic playback failed.</span>\n      <span class=\"token comment\">// Show a UI element to let the user manually start playback.</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/resolve_issue_of_using_audio/"},"frontmatter":{"date":"December 17, 2018","title":"HTML5中Audio使用踩坑汇总","tags":["h5","audio"],"description":null}}},{"node":{"excerpt":"<p>最近在项目碰到了一个 vue 组件更新导致 style 异常的问题。下面记录一下我自己的解决思路。</p>\n<h3>问题背景</h3>\n<p>由于公司项目业务复杂，就不具体描述了。简单说一下问题，就是项目使用 vue 框架，在一个页面中根据 a 值来显示不同组件，当<code class=\"language-text\">a = true</code>时显示 A 组件，否则就显示 B 组件。示例代码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n      &lt;div v-if=&quot;a&quot; :style=&quot;getBackground(&#39;a&#39;)&quot;&gt;a组件&lt;/div&gt;\n      &lt;div v-else :style=&quot;getBackground(&#39;b&#39;)&quot;&gt;b组件&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n        name:&#39;Example&#39;,\n        data: {\n            a: false\n        },\n        computed: {\n            getBackground: function(type) {\n                return {\n                    background: `url(https://${type}.png) no-repeat`,\n                    backgroundSize: &#39;100% 100%&#39;,\n                }\n            }\n        }\n        mounted() {\n            setTimeout(() =&gt; { this.a = true }, 1000)\n        }\n    }\n&lt;/script&gt;</code></pre></div>\n<h3>问题描述</h3>\n<p>如上代码，页面加载时，显示 <em>a 组件</em>，且它的背景样式是设置了<code class=\"language-text\">backgroundImage</code>和<code class=\"language-text\">backgroundSize</code>为<code class=\"language-text\">100% 100%</code>，一秒之后，a 变为<code class=\"language-text\">false</code>了，这是显示 <em>b 组件</em>，预期之中，它也是应该设置了<code class=\"language-text\">backgroundImage</code>和<code class=\"language-text\">backgroundSize</code>为<code class=\"language-text\">100% 100%</code>，但是呢，在显示 <em>b 组件</em>，它的样式，<code class=\"language-text\">backgroundSize</code>并不是<code class=\"language-text\">100% 100%</code>，而是默认的<code class=\"language-text\">initial</code>，这样导致样式并非我们预期想要的。究竟为什么在显示 <em>b 组件</em> 时，这个<code class=\"language-text\">backgroundSize</code>不是我们在<code class=\"language-text\">getBackground</code>中返回的 100%呢？</p>\n","fields":{"slug":"/post/resolve_vue_style_update_problem/"},"frontmatter":{"date":"December 03, 2018","title":"看vue源码解决组件style更新问题","tags":["vue"],"description":null}}},{"node":{"excerpt":"<p>这篇是学习和回顾 canvas 系列笔记的第六篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>。</p>\n<p>在上一篇<a href=\"/post/how_to_implement_complex_animations/\">canvas 核心技术-如何实现复杂的动画</a>笔记中，我们详细讨论了在制作复杂动画时，需要考虑时间因素，物理因素等，同时还回顾了如何使用缓动函数来扭曲时间轴实现非线性运动，比如常见的缓入，缓出，缓入缓出等。在游戏或者动画中，运动的物体在变化的过程中，它们是有可能碰撞在一起的，那么这一篇我们就来详细学习下如何进行碰撞检测。</p>\n","fields":{"slug":"/post/how_to_detect_collision/"},"frontmatter":{"date":"August 26, 2018","title":"canvas-核心技术-如何实现碰撞检测","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>这篇是学习和回顾 canvas 系列笔记的第五篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>。</p>\n<p>在上一篇<a href=\"/post/how_to_implement_simple_animations/\">canvas 核心技术-如何实现简单的动画</a>笔记中，我们详细学习了如何进行 canvas 坐标系的平移，缩放，旋转等操作来实现一些比较简单和单一的动画。但是在实际动画中，影响一个动画的因素是很多的，比如一个小球自由落体运动，我们不仅要考虑小球的初始速度和初始方向，还要考虑重力加速度，空气阻力等外界因素。这一篇笔记，我们会详细学习复杂动画的相关知识。</p>\n<h3>核心逻辑</h3>\n<p>我们理解的动画，应该是在一段时间内，物体的某些属性，比如颜色，大小，位置，透明度等，发生改变。判断动画流程度的单位是动画刷新的速率，在浏览器中一般是浏览器的帧速率。帧速率越大，动画就越流畅。在现代浏览器中，我们一般是使用<code class=\"language-text\">requestAnimationFrame</code>来执行动画。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> raf <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"token keyword\">let</span> lastFrame <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\">// 动画</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">animate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">frame</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// todo:这里可以执行一些动画更新</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">)</span>\n  raf <span class=\"token operator\">=</span> <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>animate<span class=\"token punctuation\">)</span>\n  lastFrame <span class=\"token operator\">=</span> frame\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 一些初始化的操作</span>\n  <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 执行动画</span>\n  <span class=\"token function\">animate</span><span class=\"token punctuation\">(</span>performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">cancelAnimationFrame</span><span class=\"token punctuation\">(</span>raf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/how_to_implement_complex_animations/"},"frontmatter":{"date":"August 19, 2018","title":"canavs核心技术-如何实现复杂的动画","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>这篇是学习和回顾 canvas 系列笔记的第四篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>。</p>\n<p>在前面几篇中，我们回顾了在 canvas 中绘制线段，图形，图片等基本功能，当在制作 2d 游戏或者更为丰富的图表库时，必须提供强大的动画功能。canvas 本身不提供像 css 中<code class=\"language-text\">animation</code>属性专门来实现动画，但是 canvas 提供了<code class=\"language-text\">translate</code>，<code class=\"language-text\">scale</code>，<code class=\"language-text\">rotate</code>等基本功能，我们可以通过组合使用这些功能来实现动画。</p>\n<p>跟动画有关的概念中，我们还要理解<strong>帧速率</strong>。我们通常说一帧，就是浏览器完整绘制一次所经过的时间。现代浏览器的帧速率一般是 60fps，就是在 1s 内可以绘制 60 次。如果帧速率过低，就会觉得明显的卡顿了。一般是帧速率越高，动画越流畅。在 JavaScript 中，我们要在 1s 内绘制 60 次，以前的做法是使用<code class=\"language-text\">setTimeout</code>或者<code class=\"language-text\">setInterval</code>来定时执行。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 执行绘制操作</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span> <span class=\"token operator\">/</span> <span class=\"token number\">60</span><span class=\"token punctuation\">)</span></code></pre></div>\n","fields":{"slug":"/post/how_to_implement_simple_animations/"},"frontmatter":{"date":"August 11, 2018","title":"canvas核心技术-如何实现简单的动画","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>这篇是学习和回顾 canvas 系列笔记的第三篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a></p>\n<p>通过上一篇<a href=\"/post/how_to_draw_graphics/\">canvas 核心技术-如何绘制图形</a>的学习，我们知道了如何绘制任意多边形以及图片的填充规则。在 canvas 中应用比较多的还有绘制图片和文本。这篇文章，我们就来详细聊聊图片和文本的绘制。</p>\n<h3>图片</h3>\n<p>在 canvas 中，我们可以把一张图片直接绘制到 canvas 上，跟使用<code class=\"language-text\">img</code>标签类似，不同的是，图片是绘制到 canvas 画布上的，而非独立的 html 元素。canvas 提供了<code class=\"language-text\">drawImage</code>方法来绘制图片，这个方法可以有三种形式的用法，如下，</p>\n<ul>\n<li><code class=\"language-text\">void drawImage(image,dx,dy);</code>直接将图片绘制到指定的 canvas 坐标上，图片由 image 传入，坐标由 dx 和 dy 传入。</li>\n<li><code class=\"language-text\">void drawImage(image,dx,dy,dw,dh);</code>同上面形式，只不过指定了图片绘制的宽度和高度，宽高由 dw 和 dh 传入。</li>\n<li><code class=\"language-text\">void drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);</code>这个是最复杂，最灵活的使用形式，第一参数是待绘制的图片元素，第二个到第五个参数，指定了原图片上的坐标和宽高，这部分区域将会被绘制到 canvas 中，而其他区域将忽略，最后四个参数跟形式二一样，指定了 canvas 目标中的坐标和宽高。</li>\n</ul>\n","fields":{"slug":"/post/how_to_draw_image_and_text/"},"frontmatter":{"date":"July 27, 2018","title":"canvas核心技术-如何绘制图片和文本","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>这篇学习和回顾 canvas 系列笔记的第二篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a></p>\n<p>通过上一篇<a href=\"/post/how_to_draw_line/\">canvas 核心技术-如何绘制线段</a>的学习，我们知道了如何去绘制线段。很多的线段的拼接就组成了图形了，比如常见的三角形，矩形，圆形等。</p>\n<p>常见图形的绘制可以查看我的在线示例：<a href=\"https://snayan.github.io/canvas-demo/?module=shape\">canvas shape</a></p>\n<p>示例项目仓库地址：<a href=\"https://github.com/snayan/canvas-demo\">canvas demo</a></p>\n<h3>图形</h3>\n<h4>三角形</h4>\n<p>先来看看如何绘制一个三角形。三角形就是由三条边组成，我们可以理解为三个线段组成。确定了三角形的三个顶点的坐标位置，然后用线连接起来。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 顶底1</span>\n<span class=\"token keyword\">let</span> point1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// 顶点2</span>\n<span class=\"token keyword\">let</span> point2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// 顶点3</span>\n<span class=\"token keyword\">let</span> point3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">180</span><span class=\"token punctuation\">,</span> <span class=\"token number\">120</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// 开始一段新路径</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">beginPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 移动起点到顶点1</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">moveTo</span><span class=\"token punctuation\">(</span>point1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> point1<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 连接顶点1与顶点2</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">lineTo</span><span class=\"token punctuation\">(</span>point2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> point2<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 连接顶点2与顶点3</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">lineTo</span><span class=\"token punctuation\">(</span>point3<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> point3<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 描边</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">stroke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 绘制文本水平居中</span>\nctx<span class=\"token punctuation\">.</span>textAlign <span class=\"token operator\">=</span> <span class=\"token string\">\"center\"</span>\n<span class=\"token comment\">// 绘制顶点1文本</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">fillText</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>point1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">,</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>point1<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)`</span></span><span class=\"token punctuation\">,</span> point1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> point1<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 绘制顶点2文本</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">fillText</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>point2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">,</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>point2<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)`</span></span><span class=\"token punctuation\">,</span> point2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> point2<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 绘制顶点3文本</span>\nctx<span class=\"token punctuation\">.</span><span class=\"token function\">fillText</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>point3<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">,</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>point3<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)`</span></span><span class=\"token punctuation\">,</span> point3<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> point3<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span></code></pre></div>\n","fields":{"slug":"/post/how_to_draw_graphics/"},"frontmatter":{"date":"July 18, 2018","title":"canvas核心技术-如何绘制图形","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>这篇是学习和回顾 canvas 系列笔记的第一篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>\n学习 canvas，首先得知道如何去绘制线段，然后才能通过很多简单的线段去实现比较复杂的图形，比如常见的图表，柱状图，折线图等都是通过一段一段的线段实现的。</p>\n<h3>基础知识</h3>\n<p>canvas 的基础知识不算多，主要掌握如何绘制线段，图形，图片，文本等。canvas 可以在浏览器中绘制，也可以借助 <a href=\"https://github.com/Automattic/node-canvas\">node-canvas</a>在 node 服务端绘制简单的图片。本文只记录在浏览器中绘制，至于在 node 端如何绘制，自己可以去查看相关资料。</p>\n<p>在浏览器中绘制，就先在 html 中定义 canvas 元素，默认宽高是 300 * 150，可以通过<code class=\"language-text\">width</code>和<code class=\"language-text\">height</code>设置。注意 canvas 元素样式宽高和 canvas 绘图画布宽高不是一个东西，详见<em>知识点 5 中 canvas 宽高</em>。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>canvas</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>canvas<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>当前浏览器不支持canvas，请升级浏览器<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>canvas</span><span class=\"token punctuation\">></span></span></code></pre></div>\n","fields":{"slug":"/post/how_to_draw_line/"},"frontmatter":{"date":"July 09, 2018","title":"canvas核心技术-如何绘制线段","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>最近项目需求中要写较多 H5 小游戏，游戏本身体量不是很复杂，主要是承载较多业务逻辑，所以决定用 canvas 来完成游戏部分。之前只是知道 H5 中有 canvas 这个东西，也知道它大概是画图的，但具体怎么用，还是一无所知的。在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial\">MDN</a>在看了一些相关资料，一口气也看了<a href=\"https://book.douban.com/subject/24533314/\">HTML 5 Canvas 核心技术</a>和<a href=\"https://book.douban.com/subject/27088021/\">HTML5 2D 游戏编程核心技术</a>，对 canvas H5 游戏编程有了大致的了解，发现 canvas 游戏编程其实挺有趣的。目前也在学习 webgl 相关知识，打算把前端可视化这一块也深入学习。现在先记录一些自己认为 canvas 比较重要的知识，回顾和再学习。后续在记录 webgl 相关知识。</p>\n<h3>主要知识点</h3>\n<p>本系列主要深入学习 canvas 2d 编程中相关比较重要和基础的知识，算是对「HTML 5 Canvas 核心技术」这本书的读后感，大致知识点如下：</p>\n<ol>\n<li>基础知识，学习如何绘制线段，图形，图片，文本等。</li>\n<li>动画知识，学习如何用 canvas 实现简单的动画以及相关影响因素</li>\n<li>碰撞检测，学习如何检测两个物体在运动过程中是否发生碰撞</li>\n<li>2D 游戏开发，学习用 canvas 开发 2D 游戏</li>\n<li>canvas 相关小知识点</li>\n</ol>\n<p>在学习过程中，最好是自己能动手实现，我就专门建了一个 canvas demo 的项目，里面都是自己在学习 canvas 时动手写的一些例子，感兴趣的可以去看看。</p>\n<p>项目仓库地址：<a href=\"https://github.com/snayan/canvas-demo\">https://github.com/snayan/canvas-demo</a></p>\n<p>demo 预览地址：<a href=\"https://snayan.github.io/canvas-demo/\">https://snayan.github.io/canvas-demo/</a></p>\n<p>我会按照上面的主要知识点，分篇幅来学习和回顾 canvas 相关的核心技术。主要如下：</p>\n<ul>\n<li><a href=\"/post/how_to_draw_line/\">canvas 核心技术-如何绘制线段</a></li>\n<li><a href=\"/post/how_to_draw_graphics/\">canvas 核心技术-如何绘制图形</a></li>\n<li><a href=\"/post/how_to_draw_image_and_text/\">canvas 核心技术-如何图片和文本</a></li>\n<li><a href=\"/post/how_to_implement_simple_animations/\">canvas 核心技术-如何实现简单动画</a></li>\n<li><a href=\"/post/how_to_implement_complex_animations/\">canvas 核心技术-如何实现复杂动画</a></li>\n<li><a href=\"/post/how_to_detect_collision/\">canvas 核心技术-如何实现碰撞检测</a></li>\n<li>canvas 核心技术-如何实现一个简单的 2D 游戏引擎</li>\n<li>canvas 核心技术-宽高，渐变，绘制真正 1px 线段</li>\n<li>canvas 核心技术-向量，三角函数</li>\n</ul>","fields":{"slug":"/post/core_html5_canvas/"},"frontmatter":{"date":"July 09, 2018","title":"canvas核心技术","tags":["canvas"],"description":null}}},{"node":{"excerpt":"<p>现在前端项目的构建一般基本都是基于 webpack 的。项目的技术栈目前比较主流的是 react 全家桶和 vue 全家桶。\n趁空闲，以公司一个项目整理了 webpack 构建常见的流程,这个项目是使用 vue 全家桶开发的。</p>\n<h3>技术栈</h3>\n<ul>\n<li>vue</li>\n<li>typescript</li>\n</ul>\n<h3>浏览器支持</h3>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"browserslist\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"> 1%\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"last 2 versions\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"not ie &lt;= 9\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Android >= 4.3\"</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n","fields":{"slug":"/post/process_of_webpack_build_project/"},"frontmatter":{"date":"June 27, 2018","title":"webpack构建常见流程","tags":["webpack"],"description":null}}},{"node":{"excerpt":"<h2>目的</h2>\n<p>这个项目主要是用 vue+vuex 实现一个单页面应用，纯粹是熟悉 vue 全家桶相关开发模式，用于练手非常合适。\n着手开发完了之后可以学的东西：</p>\n<ol>\n<li>熟悉 vue 单文件组件开发方式</li>\n<li>熟悉如何写一个 vue 插件</li>\n<li>熟悉如何使用 vue-router 以及挂载路由钩子函数</li>\n<li>熟悉 vuex 是如何运作的，模块化维护应用状态数据</li>\n<li>体验 typescript 的开发方式\n如果想学 vue 的不妨进来看看。\n项目源码地址：<a href=\"https://github.com/snayan/vue-task\">点击这里</a></li>\n</ol>\n<h2>技术栈</h2>\n<ul>\n<li>vue</li>\n<li>vuex</li>\n<li>vue-router</li>\n<li>typescript</li>\n</ul>\n","fields":{"slug":"/post/vue_technology_stack/"},"frontmatter":{"date":"June 15, 2018","title":"vue 全家桶初探","tags":["vue"],"description":null}}},{"node":{"excerpt":"<p>React 中比较重要的就是<strong>React elements</strong>了，可以理解为页面中可看到的节点元素。</p>\n<h2>结构</h2>\n<p>一个<strong>React element</strong>的结构为下面这样，\n<a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f621474fee94664bcdbb6718dcd1081d/1bf5c/react_element.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 27.232142857142854%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3aAD/8QAFRABAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQEAAQUCp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABgQAAIDAAAAAAAAAAAAAAAAAAABEBEh/9oACAEBAAE/IUtFR//aAAwDAQACAAMAAAAQc8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAEBAQEBAAAAAAAAAAAAAAABABExUf/aAAgBAQABPxAUEO7Y8sv/2Q=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/f621474fee94664bcdbb6718dcd1081d/cc182/react_element.webp 148w,\n/static/f621474fee94664bcdbb6718dcd1081d/f7e40/react_element.webp 295w,\n/static/f621474fee94664bcdbb6718dcd1081d/1a2f4/react_element.webp 590w,\n/static/f621474fee94664bcdbb6718dcd1081d/4837b/react_element.webp 885w,\n/static/f621474fee94664bcdbb6718dcd1081d/2f819/react_element.webp 1180w,\n/static/f621474fee94664bcdbb6718dcd1081d/9f9b9/react_element.webp 1344w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/f621474fee94664bcdbb6718dcd1081d/8ee9c/react_element.jpg 148w,\n/static/f621474fee94664bcdbb6718dcd1081d/ebbe7/react_element.jpg 295w,\n/static/f621474fee94664bcdbb6718dcd1081d/c739e/react_element.jpg 590w,\n/static/f621474fee94664bcdbb6718dcd1081d/5413e/react_element.jpg 885w,\n/static/f621474fee94664bcdbb6718dcd1081d/4efde/react_element.jpg 1180w,\n/static/f621474fee94664bcdbb6718dcd1081d/1bf5c/react_element.jpg 1344w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/jpeg\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/f621474fee94664bcdbb6718dcd1081d/c739e/react_element.jpg\"\n          alt=\"react element\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n","fields":{"slug":"/post/learn_react16_part4/"},"frontmatter":{"date":"April 11, 2018","title":"react 16学习(四)","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>ReactDom 在 16 版本中也新增了一些新的功能，比如<strong>createPortal</strong>，<strong>hydrate</strong>。今天主要学习一下<strong>createPortal</strong>。\n先看下 ReactDom 的大致包含的一些属性和方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> ReactDom <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  createPortal<span class=\"token punctuation\">,</span> <span class=\"token comment\">//reacte16中新增的</span>\n  hydrate<span class=\"token punctuation\">,</span> <span class=\"token comment\">//reacte16中新增的</span>\n  findDomNode<span class=\"token punctuation\">,</span>\n  render<span class=\"token punctuation\">,</span>\n  unmountComponentAtNode<span class=\"token punctuation\">,</span>\n  flushSync<span class=\"token punctuation\">,</span>\n  unstable_renderSubtreeIntoContainer<span class=\"token punctuation\">,</span>\n  unstable_createPortal<span class=\"token punctuation\">,</span> <span class=\"token comment\">//这个实际就是现在的createPortal,将在React17版本中移除</span>\n  unstable_batchedUpdates<span class=\"token punctuation\">,</span>\n  unstable_deferredUpdates<span class=\"token punctuation\">,</span>\n  unstable_flushControlled<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到我们熟悉的<code class=\"language-text\">findDomNode</code>，<code class=\"language-text\">render</code>，<code class=\"language-text\">unmountComponentAtNode</code>。这里面新增了两个新的方法<code class=\"language-text\">createPortal</code>和<code class=\"language-text\">hydrate</code>。以 unstable_开头的表示的是当前版本中存在的方法，但可能会在后续版本中改动或移除，所以不建议使用。</p>\n","fields":{"slug":"/post/learn_react16_part3/"},"frontmatter":{"date":"April 04, 2018","title":"react 16学习(三)","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>上篇大致说了 react16 的结构，今天来看看 react16 中新增的 Fragment。</p>\n<p>react16 中新增的可以渲染的类型：<code class=\"language-text\">fragment</code>和<code class=\"language-text\">string</code>。</p>\n<h2>Fragments</h2>\n<p>在 react16 中，<code class=\"language-text\">component</code>的<code class=\"language-text\">render</code>方法现在可以返回一个数组了，而在 react16 之前只能返回一个<code class=\"language-text\">ReactElement</code>，一般被<code class=\"language-text\">div</code>包裹着。在实际使用时，页面会输出一些很多没有用处的<code class=\"language-text\">div</code>，增加了 dom 结构的嵌套层数，不利于页面快速的渲染。</p>\n<h3>react16 之前</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>v<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token string\">`链接</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>v<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/learn_react16_part2/"},"frontmatter":{"date":"March 02, 2018","title":"React 16学习(二)","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>趁着离职期这段时间，制定了一个计划，再次阅读 React16 的源码，React16 是一个大版本的更新，其中新增了许多的新特性，并且重写了核心模块的架构，叫做<strong>Fiber</strong>，最令人兴奋的是<strong>async rendering</strong>。之前也浅显的阅读过 React15 的部分源码，发现这次 React16 与之有很大的不同。</p>\n<h2>核心文件</h2>\n<p>React16 真的是重新梳理了代码结构，并且解耦了很多，下面为 React16 的文件结构</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2157d97d8ca570791edce8da8819a70e/8854f/react16_file_structure.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 76.5079365079365%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHDXJDEH//EABcQAQEBAQAAAAAAAAAAAAAAAAEAITH/2gAIAQEAAQUCOZESxf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAIDAQEAAAAAAAAAAAAAAAABETFBoSH/2gAIAQEAAT8hhgcM6MorpRimvCh//9oADAMBAAIAAwAAABBkD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAAMBAQEBAAAAAAAAAAAAAAABESFxMVH/2gAIAQEAAT8Qd2TbG5pRHXBajeh5b6RTZa8FrdP/2Q=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/2157d97d8ca570791edce8da8819a70e/cc182/react16_file_structure.webp 148w,\n/static/2157d97d8ca570791edce8da8819a70e/f7e40/react16_file_structure.webp 295w,\n/static/2157d97d8ca570791edce8da8819a70e/1a2f4/react16_file_structure.webp 590w,\n/static/2157d97d8ca570791edce8da8819a70e/eae19/react16_file_structure.webp 630w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/2157d97d8ca570791edce8da8819a70e/8ee9c/react16_file_structure.jpg 148w,\n/static/2157d97d8ca570791edce8da8819a70e/ebbe7/react16_file_structure.jpg 295w,\n/static/2157d97d8ca570791edce8da8819a70e/c739e/react16_file_structure.jpg 590w,\n/static/2157d97d8ca570791edce8da8819a70e/8854f/react16_file_structure.jpg 630w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/jpeg\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/2157d97d8ca570791edce8da8819a70e/c739e/react16_file_structure.jpg\"\n          alt=\"react16的文件结构\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>可以看到我们熟悉的 react 和 react-dom。react-art 是绘制图形的，比如 Canvas，SVG，VML。react-call-return 是一个试验性的，用于 react 中的多遍渲染。react-reconciler 是 Fiber 的实现。share 中存放着一些公用的方法和属性。</p>\n","fields":{"slug":"/post/learn_react16_part1/"},"frontmatter":{"date":"March 01, 2018","title":"React 16学习(-)","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>在某次求职过程中，收到了一个笔试题，要求写一个人机对战的五子棋，题目要求如下：</p>\n<blockquote>\n<p>请编写一个单机【五子棋】游戏，要求如下：\n使用原生技术实现，兼容 Chrome 浏览器即可。\n实现胜负判断，并给出赢棋提示；任意玩家赢得棋局，锁定棋盘。\n请尽可能的考虑游戏的扩展性，界面可以使用 DOM / Canvas 实现。考虑后续切换界面实现的方式成本最低。（比如选择使用 DOM 实现界面，需求改变为使用 Canvas 实现时尽可能少的改动代码）。\n实现一个悔棋功能\n实现一个撤销悔棋功能\n实现一个人机对战功能\n尽可能的考虑实现的灵活性和扩展性</p>\n</blockquote>\n<p>自己收到这个题目之后感觉有点棘手，自己没有开发过游戏，时间也比较紧。下班之后就开始弄了，简单介绍下自己的实现过程。</p>\n","fields":{"slug":"/post/gomoku/"},"frontmatter":{"date":"January 23, 2018","title":"简单的五子棋","tags":["javascript","game"],"description":null}}},{"node":{"excerpt":"<p>嗯，又到了年末，是时候对 17 年做个了断，好好开始 18 年。\n17 年的年初计划是：</p>\n<ul>\n<li>找一家靠谱的互联网公司</li>\n<li>阅读 12 本书</li>\n<li>报个英语培训班</li>\n</ul>\n<h3>找一家靠谱的互联网公司</h3>\n<p>年初，3 月份从广田智能来到了深圳卷皮，是找到了一家互联网公司，很互联网 😂。\n从 PC 端半路子前端到移动端的纯前端了，恶补各种移动端开发基础知识，移动端布局方案，详见<a href=\"/post/mobile-layout/\">移动端布局方案</a>。\n从 grunt 的使用到 gulp，再到 webpack。用 gulp 也写一个小的脚手架工具，详见<a href=\"https://github.com/snayan/web-scaffold\">web-scaffold</a>。\n从 backbone 的开发框架到 react，也稍微阅读了一下 react15 的部分源码，详见<a href=\"/post/react_whole_construct/\">阅读 react 源码部分</a>。\n从 0 到 1 开始开发微信小程序，写了一个小程序组件化开发，详见<a href=\"/post/mini_program_component_programming/\">小程序组件化编程</a>。</p>\n<h3>阅读 12 本书</h3>\n<p>从 3 月份开始，一直都坚持在看书，期间虽也断续停了一段，但幸好的是，现在依然坚持着。数数，应该有 12 本书了，详见<a href=\"https://github.com/snayan/bookLists#2017%E8%AE%A1%E5%88%92\">2017 书单</a>。好习惯，要坚持啊 ✊。</p>\n<h3>报个英语培训班</h3>\n<p>额，这个计划实在是没有办，之前 6 月份好像在天虹里有个培训班的招生柜台，大致去了解了一下。下半年就一直在加班，真的没有时间（没时间不是理由，好吧！），一直到现在也没有个没有。明年估计也不会报了，没钱啊（吃土了）。</p>\n<h3>额外收获</h3>\n<p>17 年，抽空搭了一个免费的 GitHub 博客，地址<a href=\"https://snayan.github.io/\">三羊同学的 blog</a>。到现在，写了有接近 10 篇了吧，就是随便写写，总结也好，做笔记也好，当书签也好，反正，这是一个好习惯，不能放弃，要坚持。</p>\n<p>好吧，时间不早了，来小结吧。嗯，17 年确实累了不少，通宵都熬了不少，老了不少，我相信，收获也是不少的。题外话哈，负能量，12 月初也体会了一些凉心的事，但是也收获一些暖心的事。不管怎么样，还是抱着一颗感恩的心，去过 18 年。</p>\n<p>18 年的计划呢？明年再定。</p>","fields":{"slug":"/post/summary_of_2017/"},"frontmatter":{"date":"December 14, 2017","title":"2017年小结","tags":["2017","summary"],"description":null}}},{"node":{"excerpt":"<p>最近一个月都在忙公司的新项目<strong>会过精选</strong>，加上双 11 大促，真的是很忙。加上最近的烦心事比较多，心情一直不是很好，做什么事情，都效率低下。收拾收拾心情，继续努力吧。一切都不会那么糟糕。</p>\n<p>在做会过精选 M 站时，我们前端组选型的技术栈是 React，Redux，TypeScript。一直都知道 decorator 这个东西，但之前在卷皮没有机会用，现在在会过，我就高高兴兴的开始用起来了。\n装饰者的功能实际就是在不改原功能的前提下，对原目标进行额外功能的增强，比如：日志记录，缓存，访问控制等。</p>\n<h3>对类进行装饰</h3>\n<p>decorator 可以作用在类上，达到对类的属性或者原型进行改造。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 定义这个页面是需要登陆权限的页面</span>\n@needPageLogin\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">OpenCoupons</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token operator\">&lt;</span>OpenCouponsProps<span class=\"token punctuation\">,</span> ComponentState<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/note_of_decorator/"},"frontmatter":{"date":"November 26, 2017","title":"笔记之decorator","tags":["decorator","javascript"],"description":null}}},{"node":{"excerpt":"<p>在开发微信小程序时，发现缺少了组件化开发体验，在网上找了一波资源，发现都不是很好。其中，有用开发 Vue 的方式去开发小程序，比如，WePY，最后将源代码编译成小程序的官方文件模式。这种方式，开发感觉爽，但是如果小程序版本升级变了之后，不在支持这种方式，那么就得重新开发一套小程序官方支持的代码了，成本代价很大。并且，这次项目时间非常紧，团队成员不熟悉 vue 的情况下，不敢用 WePY。但是，小程序官方又对组件化支持不是很友好。于是，决定自己弄一套，既有组件化开发体验，又是最大限度的接近小程序官方的开发模式。</p>\n<p>目前项目已经成功上线，小程序：会过精选</p>\n<p><a href=\"https://github.com/snayan/weChart-component\">示例地址</a></p>\n<h3>第一步，改写 Page</h3>\n<p>由于小程序的页面定义是通过<code class=\"language-text\">Page</code>方法去定义的，那么，<code class=\"language-text\">Page</code>一定在小程序内可以认为是一个全局变量，我只需要改写<code class=\"language-text\">Page</code>这个方法，去可以引用组件，调用组件，触发组件的生命周期方法，维持组件内部的数据状态，那么，是不是就可以接近了组件化的编程体验了，并且可以抽离常用组件，达到复用的目的。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 先保存原Page</span>\n<span class=\"token keyword\">const</span> nativePage <span class=\"token operator\">=</span> Page\n\n<span class=\"token comment\">/* 自定义Page */</span>\n<span class=\"token function-variable function\">Page</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...改写Page逻辑，增加自己的功能</span>\n  <span class=\"token comment\">// 最后一定得调用原Page方法，不然，小程序页面无法生成</span>\n  <span class=\"token function\">nativePage</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/mini_program_component_programming/"},"frontmatter":{"date":"September 17, 2017","title":"小程序组件化编程","tags":["mini program"],"description":null}}},{"node":{"excerpt":"<p>一直想抽时间总结一下现在业界可用的移动端布局方案。需求多，995 模式，身心被掏空，一拖再拖，终于在周六的晚上，做着梦弄完成的，不足之道 😪，请指教改正 🤠。</p>\n<h3>media+百分比</h3>\n<p>直接采用媒体查询加百分比去布局。</p>\n<p>核心思想：</p>\n<ul>\n<li>页面主体布局基本采用百分比去设置。</li>\n<li>然后，其他块内布局,例如 font-size 等可通过设置媒体查询的断点来分设置，已达到兼容其他手机尺寸。</li>\n</ul>\n","fields":{"slug":"/post/mobile-layout/"},"frontmatter":{"date":"July 31, 2017","title":"移动端布局方案浅谈","tags":["h5","mobile"],"description":null}}},{"node":{"excerpt":"<p>在做响应式图片加载需要使用到的两个关键属性就是<code class=\"language-text\">srcset</code>和<code class=\"language-text\">sizes</code> ，这两个属性是 H5 中新加的，是给 img 标签提供多个不同尺寸的图片，在不同设备，不同分辨率的情况下加载不同的图片。</p>\n<h3>根据屏幕分辨率选择</h3>\n<p>当只需要根据屏幕分辨率去选择不同的图片的时候，有 2 种情况。</p>\n<p>第 1 种，语法形式为：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">srcset=\"[url] [dpr]x,[url] [dpr]x,....etc\"</code></pre></div>\n<p>一般屏幕的分辨率会到 3 倍，例如 iphone6plus，其 dpr=3，这种是直接给出每种图片的分辨率规格，例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span>\n  <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>./mm-width-128px.jpg<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>示例图片<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">srcset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>./mm-width-256px.jpg 2x, ./mm-width-512px.jpg 3x<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>上面的示例表示，在 dpr=1 的屏幕下加载 128px 这张图片；在 1&#x3C;dpr&#x3C;=2 时，加载 256px 这张图片；当 dpr>2 时就加载 512px 这张图片了。\n注意，srcset 里的<strong>x</strong>一定要是小写，大写的话，chrome 会无法识别。\n<a href=\"https://webkit.org/demos/srcset/\">查看 demo</a></p>\n","fields":{"slug":"/post/img_srcset_seizes/"},"frontmatter":{"date":"July 24, 2017","title":"响应式图片加载","tags":["resposive","mobile"],"description":null}}},{"node":{"excerpt":"<p>看了这么多框架方面的东西，但注意，基础很重要。今天就来说说 javascipt 中容易忽略的类型转换问题。\n在 javascript 中有 7 种基本类型，它们为：<code class=\"language-text\">string</code>，<code class=\"language-text\">number</code>，<code class=\"language-text\">boolean</code>，<code class=\"language-text\">undefined</code>，<code class=\"language-text\">null</code>，<code class=\"language-text\">symbol</code>，<code class=\"language-text\">object</code>。判断类型的方式是<code class=\"language-text\">typeof</code>。我们把<code class=\"language-text\">string</code>，<code class=\"language-text\">number</code>，<code class=\"language-text\">boolean</code>，<code class=\"language-text\">undefined</code>，<code class=\"language-text\">null</code>，<code class=\"language-text\">symbol</code>这几类称为原始类型。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">typeof</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 'number'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token string\">\"aa\"</span> <span class=\"token comment\">// 'string'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// 'boolean'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 'symbol'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">undefined</span> <span class=\"token comment\">// 'undefined'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 'object'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 'object'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 'function'</span></code></pre></div>\n<p>注意两点，一是，对于函数，实际上也可以认为是<code class=\"language-text\">object</code>，但使用<code class=\"language-text\">typeof</code>得到的结果是<code class=\"language-text\">function</code>；二是，对于<code class=\"language-text\">null</code>，<code class=\"language-text\">typeof</code>得到的结果是<code class=\"language-text\">object</code>。</p>\n","fields":{"slug":"/post/explanatio_of_ToPrimitive/"},"frontmatter":{"date":"July 06, 2017","title":"javascript中ToPrimitive详解","tags":["javascript"],"description":null}}},{"node":{"excerpt":"<p>众所周知，react 的组件是有一个个的钩子函数，构建成的生命周期，在用 es6 的 class 与用 createClass 有所不同，其中 createClass 还包括了<code class=\"language-text\">getDefaultProps</code>与<code class=\"language-text\">getInitialState</code>。由于 createClass  将在后续版本中移除，建议使用 class 形式。所以，下面讨论的都是 class 形式下的生命周期方式。</p>\n<h2>初始阶段</h2>\n<ul>\n<li>constructor ，构造函数，在初始化实例时首先触发</li>\n<li>componentWillMount，组件将渲染出来之前触发，可以调用 setState，简单的合并 state，不会触发 render 重新渲染</li>\n<li>render ，将组件渲染，不可以调用 setState</li>\n<li>componentDidMount，组件渲染之后触发，可以调用 setState，会重新触发 render</li>\n</ul>\n","fields":{"slug":"/post/react_component_life_cycle/"},"frontmatter":{"date":"June 19, 2017","title":"react组件生命周期浅谈","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>ReactMount 为 react-dom 对象提供了<code class=\"language-text\">render</code>和<code class=\"language-text\">unmountComponentAtNode</code>这 2 个方法，其中第一个<code class=\"language-text\">render</code>就是我们常用的输出 react element 到真实的 dom 里。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> ReactMount <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">scrollMonitor</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">container<span class=\"token punctuation\">,</span> renderCallback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">renderSubtreeIntoContainer</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">parentComponent<span class=\"token punctuation\">,</span>\n    nextElement<span class=\"token punctuation\">,</span>\n    container<span class=\"token punctuation\">,</span>\n    callback</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">render</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextElement<span class=\"token punctuation\">,</span> container<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">unmountComponentAtNode</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">container</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/reactdom_reactmount_source/"},"frontmatter":{"date":"June 10, 2017","title":"阅读react-dom源码--ReactMount部分","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>ReactElement 对象为 React 提供了<code class=\"language-text\">createElement</code>，<code class=\"language-text\">createFactory</code>，<code class=\"language-text\">cloneElement</code>，<code class=\"language-text\">isValidElement</code>四个方法。ReactElement 是一个工厂方法，不是类模式，不要使用<code class=\"language-text\">new</code>去调用。检查一个对象是否是 react element 对象，通过检查这个对象的<code class=\"language-text\">$$typeof</code>是否等于<code class=\"language-text\">Symbol.for(&#39;react.element&#39;)</code></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">ReactElement</span><span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">,</span>ref<span class=\"token punctuation\">,</span>self<span class=\"token punctuation\">,</span>source<span class=\"token punctuation\">,</span>owner<span class=\"token punctuation\">,</span>props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> element<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n\t$$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span><span class=\"token constant\">REACT_ELEMENT_TYPE</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// Symbol['for']('react.element')</span>\n    type<span class=\"token punctuation\">:</span>type<span class=\"token punctuation\">,</span>\n    key<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">,</span>\n    ref<span class=\"token punctuation\">:</span>ref<span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">:</span>props<span class=\"token punctuation\">,</span>\n    _owner<span class=\"token punctuation\">:</span>owner\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span><span class=\"token operator\">!==</span><span class=\"token string\">'production'</span><span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ....... 增加一些其他的属性</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span>freeze<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      Object<span class=\"token punctuation\">.</span><span class=\"token function\">freeze</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      Object<span class=\"token punctuation\">.</span><span class=\"token function\">freeze</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/reactelement_source/"},"frontmatter":{"date":"May 30, 2017","title":"阅读react源码--ReactElement部分","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>ReactClass 对象为 React 提供了<code class=\"language-text\">createClass</code>方法，实际上 ReactClass 有 2 个属性，一个是<code class=\"language-text\">createClass</code>，另外一个是<code class=\"language-text\">injection</code>对象。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> ReactClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">createClass</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">spec</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// createClass实现</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  injection<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">injectMixin</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">mixin</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      injectedMixins<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>mixin<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/reactclass_source/"},"frontmatter":{"date":"May 22, 2017","title":"阅读react源码--createClass部分","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>今天主要看下<code class=\"language-text\">React.Component</code>，实际上<code class=\"language-text\">Component</code>是<code class=\"language-text\">React</code>对象上一个构造函数。\n构造函数接受三个参数，<code class=\"language-text\">props</code>，<code class=\"language-text\">context</code>，<code class=\"language-text\">updater</code>，<code class=\"language-text\">updater</code>实际是在<code class=\"language-text\">render</code>中注入的，它是用来实际更新<code class=\"language-text\">state</code></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">ReactComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> updater</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>context <span class=\"token operator\">=</span> context\n  <span class=\"token comment\">// emptyObject 是一个空对象{}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>refs <span class=\"token operator\">=</span> emptyObject\n  <span class=\"token comment\">// ReactNoopUpdateQueue is the abstract API for an update queue</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> updater <span class=\"token operator\">||</span> ReactNoopUpdateQueue\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/react_component_source/"},"frontmatter":{"date":"May 09, 2017","title":"阅读react源码--component部分","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>最近打算学习 react 与 redux 的源码，以此记录在学习过程中做的笔记吧。\n先来整体看看 react 的结构吧，实际上 react 就是一个对象，在实际使用的时候是这样的方式</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span>\n<span class=\"token comment\">// 或则</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component<span class=\"token punctuation\">,</span> createElement <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span></code></pre></div>\n<p>查看源码发现，react 对象就是一些包含一些属性的常见对象。常见的属性包括<code class=\"language-text\">Component</code>，<code class=\"language-text\">createElement</code>，<code class=\"language-text\">cloneElement</code>，<code class=\"language-text\">createClass</code>，<code class=\"language-text\">DOM</code>等。</p>\n","fields":{"slug":"/post/react_whole_construct/"},"frontmatter":{"date":"May 04, 2017","title":"阅读react源码--react整体结构","tags":["react"],"description":null}}},{"node":{"excerpt":"<p>单例模式，简单的说就是保证一个特定的类仅有一个实例，也就是不管实例化几次，都是返回的同一个实例。在 javascript 中，没有类的概念，每一个对象字面量都可以是认为是一个单例。对象全等，表示引用的同一个内存地址。</p>\n<p>在 javascript 中实现单例模式，有如下几种方式：</p>\n<ul>\n<li>全局变量方式，这种方式不好，全局变量可被随意改变，且可能与其他类库命名冲突</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> instance\n<span class=\"token keyword\">function</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> instance\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 做一些其他操作</span>\n  instance <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n","fields":{"slug":"/post/singleton/"},"frontmatter":{"date":"May 02, 2017","title":"单例模式","tags":["design patterns"],"description":null}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}