{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"fa6b6f53-e174-5aeb-bebf-d9d267173e7e","excerpt":"这篇是学习和回顾 canvas 系列笔记的第六篇，完整笔记详见：canvas 核心技术。在上一篇canvas…","html":"<p>这篇是学习和回顾 canvas 系列笔记的第六篇，完整笔记详见：<a href=\"/post/core_html5_canvas/\">canvas 核心技术</a>。</p>\n<p>在上一篇<a href=\"/post/how_to_implement_complex_animations/\">canvas 核心技术-如何实现复杂的动画</a>笔记中，我们详细讨论了在制作复杂动画时，需要考虑时间因素，物理因素等，同时还回顾了如何使用缓动函数来扭曲时间轴实现非线性运动，比如常见的缓入，缓出，缓入缓出等。在游戏或者动画中，运动的物体在变化的过程中，它们是有可能碰撞在一起的，那么这一篇我们就来详细学习下如何进行碰撞检测。</p>\n\n          <h3 id='toc-3-1' >\n            边界值检测\n          </h3>\n        \n<p>最简单的检测手段就是边界值检测了，就是对一个运动的物体的某些属性进行条件判断，如果达到了这个条件，则说明发生了碰撞。例如在上一篇中的示例，小球自由下落，当在检测小球是否与地面发生碰撞时，我们是检测小球下落的高度 fh 是否达到了小球本身距离地面的高度 dh，如果 fh > dh，则说明小球与地面发生了碰撞。</p>\n<pre><code class=\"language-javascript\">let distance = ball.currentSpeed * t\nif (ball.offset + distance > ball.verticalHeight) {\n  // 落到地面了，发生了碰撞\n  // ...\n} else {\n  // 还没有落到地面，没有发生碰撞\n  ball.offset += distance\n}\n</code></pre>\n<!--more-->\n<p><a href=\"https://snayan.github.io/canvas-demo/?module=free_fall\">这里是我的小球自由落体完整在线示例</a></p>\n<p>这种检测方式非常的简单且准确，在针对类似业务开发时，我们可以简化成边界值检测。但是当我们开发较为复杂游戏时，边界值检测通常不能很好的实现，为了更加真实，它通常与其他检测方法一起使用。</p>\n\n          <h3 id='toc-3-2' >\n            外接图形检测\n          </h3>\n        \n<p>在 canvas 游戏中，对于不规则的物体，比如运动的小人等，我们可以通过抽象成一个矩形，使得这个矩形恰好可以包裹这个物体，在进行碰撞检测时，就可以使用这个矩形来代替实际的物体。这种方法，实际上就是通过抽象，将复杂简单化，对于精确度不是那么高的动画或者游戏，我们直接使用这种外接图形来检测就可以了。在抽象图形的时候，我们要根据具体的物体，比如小人可以抽象成矩形，太阳就要抽象成圆了，把具体的物体抽象的跟它相似的形状，这样在检测时就会更加准确。</p>\n<p>进行了图形抽象之后，我们在检测就只需对图形进行检测了。对于两个图形是否发生碰撞，我们只需要判断它们是否存在相交的部分，如果存在相交的部分，那么则可以认为是发生了碰撞，否则就没有。下面，我们分别来学习矩形和矩形的碰撞检测，圆和圆的碰撞检测，矩形和圆的碰撞检测。</p>\n<p>矩形与矩形碰撞情况，</p>\n<p><img src=\"./rect_rect.png\" alt=\"rect_rect\"></p>\n<p>这里列举两个矩形发生碰撞的所有情况，在 canvas 中具体代码实现如下，</p>\n<pre><code class=\"language-javascript\">/* 判断是否两个矩形发生碰撞 */\nprivate didRectCollide(sprite: RectSprite, otherSprite: RectSprite) {\n  let horizontal = sprite.left + sprite.width > otherSprite.left &#x26;&#x26; sprite.left &#x3C; otherSprite.left + otherSprite.width;\n  let vertical = sprite.top &#x3C; otherSprite.top + otherSprite.height &#x26;&#x26; sprite.top + sprite.height > otherSprite.top;\n  return horizontal &#x26;&#x26; vertical;\n}\n</code></pre>\n<p>其实就是分别在水平方向和垂直方向判断这两个矩形是否发生重叠。</p>\n<p>圆和圆碰撞情况，</p>\n<p><img src=\"./circle_circle.png\" alt=\"circle_circle\"></p>\n<p>判断两个圆是否发生碰撞，就是判断两个圆的圆心之间的距离是否小于它们的半径之和，如果小于半径之和，则发生碰撞，否则就没有发生碰撞。主要就是计算两个圆心之间的距离，可以根据坐标系中两点之间距离公式得到，</p>\n<p>$$\n|AB| = \\sqrt{(x<em>1-x</em>2)^2 + (y_1-y2)^2}\n$$</p>\n<p>在 canvas 中具体代码实现如下，</p>\n<pre><code class=\"language-javascript\">/* 判断是否两个圆发生碰撞 */\nprivate didCircleCollide(sprite: CircleSprite, otherSprite: CircleSprite) {\n  return distance(sprite.x, sprite.y, otherSprite.x, otherSprite.y) &#x3C; sprite.radius + otherSprite.radius;\n}\n</code></pre>\n<p>矩形和圆碰撞情况，</p>\n<p><img src=\"./rect_circle.png\" alt=\"rect_circle\"></p>\n<p>这种情况，就是判断圆形到矩形上最近的一点的距离是否小于圆的半径，如果小于圆的半径，则发生碰撞，否则就没有发生碰撞。我们首先要找到圆距离矩形上最近的点的坐标，这种就要考虑圆心在矩形左侧，圆心在矩形上面，圆心在矩形右侧，圆心在矩形下面，圆心在矩形里面这五种情况。如果圆心在矩形里面，那么一定是碰撞的。其他四种情况根据每一种情况来计算得到矩形上离圆心最近的一点，下面举例其中一种情况，其他情况原理类似，比如圆心在矩形左侧，</p>\n<p><img src=\"./rect_circle_left.png\" alt=\"rect_circle_left\"></p>\n<p>这种情况下，最近一点的 X 轴坐标跟矩形左上角坐标的 X 轴坐标相等，跟圆心 Y 轴坐标相等，这样就可以得出来了，$(rect<em>x,circle</em>y)$。在 canvas 中具体代码实现如下，</p>\n<pre><code class=\"language-javascript\">/* 判断是否矩形和圆形发生碰撞 */\nprivate didRectWidthCircleCollide(rectSprite: RectSprite, circleSprite: CircleSprite) {\n  let closePoint = { x: undefined, y: undefined };\n  if (circleSprite.x &#x3C; rectSprite.left) {\n    closePoint.x = rectSprite.left;\n  } else if (circleSprite.x &#x3C; rectSprite.left + rectSprite.width) {\n    closePoint.x = circleSprite.x;\n  } else {\n    closePoint.x = rectSprite.left + rectSprite.width;\n  }\n  if (circleSprite.y &#x3C; rectSprite.top) {\n    closePoint.y = rectSprite.top;\n  } else if (circleSprite.y &#x3C; rectSprite.top + rectSprite.height) {\n    closePoint.y = circleSprite.y;\n  } else {\n    closePoint.y = rectSprite.top + rectSprite.height;\n  }\n  return distance(circleSprite.x, circleSprite.y, closePoint.x, closePoint.y) &#x3C; circleSprite.radius;\n}\n</code></pre>\n<p><a href=\"https://snayan.github.io/canvas-demo/?module=collide_01\">这里是我的外接图形碰撞检测在线示例</a>。</p>\n\n          <h3 id='toc-3-3' >\n            光线投射检测\n          </h3>\n        \n<blockquote>\n<p>光线投射法：画一条与物体的速度向量相重合的线，然后再从另外一个待检测物体出发，绘制第二条线，根据两条线的交点位置来判定是否发生碰撞。</p>\n</blockquote>\n<p><img src=\"./light_collide.png\" alt=\"light_collide\"></p>\n<p>光线投射法一般还会结合边界值检测来进行严格准确的判断，这种方法要求我们在动画更新中，不断计算出两个速度向量的交点坐标，根据交点坐标判断是否满足碰撞条件，交点满足了条件，我们还要运用边界值检测方法来检测运动物体是否满足边界值条件，只有同时满足才判断为发生碰撞。这种检测，准确度一般比较高，特别是适用于运动速度快的物体。以小球投桶示例，检测代码如下，</p>\n<pre><code class=\"language-javascript\">/* 是否发生碰撞 */\npublic didCollide(ball: CircleSprite, bucket: ImageSprite) {\n  let k1 = ball.verticalVelocity / ball.horizontalVelocity;\n  let b1 = ball.y - k1 * ball.x;\n  let inertSectionY = bucket.mockTop; //计算交点Y坐标\n  let insertSectionX = (inertSectionY - b1) / k1; //计算交点X坐标\n  return (\n    insertSectionX > bucket.mockLeft &#x26;&#x26;\n    insertSectionX &#x3C; bucket.mockLeft + bucket.mockWidth &#x26;&#x26;\n    ball.x > bucket.mockLeft &#x26;&#x26;\n    ball.x &#x3C; bucket.mockLeft + bucket.mockWidth &#x26;&#x26;\n    ball.y > bucket.mockTop &#x26;&#x26;\n    ball.y &#x3C; bucket.mockTop + bucket.mockHeight\n  );\n}\n</code></pre>\n<p><a href=\"https://snayan.github.io/canvas-demo/?module=collide_02\">这里是我的光线投射检测在线示例</a>。</p>\n\n          <h3 id='toc-3-4' >\n            分离轴检测\n          </h3>\n        \n<p>在判断凸多边形的碰撞检测时，我们可以使用分离轴方法。在学习分离轴检测之前，我们需要先熟悉向量的一些基础知识。</p>\n<p>向量基础知识：</p>\n<ul>\n<li>在平面二维坐标系中，我们可以使用向量来表示某个点的位置。向量表示法就是从坐标原点（0，0）指向目标点（x，y） 。</li>\n<li>两个向量相减，结果是另外一条新的向量。</li>\n<li>两个向量做点积，可以得到投影的值。</li>\n<li>单位向量，就是长度为 1 的向量，其实际作用是表示方向。</li>\n<li>一个向量垂直于另外一个向量，我们叫做法向量。</li>\n</ul>\n<p><img src=\"./system.png\" alt=\"system\"></p>\n<p>图中可以看到，$\\overrightarrow{oa} -\\overrightarrow{ob} = \\overrightarrow{ba}$，$\\overrightarrow{oa} * \\overrightarrow{ob} = |od|$。多余凸多边形的每个顶点，我们可以用向量来表示。</p>\n<p>分离轴检测思路，</p>\n<ol>\n<li>先获取被检测多边形的所有的投影轴，一般只需要计算出多边形对应边的投影轴即可</li>\n<li>计算出被检测多边形在每一条投影轴上的投影</li>\n<li>判断它们的投影是否重叠，如果存在在任意一条投影轴的投影不重叠，则说明它们没有发生碰撞，否则就发生了碰撞</li>\n</ol>\n<pre><code class=\"language-typescript\">/* 判断是否发生碰撞 */\npublic didCollide(sprite: Sprite, otherSprite: Sprite) {\n  let axes1 = sprite.type === 'circle' ? (sprite as Circle).getAxes(otherSprite as Polygon) : (sprite as Polygon).getAxes();\n  let axes2 = otherSprite.type === 'circle' ? (otherSprite as Circle).getAxes(sprite as Polygon) : (otherSprite as Polygon).getAxes();\n  // 第一步：获取所有的投影轴\n  // 第二步：获取多边形在各个投影轴的投影\n  // 第三步：判断是否存在一条投影轴上，多边形的投影不相交，如果存在不相交的投影则直接返回false，如果有所的投影轴上的投影都存在相交，则说明相碰了。\n  let axes = [...axes1, ...axes2];\n  for (let axis of axes) {\n    let projections1 = sprite.getProjection(axis);\n    let projections2 = otherSprite.getProjection(axis);\n    if (!projections1.overlaps(projections2)) {\n      return false;\n    }\n  }\n  return true;\n}\n</code></pre>\n<p>下面我们就按照这三个步骤来，一步一步实现分离轴检测方法。</p>\n<p>获取投影轴</p>\n<p><img src=\"./projection.png\" alt=\"projection\"></p>\n<p>在多边形中，我们是以边来建立边向量的，边向量的法向量，就是这条边的投影轴了。对于投影轴，我们只需它的方向，所以一般会把它格式化为单位向量。</p>\n<pre><code class=\"language-typescript\">// 获取凸多边形的投影轴\npublic getAxes() {\n  let points = this.points;\n  let axes = [];\n  for (let i = 0, j = points.length - 1; i &#x3C; j; i++) {\n      let v1 = new Vector(points[i].x, points[i].y);\n      let v2 = new Vector(points[i + 1].x, points[i + 1].y);\n      axes.push(\n          v1\n          .subtract(v2)\n          .perpendicular()\n          .normalize(),\n      );\n  }\n  let firstPoint = points[0];\n  let lastPoint = points[points.length - 1];\n  let v1 = new Vector(lastPoint.x, lastPoint.y);\n  let v2 = new Vector(firstPoint.x, firstPoint.y);\n  axes.push(\n      v1\n      .subtract(v2)\n      .perpendicular()\n      .normalize(),\n  );\n  return axes;\n}\n</code></pre>\n<p>获取了待检测图形的投影轴之后，我们就需要计算图形在每条投影轴上的投影</p>\n<pre><code class=\"language-typescript\">public getProjection(v: Vector) {\n  let min = Number.MAX_SAFE_INTEGER;\n  let max = Number.MIN_SAFE_INTEGER;\n  for (let point of this.points) {\n    let p = new Vector(point.x, point.y);\n    let dotProduct = p.dotProduct(v);\n    min = Math.min(min, dotProduct);\n    max = Math.max(max, dotProduct);\n  }\n  return new Projection(min, max);\n}\n</code></pre>\n<p>最后判断投影是否重叠</p>\n<pre><code class=\"language-typescript\">/* 投影是否重叠 */\noverlaps(p: Projection) {\n  return this.max > p.min &#x26;&#x26; p.max > this.min;\n}\n</code></pre>\n<p>其中，如果是一个圆形与一个凸多边形的检测时，在计算圆对应的投影轴时比较特殊，圆只有一条投影轴，就是圆心与它距离多边形最近顶点的向量，</p>\n<pre><code class=\"language-typescript\">// 获取圆的投影轴\npublic getAxes(polygon: Polygon) {\n  // 对于圆来说，获取其投影轴就是将圆心与他距离多边形最近顶点的连线\n  let { x, y } = this;\n  let nearestPoint = null;\n  let nearestDistance = Number.MAX_SAFE_INTEGER;\n  for (let [index, point] of polygon.points.entries()) {\n    let d = distance(x, y, point.x, point.y);\n    if (d &#x3C; nearestDistance) {\n      nearestDistance = d;\n      nearestPoint = point;\n    }\n  }\n  let v1 = new Vector(x, y);\n  let v2 = new Vector(nearestPoint.x, nearestPoint.y);\n  return [v1.subtract(v2).normalize()];\n}\n</code></pre>\n<p><a href=\"https://snayan.github.io/canvas-demo/?module=collide_03\">这里是我的分离轴检测在线示例</a>。</p>\n\n          <h3 id='toc-3-5' >\n            小结\n          </h3>\n        \n<p>这篇笔记详细记录了 2d 图形中碰撞检测的方法，比较简单的方法是外接图形法和边界值检测法，它们相对不是那么精确，比较复杂和精确的方法有光线投射法和分离轴法。根据不同的场景和精确度要求，我们选择不同的方法。其他，除了上面几种，还有像素检测等方法也可以实现碰撞检测，像素检测是以像素为单位来检测，如果存在不透明的像素在同一个坐标上重叠，则说明发生了碰撞，具体实现可以查看<a href=\"https://benjaminhorn.io/code/pixel-accurate-collision-detection-with-javascript-and-canvas/\">Pixel accurate collision detection with Javascript and Canvas</a>。</p>\n<p>对于这几种检测方法，强力建议熟悉掌握分离轴法，因为它使用的范围最为广泛，对于任意的凸多边形，它都可以较精确的检测出来。由于分离轴检测法计算量一般比较大，所以在检测之前，我们先过滤掉那些根本不可能发生碰撞的图形，一般方法是空间分隔法，或者过滤可视区间不可见的图形等，然后再对较小的一部分可能发生碰撞的图形来进行计算检测，这样可以提升检测的速度。</p>\n\n          <h4 id='toc-4-1' >\n            参考\n          </h4>\n        \n<ul>\n<li><a href=\"https://github.com/JChehe/blog/issues/8\">“等一下，我碰！”——常见的 2D 碰撞检测</a> 「部分图片引用这篇文章的，这篇文章写的较好，建议读者看看」</li>\n<li><a href=\"https://book.douban.com/subject/24533314/\">《HTML5 Canvas 核心技术：图形、动画与游戏开发》</a></li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">边界值检测</a><ul><li><a href=\"#toc-4-1\">参考</a></li></ul></li><li><a href=\"#toc-3-2\">外接图形检测</a><ul></ul></li><li><a href=\"#toc-3-3\">光线投射检测</a><ul></ul></li><li><a href=\"#toc-3-4\">分离轴检测</a><ul></ul></li><li><a href=\"#toc-3-5\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"canvas-核心技术-如何实现碰撞检测","date":"August 26, 2018","tags":["canvas"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/how_to_detect_collision/","previous":{"fields":{"slug":"/post/how_to_implement_complex_animations/"},"frontmatter":{"title":"canavs核心技术-如何实现复杂的动画"}},"next":{"fields":{"slug":"/post/resolve_vue_style_update_problem/"},"frontmatter":{"title":"看vue源码解决组件style更新问题"}}}}