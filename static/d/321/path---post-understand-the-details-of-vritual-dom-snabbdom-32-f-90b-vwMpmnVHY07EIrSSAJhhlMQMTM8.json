{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"61acb6ff-a555-56b4-b3c2-56bfe6db2f18","excerpt":"最近想了解一下 React 和 Vue 框架分别在 virtual dom 部分的实现，以及他们的不同之处。于是先翻开 Vue 的源码去找 virtual dom 的实现，看到开头，它就提到了 Vue 的 virtual dom 更新算法是基于 Snabbdom 实现的。于是，又去克隆了 Snabbdom…","html":"<p>最近想了解一下 React 和 Vue 框架分别在 virtual dom 部分的实现，以及他们的不同之处。于是先翻开 Vue 的源码去找 virtual dom 的实现，看到开头，它就提到了 Vue 的 virtual dom 更新算法是基于 Snabbdom 实现的。于是，又去克隆了 Snabbdom 的源码，发现它的源码并不是很复杂并且星星 🌟 还很多，所以就仔细看了一遍了，这里就将详细学习一下它是如何实现 virtual dom 的。</p>\n<p>在 Snabbdom 的 GitHub 上就解释了，它是一个实现 virtual dom 的库，简单化，模块化，以及强大的特性和性能。</p>\n<blockquote>\n<p>A virtual DOM library with focus on simplicity, modularity, powerful features and performance.</p>\n</blockquote>\n<p><a href=\"https://github.com/snabbdom/snabbdom\">这里是 Snabbdom 的仓库地址</a>。</p>\n\n          <h3 id='toc-3-1' >\n            init\n          </h3>\n        \n<!--more-->\n<p>Snabbdom 的简单是基于它的模块化，它对 virtual dom 的设计非常巧妙，在核心逻辑中只会专注于 vNode 的更新算法计算，而把每个节点具体要更新的部分，比如<code>props</code>，<code>class</code>，<code>styles</code>，<code>datalist</code>等放在独立的模块里，通过在不同时机触发不同 module 的钩子函数去完成。通过这样的方式解耦，不仅可以使代码组织结构更加清晰，更可以使得每一部分都专注于实现特定的功能，在设计模式中，这个也叫做单一职责原则。在实际场景使用时，可以只引入需要用到的特定模块。比如我们只会更新节点的类名和样式，而不关心属性以及事件，那么就只需要引用 class 和 style 的模块就可以了。例如下面这样，</p>\n<pre><code class=\"language-javascript\">// 这里我们只需要用到class和style模块，所以就可以只需要引用这2个模块\nvar patch = snabbdom.init([\n  require(\"snabbdom/modules/class\").default,\n  require(\"snabbdom/modules/style\").default,\n])\n</code></pre>\n<p>它的核心方法就是这个<code>init</code>，我们先来简单看一下这个函数的实现，</p>\n<pre><code class=\"language-typescript\">// 这里是module中的钩子函数\nconst hooks = [\"create\", \"update\", \"remove\", \"destroy\", \"pre\", \"post\"]\nexport function init(modules: Array&#x3C;Partial&#x3C;Module>>, domApi?: DOMAPI) {\n  let i: number,\n    j: number,\n    cbs = {} as ModuleHooks\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi\n  // cbs存储了引入的modules中定义的钩子函数，\n  for (i = 0; i &#x3C; hooks.length; ++i) {\n    cbs[hooks[i]] = []\n    for (j = 0; j &#x3C; modules.length; ++j) {\n      const hook = modules[j][hooks[i]]\n      if (hook !== undefined) {\n        cbs[hooks[i]].push(hook)\n      }\n    }\n  }\n\n  // 还定义了一些其他的内部方法，这些方法都是服务于patch\n  function emptyNodeAt() {\n    /* ... */\n  }\n  function createRmCb() {\n    /* ... */\n  }\n  function createElm() {\n    /* ... */\n  }\n  function addVnodes() {\n    /* ... */\n  }\n  function invokeDestroyHook() {\n    /* ... */\n  }\n  function removeVnodes() {\n    /* ... */\n  }\n  function updateChildren() {\n    /* ... */\n  }\n  function patchVnode() {\n    /* ... */\n  }\n\n  // init返回了一个patch函数，这个函数接受2个参数，第一个是将被更新的vNode或者真实dom节点，第二个是用来更新的新的vNode\n  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {\n    //...\n  }\n}\n</code></pre>\n<p>从<code>init</code>函数整体来看，它接受一个 modules 数组，返回一个新的函数<code>patch</code>。这不就是我们熟悉的闭包函数吗？在<code>init</code>中，它会将引入模块的钩子函数通过遍历存储在<code>cbs</code>变量里，后面在执行更新算法时会相应的触发这些钩子函数。只需要初始化一次，后面 virtual dom 的更新都是通过<code>patch</code>来完成的。</p>\n<p>流程图如下，</p>\n<p><img src=\"./main.png\" alt=\"main\"></p>\n\n          <h3 id='toc-3-2' >\n            patch\n          </h3>\n        \n<p>最为复杂也最为耗时的部分就是如何实现 virtual dom 的更新，更新算法的好坏直接影响整个框架的性能，比如 React 中的 react-reconciler 模块，到 vue 中的 vdom 模块，都是最大可能优化这一部分。在 Snabbdom 中 virtual dom 的更新逻辑大致如下，</p>\n<pre><code class=\"language-typescript\">// 这个patch就是init返回的\nfunction patch(oldVnode, vnode) {\n  // 第一步：如果oldVnode是Element，则根据Element创建一个空的vnode，这个也是vnode tree的根节点\n  if (!isVnode(oldVnode)) {\n    oldVnode = emptyAtNode(oldVnode)\n  }\n  // 第二步：判断oldVnode是否与vnode相同的元素，如果是，则更新元素即可。\n  // 这里判断它们是否相同，是对比了它们的key相同且tagName相同且ID属性相同且类相同\n  if (sameVnode(oldVnode, vnode)) {\n    patchVnode(oldVnode, vnode)\n  } else {\n    // 第三步：如果不相同，则直接用vnode创建新的element元素替换oldVnode，且删除掉oldVnode。\n    elm = oldVnode.elm\n    parent = api.parentNode(elm)\n    createElm(vnode)\n    if (parent !== null) {\n      api.insertBefore(parent, vnode.elm, api.nextSlibing(elm))\n      removeVnodes(parent, [oldVnode], 0, 0)\n    }\n  }\n}\n</code></pre>\n<p><code>patch</code>逻辑可以简化为下面：</p>\n<ol>\n<li>如果 oldVnode 是 Element 类型，则根据 oldVnode 创建一个空 vnode，这个空 vnode 也是这个 vnode tree 的 root 节点</li>\n<li>比较 oldVnode 与 vnode，如果是同一个 vnode（key 值相同）或者是相同类型的元素（tagName 相同且 id 相同且 class 相同），则直接调用<code>patchVnode</code></li>\n<li>否则，直接根据 vnode 创建一个新的 element，且用新的 element 替换掉 oldVnode 的 element，且删除掉 oldVnode</li>\n</ol>\n<p>流程图如下，</p>\n<p><img src=\"./structure.png\" alt=\"structure\"></p>\n<p>在进行第 3 步时，当 oldVnode 与 vnode 不相同，是直接抛弃了旧的节点，创建新的节点来替换，在用新 vnode 来创建节点时会检查当前 vnode 有没有 children，如果有，则也会遍历 children 创建出新的 element。这意味 oldVnode 以及包含的所有子节点将被作为一个整体被新的 vnode 替换。示意图如下，</p>\n<p><img src=\"./replace.png\" alt=\"replace\"></p>\n<p>如果 B 与 B'不相同，则 B 在被 B'替换的过程中，B 的子节点 D 也就被 B'的子节点 D'和 E'一起替换掉了。</p>\n\n          <h3 id='toc-3-3' >\n            patchVnode\n          </h3>\n        \n<p>我们再来看看第 2 步，如果 oldVnode 与 vnode 相同，则会复用之前已经创建好的 dom，只是更新这个 dom 上的差异点，比如 text，class，datalist，style 等。这个是在函数<code>patchVnode</code>中实现的，下面为它的大致逻辑，</p>\n<pre><code class=\"language-typescript\">function patchVnode(oldVnode, vnode) {\n   // 获取oldVnode的dom对象\n  const elm = oldVnode.elm\n  // 将vnode的elm直接指向elm，复用oldVnode的dom对象，因为它们类型相同\n  vnode.elm = elm\n  // 如果oldVnode与vnode相等，则直接返回，根本不用更新了\n  if (oldVnode === vnode) {\n    return\n  }\n  // 如果vnode是包含text，且不等于oldVnode.text，则直接更新elm的textContent为vnode.text\n  if (isDef(vnode.text) &#x26;&#x26; vnode.text !== oldVnode.text) {\n    return api.setTextContext(elm, vnode.text)\n  }\n  let oldCh = oldVnode.children // 获取oldVnode的子节点\n  let ch = vnode.children // 获取vnode的子节点\n\n  // 如果oldVnode没有子节点，而vnode有子节点,则添加vnode的子节点\n  if (isUndef(oldCh) &#x26;&#x26; isDef(ch)) {\n    // 如果oldVnode有text值，则先将elm的textContent清空\n    if (idDef(oldVnode.text)) {\n      api.setTextContext(elm, \"\")\n    }\n    addVnodes(elm, null, ch, 0, ch.length - 1)\n  }\n  // 如果oldVnode有子节点，而vnode没有子节点，则删除oldVnode的子节点\n  else if (isUndef(ch) &#x26;&#x26; isDef(oldCh)) {\n    reoveVnodes(elm, oldCh, 0, oldCh.length - 1)\n  }\n  // 如果它们都有子节点，并且子节点不相同，则更新它们的子节点\n  else if (ch !== oldCh) {\n    updateChildren(elm, oldCh, ch)\n  }\n  // 否则就是它们都有子节点，且子节点相同，如果oldVnode有text值，则将elm的textContent清空\n  else if (ifDef(oldVnode.text)) {\n    api.setTextContext(elm, \"\")\n  }\n}\n</code></pre>\n<p><code>patchVnode</code>逻辑可以简化为下面：</p>\n<ol>\n<li>直接将 vnode 的 elm 设置为 oldVnode 的 elm，以达到复用已有的 dom 对象，避免了创建新的 dom 对象的开销</li>\n<li>比较 oldVnode === vnode，如果相等，则直接返回，不同更新，因为它们就是同一个对象</li>\n<li>如果 vnode 有 text 值，则说明 elm 就只包含了纯 text 文本，无其他类型子节点，如果它的值与 oldVnode 的 text 不相同，则更新 elm 的 textContent，并返回。</li>\n<li>这一步开始，真正比较它们的 children 了，<ul>\n<li>如果 vnode 有 children，oldVnode 没有 children，先清空 elm 的 textContext，再将 vnode 的 children 添加进来</li>\n<li>如果 vnode 没有 children，oldVnode 有 children，则直接删除 oldVnode 的 children</li>\n<li>如果它们都有 children，且不相同，则更新它们的 children</li>\n<li>如果它们都有 children，且相同，则清空 elm 的 textContext</li>\n</ul></li>\n</ol>\n<p>流程图如下，</p>\n<p><img src=\"./patchVnode.png\" alt=\"patchVnode\"></p>\n<p>在<code>patchVnode</code>更新时，vnode 会先是通过触发定义在 data 数据上的钩子函数来更新自己节点上的信息，比如 class 或者 styles 等，然后再去更新 children 节点信息。</p>\n\n          <h3 id='toc-3-4' >\n            updateChildren\n          </h3>\n        \n<p>更新 vnode.children 信息是通过<code>updateChildren</code>函数来完成的。只有当 oldVnode 上存在 children，且 vnode 上也存在 children 时，并且<code>oldVnode.children !== vnode.children</code>时，才会去调用<code>updateChildren</code>。下面来梳理一下<code>updateChildren</code>的大致逻辑，</p>\n<pre><code class=\"language-typescript\">function updateChildren(parentElm, oldCh, newCh) {\n  // 旧的children\n  let oldStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[oldStartIdx]\n  let oldEndVnode = oldCh(oldEndIdx)\n\n  // 新的children\n  let newStartIdx = 0\n  let newEndIdx = newCh.length - 1\n  let newStartVnode = newCh(newStartIdx)\n  let newEndVnode = newCh(newEndIdx)\n\n  let before = null\n\n  // 循环比较\n  while (oldStartIdx &#x3C;= oldEndIdx &#x26;&#x26; newStartIdx &#x3C;= newEndIdx) {\n    if (oldStartVnode == null) {\n      // 当前节点可能被移动了\n      oldStartVnode = oldCh[++oldStartIdx]\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx]\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode) // 更新newStartVnode\n      oldStartVnode = oldCh[++oldStartIdx] // oldStartIdx 向右移动\n      newStartVnode = newCh[++newStartIdx] // newStartIdx 向右移动\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode) // 更新newEndVnode\n      oldEndVnode = oldCh[--oldEndIdx] // oldEndIdx 向左移动\n      newEndVnode = newCh[--newEndIdx] // newEndIdx 向左移动\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      patchVnode(oldStartVnode, newEndVnode) //更新newEndVnode\n      let oldAfterVnode = api.nextSibling(oldEndVnode)\n      // 将oldStartVnode移动到当前oldEndVnode后面\n      api.insertBefore(parentElm, oldStartVnode.elm, oldAfterVnode)\n      oldStartVnode = oldCh[++oldStartIdx] // oldStartIdx 向右移动\n      newEndVnode = newCh[--newOldVnode] // newEndIdx 向左移动\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      patchVnode(oldEndVnode, newStartVnode) // 更新newStartVnode\n      // 将oldEndVnode移动到oldStartVnode前面\n      api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx] // oldEndVnode 向右移动\n      newStartVnode = newCh[++newStartIdx] // newStartVnode 向左移动\n    } else {\n      // 获取当前旧的children的节点的key与其index的对应值，\n      if (oldKeyIdx == undefined) {\n        oldKeyIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n      }\n      // 获取当前newStartVnode的key是否存在旧的children数组里\n      idxInOld = oldKeyIdx[newStartVnode.key]\n      if (isUndef(idxInOld)) {\n        // 如果当前newStartVnode的key不存在旧的children数组里，那么这个newStartVnode就是新的，需要新建dom\n        let newDom = createElm(newStartVnode)\n        api.insertBefore(parentElm, newDom, oldStartVnode.elm)\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        // 否则，当前newStartVnode的key存在旧的children里，说明它们之前是同一个Vnode,\n        elmToMove = oldCh[idxInOld]\n        if (elmToMove.sel !== newStartVnode.sel) {\n          // 节点类型变了，不是同一个类型的dom元素了,也是需要新建的\n          let newDom = createElm(newStartVnode)\n          api.insertBefore(parentElm, newDom, oldStartVnode.elm)\n        } else {\n          // 否则，它们是同一个Vnode且dom元素也相同，则不需要新建，只需要更新即可\n          patchVnode(elmToMove, newStartVnode)\n          oldCh[idxInOld] = undefined // 标志旧的children当前位置的元素被移走了，\n          api.insertBefore(parentElm, elmToMove, oldStartVnode.elm)\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n  }\n\n  // 如果循环之后，还有未处理的children，\n  if (oldStartIdx &#x3C;= oldEndIdx || newStartIdx &#x3C;= newEndIdx) {\n    // 如果新的children还有部分未处理，则把多的部分增加进去\n    if (oldStartIdx > oldEndIdx) {\n      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1]\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n    } else {\n      // 如果旧的children还有未处理，则把多的部分删除掉\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n}\n</code></pre>\n<p><code>updateChildren</code>函数逻辑可以简化为，</p>\n<ol>\n<li>初始化循环变量</li>\n<li>根据变量循环遍历 old children 与 new children，并逐个比较更新，当类型相同时，则调用<code>patchVnode</code>更新，当类型不同时，则直接新建 new vnode 的 dom 元素，并插入到合适的位置</li>\n<li>循环完了之后，增加新增的 new vnode 节点和移除旧的冗余的 old vnode</li>\n</ol>\n<p>流程图如下，</p>\n<p><img src=\"./updateChildren.png\" alt=\"updateChildren\"></p>\n<p>在<code>updateChildren</code>函数中，逐个更新 children 中节点时，当比较的两个节点类型相同时，又会反过来调用<code>patchVnode</code>来更新节点，这样，实际上存在了间接的递归调用。</p>\n\n          <h3 id='toc-3-5' >\n            life cycle hooks\n          </h3>\n        \n<p>在使用 React 或者 Vue 时，你会发现它们都分别定义了组件的生命周期方法，虽然名称或触发时机不完全相同，但是基本的顺序和目的是差不多的。Snabbdom 也提供了相应的生命周期钩子函数，不同的是它提供了 2 套，一套是针对 virtual dom 的，比如一个 Vnode 的<code>create</code>，<code>update</code>，<code>remove</code>等；一套是针对 modules 的，通过在不同时机触发不同 module 的钩子函数去完成当前 Vnode 的更新操作。</p>\n<p>modules 的上的钩子函数如下,</p>\n<pre><code class=\"language-typescript\">export interface Module {\n  pre: PreHook\n  create: CreateHook\n  update: UpdateHook\n  destroy: DestroyHook\n  remove: RemoveHook\n  post: PostHook\n}\n</code></pre>\n<p>它的触发时机图如下，</p>\n<p><img src=\"./module_hooks.png\" alt=\"modules_hook\"></p>\n<p>在触发 modules 的 hooks 函数时，不同的函数会接受不同的参数，下面为 modukes 中钩子函数接受参数情况，</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Triggered when</th>\n<th>Arguments to callback</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>pre</code></td>\n<td>在<code>patch</code>函数开始处</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>create</code></td>\n<td>在<code>createElm</code>函数中创建一个 element 时</td>\n<td><code>vnode</code></td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>在<code>pathVnode</code>函数中更新 Vnode 时，</td>\n<td><code>oldVnode</code>，<code>newVnode</code></td>\n</tr>\n<tr>\n<td><code>destroy</code></td>\n<td>在<code>removeVnodes</code>函数中移除 Vnode 时，</td>\n<td><code>vnode</code></td>\n</tr>\n<tr>\n<td><code>remove</code></td>\n<td>在<code>removeVnodes</code>函数中移除 Vnode 时，</td>\n<td><code>vnode</code>，<code>removeCallback</code></td>\n</tr>\n<tr>\n<td><code>post</code></td>\n<td>在<code>patch</code>函数最后处，</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<p>大部分 module 中都没有定义<code>pre</code>函数和<code>post</code>函数，主要是在<code>create</code>，<code>update</code>， <code>destory</code>，<code>remove</code>中对当前 Vnode 进行操作。比如，在 class module 中在<code>create</code>函数内对 Vnode 上的操作如下，</p>\n<pre><code class=\"language-typescript\">// class modules 中在create钩子函数中对当前Vnode操作\nfunction updateClass(oldVnode: VNode, vnode: VNode): void {\n  var cur: any,\n    name: string,\n    elm: Element = vnode.elm as Element,\n    oldClass = (oldVnode.data as VNodeData).class, // 旧的class\n    klass = (vnode.data as VNodeData).class // 新的class\n\n  if (!oldClass &#x26;&#x26; !klass) return // 都不存在class,直接返回\n  if (oldClass === klass) return // 相等，直接返回\n  oldClass = oldClass || {}\n  klass = klass || {}\n\n  // 删除那些存在oldVnode上而不存在vnode上的\n  for (name in oldClass) {\n    if (!klass[name]) {\n      elm.classList.remove(name)\n    }\n  }\n  // 遍历当前vnode上的class，\n  for (name in klass) {\n    cur = klass[name]\n    // 如果不想等\n    if (cur !== oldClass[name]) {\n      // 如果值为true，则添加class，否则移除class\n      ;(elm.classList as any)[cur ? \"add\" : \"remove\"](name)\n    }\n  }\n}\n</code></pre>\n<p>其他 module 的其他 hook 函数也都会对当前 vnode 更新，这里就不一一列举了。</p>\n<p>我们再来看看对 Vnode 上的钩子函数如下，</p>\n<pre><code class=\"language-typescript\">export interface Hooks {\n  init?: InitHook\n  create?: CreateHook\n  insert?: InsertHook\n  prepatch?: PrePatchHook\n  update?: UpdateHook\n  postpatch?: PostPatchHook\n  destroy?: DestroyHook\n  remove?: RemoveHook\n}\n</code></pre>\n<p>它的触发时机以及接受参数情况如下，</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Triggered when</th>\n<th>Arguments to callback</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>init</code></td>\n<td>在<code>createElm</code>时会先触发<code>init</code></td>\n<td><code>vnode</code></td>\n</tr>\n<tr>\n<td><code>create</code></td>\n<td>在<code>createElm</code>时，已经建好了 element，已经对应的 children 都创建完毕，之后在触发<code>create</code></td>\n<td><code>emptyVnode</code>，<code>vnode</code></td>\n</tr>\n<tr>\n<td><code>insert</code></td>\n<td>当<code>vnode.elm</code>已经更新到 dom 文档上了，最后在<code>patch</code>函数结尾处触发</td>\n<td><code>vnode</code></td>\n</tr>\n<tr>\n<td><code>prepatch</code></td>\n<td>在<code>patchVnode</code>开始处就触发了<code>prepatch</code></td>\n<td><code>oldVnode</code>，<code>vnode</code></td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>在<code>patchVnode</code>中，<code>vnode.elm=oldVnode.elm</code>之后，更新 children 之前触发</td>\n<td><code>oldVnode</code>，<code>vnode</code></td>\n</tr>\n<tr>\n<td><code>postpatch</code></td>\n<td>在<code>patchVnode</code>中结尾处，已经更新为 children 后触发，</td>\n<td><code>oldvnode</code>，<code>vnode</code></td>\n</tr>\n<tr>\n<td><code>destroy</code></td>\n<td>在<code>removeVnodes</code>中触发，此时还没有被移除</td>\n<td><code>vnode</code></td>\n</tr>\n<tr>\n<td><code>remove</code></td>\n<td>在<code>removeVnodes</code>中，<code>destroy</code>之后触发，此时还没有真正被移除，需调用<code>removeCallback</code>才真正将 element 移除</td>\n<td><code>vnode</code>，<code>removeCallback</code></td>\n</tr>\n</tbody>\n</table>\n<p>在<code>Vnode</code>上的钩子函数就是我们自己定义的了，定义在<code>data.hooks</code>中，例如，</p>\n<pre><code class=\"language-typescript\">h(\"div.row\", {\n  key: movie.rank,\n  hook: {\n    insert: vnode => {\n      movie.elmHeight = vnode.elm.offsetHeight\n    },\n  },\n})\n</code></pre>\n\n          <h3 id='toc-3-6' >\n            小结\n          </h3>\n        \n<p>在看了源码之后，其实最为复杂的地方就是<code>updateChildren</code>中更新子节点，这里为了避免重复创建 element，而做了很多的判断和比较，以达到最大化的复用之前已经创建好的 element。与 React 和 Vue 类似，它在比较中也添加了<code>key</code>来优化这一点。在更新 Vnode 对应的 element 时，它将不同数据分解到不同 module 中去更新，通过钩子函数来触发，这一点非常的优雅。</p>","tableOfContents":"<ul><li><a href=\"#toc-3-1\">init</a><ul></ul></li><li><a href=\"#toc-3-2\">patch</a><ul></ul></li><li><a href=\"#toc-3-3\">patchVnode</a><ul></ul></li><li><a href=\"#toc-3-4\">updateChildren</a><ul></ul></li><li><a href=\"#toc-3-5\">life cycle hooks</a><ul></ul></li><li><a href=\"#toc-3-6\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"理解virtual dom的实现细节-snabbdom","date":"December 31, 2018","tags":["h5","vue","vdom"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/understand_the_details_of_vritual_dom_snabbdom/","previous":{"fields":{"slug":"/post/resolve_issue_of_using_audio/"},"frontmatter":{"title":"HTML5中Audio使用踩坑汇总"}},"next":{"fields":{"slug":"/post/understand_the_details_of_h5_and_native(ios)_communication/"},"frontmatter":{"title":"理解h5与native(ios)通信细节"}}}}