{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"e7027570-411e-5bb6-b32d-086e77d38c08","excerpt":"背景最近老板来了一个新需求，地理位置组团。其中一个功能点，就是用户可以进入地图页面，查看当前自身位置，且扫描圈内和圈外其他玩家，将玩家头像显示在地图页面上，标明玩家在哪个位置。老板说，在地图上要可以同时显示 200 个玩家头像，且保证页面流畅；Android…","html":"\n          <h2 id='toc-2-1' >\n            背景\n          </h2>\n        \n<p>最近老板来了一个新需求，地理位置组团。其中一个功能点，就是用户可以进入地图页面，查看当前自身位置，且扫描圈内和圈外其他玩家，将玩家头像显示在地图页面上，标明玩家在哪个位置。老板说，在地图上要可以同时显示 200 个玩家头像，且保证页面流畅；Android6 的手机上，在拖拽，缩小放大时，不能出现明显的卡顿，必须保证用户体验。在拖拽，缩小或者放大等改变地图可视范围时，或则停留时间超过 60s，需要更新当前地图上的用户头像。</p>\n\n          <h2 id='toc-2-2' >\n            思路\n          </h2>\n        \n<p>需求其实不复杂，但是要做到老板的要求，就没那么简单了。android 6 的机型，这个应该是几年前的千元机了。这种机型的硬件本来就很差，不用想，在地图上一次性绘制 200 个头像，肯定会很卡。并且拖拽地图之后，又清空之前已经绘制的 200 个头像，重新绘制新的 200 个，这个肯定会使页面出现明显的卡顿。要达到老板的要求，必须仔细的思考一下该怎么做了。</p>\n\n          <h3 id='toc-3-1' >\n            分批绘制\n          </h3>\n        \n<p><a href=\"http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/\">浏览器对同一个域名的并发请求数量是有上限的</a>，一般不会超过 8 个，就算一次发送 200 个图片请求，也是分批返回的。结合这一点，我也可以分批绘制，200 个头像，我可以分成 40 次绘制，每次只绘制 5 个，上一次的 5 个绘制完成了，才开始绘制下一批的 5 个。带着这种想法，就去找 PM 商量，跟他说明浏览器请求限制和性能上的考虑，能不能不要一次性全部显示，可以慢慢显示出来。PM 接受了这种方式，但是要优先显示圈内的头像。</p>\n<p>为了达到可以分批绘制，且圈内的要优先绘制，容易就想到了，<a href=\"https://en.wikipedia.org/wiki/Priority_queue\"><strong>优先级队列</strong></a>，优先级高的先出队列。这里，圈内头像就比圈外的优先级高。每一次从队列里取出 5 个头像来绘制，直到队列为空。如果同步的循环调用每一批绘制，直到队列为空，那么肯定会使得当前帧执行时间超过 16ms，且会超过很长时间，浏览器一直会被阻塞，使得其他用户事件都不得到响应，表现出来就是页面卡死了，这样肯定不行的。利用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">javascript 的 event loop</a>，可以将每次绘制 5 个头像，这样一个功能包装在一个任务里，将 200 个头像就可以分成 40 个这样的任务，然后将每个任务分别加入到 javascript 的执行队列里。这样，可以异步的方式，将头像分批绘制出来，页面也不会出现卡死。</p>\n<p><img src=\"./per_draw.jpg\" alt=\"per_draw\"></p>\n<pre><code class=\"language-typescript\">// 伪代码，\n// 将一次绘制5个头像包装成一个任务，放到event loop 里\nconst PER_COUNT = 5\nfunction paintMarker(type) {\n  // 优先获取圈内数据\n  const userData = getUserData(type)\n\n  if (!userData.length) {\n    if (type === \"nearbyMarker\") {\n      // 圈内绘制完了，继续绘制圈外的\n      this.engine.pushDraw(() => {\n        this.paintMarker(\"externalMarker\")\n      })\n    }\n    return\n  }\n\n  // 一次绘制5个\n  let start = 0\n  let notAvailable = false\n  while (start &#x3C; PER_COUNT &#x26;&#x26; start &#x3C; userData.length) {\n    const user = userData[start]\n    // 从实例池取出一个\n    const marker = this.pools.take()\n    if (!marker) {\n      notAvailable = true\n      break\n    }\n    // 开始绘制头像\n    marker.draw(user)\n    start = start + 1\n  }\n\n  // 将下一次绘制任务加入到event loop里\n  if (!notAvailable) {\n    this.engine.pushDraw(() => {\n      this.paintMarker()\n    })\n  }\n}\n</code></pre>\n\n          <h3 id='toc-3-2' >\n            重复利用\n          </h3>\n        \n<p>对于地图页面，绘制的上限是 200 个头像。每次改变了地图的范围，比如移动，缩小，放大地图等操作，需要重新请求接口数据，获得当前新的地图可视范围内的玩家头像数据，然后将新的玩家头像绘制出来。由于 google map 在绘制自定义图形时，需要生成一个 google map 的 OverlayView 对象，实现它的 onAdd 和 onDraw 方法。如果，我们每次绘制新的头像都新建一个 OverlayView 对象，势必会增加浏览器的内存使用，且新建 OverlayView 对象也是需要花费一定时间的。为了高效绘制，且花费尽量少的内存，可以事先创建一个容量为 200 的 OverlayView 对象池，在每次改变地图范围操作之后，可以先回收那些不在可视范围内的 OverlayView 对象，放入池中；然后在绘制新的头像时，直接从池中取一个 OverlayView 对象使用就可以了，这样，即减少了内存的使用，也减去了每次新建 OverlayView 对象花费的时间。当池中没有可用 OverlayView 对象时，说明当前页面已经绘制了 200 个头像，达到了上限，不需要在绘制其他头像了。</p>\n<p><img src=\"./detail_draw.jpg\" alt=\"detail_draw\"></p>\n<pre><code class=\"language-typescript\">// 伪代码\n// 初始化pools\nconst MAX_COUNT = 200\nfunction init() {\n  // 初始marker实例池\n  this.pools = new MarkerPool(MAX_COUNT)\n\n  // 监听idle事件\n  google.maps.event.addListener(this.map, \"idle\", () => {\n    this.isIdle = true\n    // 回收可视区域外的marker\n    this.reclaimMarker()\n    // 设置定时刷新数据\n    this.initRefreshTimer()\n    // 请求用户数据\n    this.fetchUserData(\"nearbyMarker\", { users: [] }, true)\n  })\n}\n</code></pre>\n\n          <h3 id='toc-3-3' >\n            idle 时机执行\n          </h3>\n        \n<p>为了保证在操作地图的时候有最好的流畅度，比图拖拽，缩小，放大等，我们不做任何事情，即不绘制头像，也不请求数据，就仅仅让 google map 自己改变地图。当 google map 状态是 idle 时，我们再去做绘制头像或者更新数据等。google map 提供了 idle 事件，我们只需要监听这个事件就可以了。</p>\n<p><img src=\"./idle.jpg\" alt=\"idle\"></p>\n<p>更新数据，就是把接口请求来的数据，先做一些清洗工作，然后把合格的数据更新到待绘制头像队列里；可以把它的优先级降到最低，只有当前绘制头像队列为空时，才去执行更新数据任务。它的执行时间基本是固定可预估的，不会特别延误到当前帧的绘制，可以把它放在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\">requestIdleCallback</a>队列里去，通过增加一个超时执行时间内，只有当浏览器是 idle 时或者超过了某一个时间，才会去执行。</p>\n<p><img src=\"./detail_update.jpg\" alt=\"detail_update\"></p>\n<pre><code class=\"language-typescript\">// 伪代码\n// 将更新数据操作放入到requestIdleCallback\nfunction fetchUserData(type, userData, fromStart = true) {\n  // 加入到待绘制数组中\n  if (data.users.length) {\n    this.patchUserData(data.users, type)\n  }\n  const nextType\n  // ... //\n  this.fetchUserDataApi(\n    this.myLocation,\n    this.mapBounds,\n    fromStart,\n    nextType\n  ).then(data => {\n    this.engine.pushRequest(() => {\n      this.fetchUserData(nextType, data)\n    })\n  })\n}\n</code></pre>\n\n          <h2 id='toc-2-3' >\n            优化\n          </h2>\n        \n<p>浏览器的理想帧率是 60fps，如果一直稳定在 60fps 左右，那么将是非常流畅的。对于 Android 6 这样的机型，肯定是达不到 60fps 的，只能尽可能提高它的帧率，让它能稳定在 30fps 左右，基本上就可以达到要求了。对于一些细节的优化，特别是要避免 layout reflow 的情况，同样严重影响页面流畅度。下面的 performance 分析，我都是将 CPU 降低 6 倍，且绘制了 200 个头像，拖动地图页面得到的。</p>\n\n          <h3 id='toc-3-4' >\n            避免设置 zIndex\n          </h3>\n        \n<p>刚开始，给每个 OverlayView 都设置了<code>zIndex = '50'</code>，当前用户的 OverlayView 设置了<code>zIndex = '80'</code>，这样当前用户总是显示在最上层。这样更改头像样式能达到设计稿的视觉效果，但是这将造成页面非常卡顿，具体我们通过 chrome performance 调试得到结果。</p>\n<p><img src=\"./1.1.png\" alt=\"image-20190414171827226\"></p>\n<p>页面的帧率平均是 8fps，也就是绘制一帧需要花费平均 122ms 左右。先不看其他影响帧率的地方，就看看 Composite Layers 步骤，它就花费了 17.56ms。理想 60fps 的情况下，一帧的绘制总共才花费 16.67ms 左右。显然，我们的 Composite Layers 步骤严重影响性能。Composite Layers 是浏览器一帧绘制工作中的最后一个步骤，合成层。每当设置新的 zIndex 值，都将会创建新的 layer，同一个 zIndex 的值的元素，最后会被绘制在同一个 layer 中，具体可以查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/Adding_z-index\">使用 zIndex</a>。去掉 zIndex，我们再来看看结果。</p>\n<p><img src=\"./1.2.png\" alt=\"image-20190414180429504\"></p>\n<p>去掉了 zIndex 之后，现在页面的帧率平均是 10fps，绘制一帧需要花费的平均时间是 100ms 了。在 Composite Layers 阶段花费的时间基本是 9ms 左右了。显然是有所提升的。</p>\n\n          <h3 id='toc-3-5' >\n            避免在 onDraw 里访问 offsetWidth 等触发 reflow\n          </h3>\n        \n<p>由于在拖拽地图时，google map 会不停的调用我们实现的 onDraw 方法。在 onDraw 方法里，可以随意设置当前 OverlayView 对象的样式和位置。未优化之前，是根据当前容器 div 的宽高和当前经纬度换算出来的坐标计算得到当前 OverlayView 对象的 left 和 top。</p>\n<pre><code class=\"language-typescript\">// 部分代码如下\n/* 继承 google.maps.OverlayView，实现draw */\nfunction draw() {\n  const overlayProjection = this.overlayView.getProjection()\n  const posPixel = overlayProjection.fromLatLngToDivPixel(this.latLng)\n  const scale = this.computeScale()\n\n  // Resize the image's div to fit the indicated dimensions.\n  const div = this.el\n  let x = posPixel.x - div.offsetWidth / 2\n  let y = posPixel.y - (div.offsetHeight * (scale + 1)) / 2\n  div.style.transform = `scale(${scale})`\n  div.style.left = x + \"px\"\n  div.style.top = y + \"px\"\n}\n</code></pre>\n<p><img src=\"./2.2.png\" alt=\"image-20190414183610229\"></p>\n<p>draw 方法中，访问<code>div.offsetWidth</code>和 <code>div.offsetHeight</code>，强制触发 reflow，这将非常影响性能。我们可以优化成，头像显示成固定宽高。例如，<code>let x = posPixel.x - 32 / 2;</code>和<code>let y = posPixel.y - 32 * (scale + 1) / 2;</code>。</p>\n<p><img src=\"./2.3.png\" alt=\"image-20190414184005195\"></p>\n<p>可以看到，在 draw 方法里，现在就没有 Layout 和 Recalculate Style 的操作了。现在帧率平均基本是 12fps 了，绘制一帧需要花费的平均时间是 84ms 了。又有所提高了。</p>\n\n          <h3 id='toc-3-6' >\n            必要降级，去掉不必要的元素\n          </h3>\n        \n<p>对于 Android 6 等机型，完全没有必要还为每个头像都绘制出一个底部三角形。底部三角形，会额外创建一个 div 元素，如果是 200 个头像，页面就会多出了 200 个元素。并且在拖拽等操作，频繁的调用 onDraw，会重新绘制每个头像，也会重新绘制每个底部三角形，这样也增加了绘制所需要的时间。对于 android 6 以下等低端机型，可以去掉底部三角形。</p>\n<p><img src=\"./2.4.png\" alt=\"image-20190414190054000\"></p>\n<p>现在页面的帧率平均可以达到了 15fps，绘制一帧需要花费的平均时间是 68ms 了。</p>\n<p>在优化这些小细节之后，在 CPU 降低到 6 倍慢，且页面绘制 200 个头像时，帧率从之前的 8fps 提高了 15fps，足足提升了一倍的性能。对于 Android 6 等极端机型，其实还可以再降级，从 200 个头像减少到 100 个。</p>\n<p><img src=\"./2.5.png\" alt=\"image-20190414192024307\"></p>\n<p>头像降到 100 个之后，可以看到现在页面的帧率平均可以达到了 27fps，绘制一帧需要花费的平均时间是 36ms 了。帧率从之前的 8fps 提高了 27fps，足足提升了三倍多的性能。</p>\n\n          <h2 id='toc-2-4' >\n            小结\n          </h2>\n        \n<p>前端也可以使用一些基础的数据结构和算法，结合前端的一些知识，可以有比较好的实践。在开始动手编码之前，可以先思考一下，大致的实现思路，是否可以有更优方案。当在低端机型上无法满足性能要求时，要学会与 PM 沟通，是否可以降级处理。在遇到性能瓶颈时，学会使用工具分析和定位问题。</p>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">背景</a><ul><li><a href=\"#toc-3-1\">分批绘制</a></li><li><a href=\"#toc-3-2\">重复利用</a></li><li><a href=\"#toc-3-3\">idle 时机执行</a></li><li><a href=\"#toc-3-4\">避免设置 zIndex</a></li><li><a href=\"#toc-3-5\">避免在 onDraw 里访问 offsetWidth 等触发 reflow</a></li><li><a href=\"#toc-3-6\">必要降级，去掉不必要的元素</a></li></ul></li><li><a href=\"#toc-2-2\">思路</a><ul></ul></li><li><a href=\"#toc-2-3\">优化</a><ul></ul></li><li><a href=\"#toc-2-4\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"性能优化篇-地图页面","date":"April 13, 2019","tags":["performance","javascript"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019/optimize_map_page/","previous":{"fields":{"slug":"/post/2019/summary_of_2018/"},"frontmatter":{"title":"2018年小结"}},"next":{"fields":{"slug":"/post/2019/alorithm_outline_of_knowledge/"},"frontmatter":{"title":"数据结构和算法-前端必会知识点"}}}}