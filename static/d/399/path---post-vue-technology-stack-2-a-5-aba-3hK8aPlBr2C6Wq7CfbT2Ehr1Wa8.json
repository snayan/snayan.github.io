{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"a7c66256-7f1f-546b-b6c6-6d5ff325626f","excerpt":"目的这个项目主要是用 vue+vuex 实现一个单页面应用，纯粹是熟悉 vue 全家桶相关开发模式，用于练手非常合适。\n着手开发完了之后可以学的东西：熟悉 vue 单文件组件开发方式熟悉如何写一个 vue 插件熟悉如何使用 vue-router 以及挂载路由钩子函数熟悉 vuex…","html":"\n          <h2 id='toc-2-1' >\n            目的\n          </h2>\n        \n<p>这个项目主要是用 vue+vuex 实现一个单页面应用，纯粹是熟悉 vue 全家桶相关开发模式，用于练手非常合适。\n着手开发完了之后可以学的东西：</p>\n<ol>\n<li>熟悉 vue 单文件组件开发方式</li>\n<li>熟悉如何写一个 vue 插件</li>\n<li>熟悉如何使用 vue-router 以及挂载路由钩子函数</li>\n<li>熟悉 vuex 是如何运作的，模块化维护应用状态数据</li>\n<li>体验 typescript 的开发方式\n如果想学 vue 的不妨进来看看。\n项目源码地址：<a href=\"https://github.com/snayan/vue-task\">点击这里</a></li>\n</ol>\n\n          <h2 id='toc-2-2' >\n            技术栈\n          </h2>\n        \n<ul>\n<li>vue</li>\n<li>vuex</li>\n<li>vue-router</li>\n<li>typescript</li>\n</ul>\n<!--more-->\n\n          <h2 id='toc-2-3' >\n            开始\n          </h2>\n        \n<p>开始之前，还是有必要去 vue 官网学习一下 vue，至少得有个大致的了解，后面在用到 vue-router 和 vuex 时，再去对应的仓库看文档就可以了。</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/\">vue 官网地址</a></li>\n<li><a href=\"https://router.vuejs.org/\">vue-router 地址</a></li>\n<li><a href=\"https://vuex.vuejs.org/\">vuex 地址</a>\n创建项目可以用 vue-cli，具体看<a href=\"https://github.com/vuejs/vue-cli/blob/dev/docs/README.md\">这里</a></li>\n</ul>\n\n          <h2 id='toc-2-4' >\n            结构\n          </h2>\n        \n<p>项目结构一般来说非常重要，定义好的目录结构，非常利于后续的项目维护，以及别人阅读理解。下面就是这个项目的结构，应该看一下就知道是干什么的，大致说一下。\n项目结构分为静态资源目录，api 接口请求目录，组件目录，插件目录，路由配置目录，公共样式目录，状态维护目录，工具类目录，页面视图目录。\n<img src=\"./vue-structure.png\"></p>\n\n          <h2 id='toc-2-5' >\n            单页面组件\n          </h2>\n        \n<p>vue 开发一般都是单页面组件的方式，即一个以 vue 为后缀的文件就是一个组件，组件里包含了 template 模版，script 脚本，style 样式，组件内的逻辑可以完全封装在里面，对外可以提供接受的 Props 数据，可以对外发射一个事件 emit，或者将外部组件组合到自己内部的 slot 里面。</p>\n<pre><code class=\"language-vue\">&#x3C;template>\n  &#x3C;div class=\"topNav\">\n    &#x3C;ul class=\"list\">\n      &#x3C;li class=\"item left\">\n        &#x3C;app-icon :link=\"left\" @click.native.stop=\"clickLeft\" />\n      &#x3C;/li>\n    &#x3C;/ul>\n  &#x3C;/div>\n&#x3C;/template>\n\n&#x3C;script lang=\"ts\">\nimport { Component, Prop, Emit, Vue } from \"vue-property-decorator\"\nimport AppIcon from \"./AppIcon.vue\"\nimport { PREFIX } from \"@/store/modules/user/CONSTANTS\"\n\n@Component({\n  components: {\n    AppIcon,\n  },\n})\nexport default class TopNav extends Vue {\n  @Prop({ required: true })\n  private left!: string\n  private get avatar() {\n    return this.$store.state[PREFIX].avatar\n  }\n  private clickLeft() {\n    this.$emit(\"left\")\n  }\n}\n&#x3C;/script>\n\n&#x3C;style lang=\"scss\" scoped>\n@import \"../scss/theme.scss\";\n.topNav {\n  background: $topBarBgColor;\n  position: fixed;\n}\n&#x3C;/style>\n</code></pre>\n\n          <h2 id='toc-2-6' >\n            配置路由\n          </h2>\n        \n<p>由于在客户端渲染的单页面应用，需要在客户端配置路由，实现页面间的切换。开发 vue 时官方推荐使用 vue-router，在配置这个项目时，由于考虑登录态的维护，所以对路由配置加了 meta 数据，并增加了路由跳转钩子函数，进行鉴权控制受登录态的页面。</p>\n<pre><code class=\"language-typescript\">import Vue from \"vue\"\nimport Router from \"vue-router\"\nimport Sign from \"@/views/Sign.vue\"\nimport Me from \"@/views/Me.vue\"\nimport { hasLogin } from \"@/util/session\"\n\nVue.use(Router)\n\nconst router = new Router({\n  mode: \"history\",\n  routes: [\n    {\n      path: \"/\",\n      name: \"sign\",\n      component: Sign,\n    },\n    {\n      path: \"/me\",\n      name: \"me\",\n      component: Me,\n      meta: { requiredAuth: true },\n    },\n  ],\n})\n\nrouter.beforeEach((to, from, next) => {\n  if (to.matched.some(record => record.meta.requiredAuth)) {\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    if (!hasLogin()) {\n      next({\n        path: \"/\",\n        query: { redirect: to.fullPath },\n      })\n    } else {\n      next()\n    }\n  } else {\n    next() // 确保一定要调用 next()\n  }\n})\n\nexport default router\n</code></pre>\n\n          <h2 id='toc-2-7' >\n            vue 插件编写\n          </h2>\n        \n<p>对于那种需要全组件共享，或者全局注入的方法等可以使用 vue 插件。其实，vue-router 和 vuex 实际就是 vue 的插件，在入口处，调<code>Vue.use(Router);</code> 就可以了，比如 <code>Vue.use(Router);</code>\n一个插件，可以是一个函数，或者一个包含<code>install</code>方法的对象，在调用<code>Vue.use</code>时，会调用<code>install</code>方法。\n在插件里，我们可以</p>\n<ol>\n<li>添加全局方法或者属性，</li>\n<li>添加全局资源</li>\n<li>通过全局 mixin 方法添加一些组件选项</li>\n<li>添加 Vue 实例方法</li>\n</ol>\n<pre><code class=\"language-typescript\">import Vue, { VueConstructor, PluginObject } from \"vue\"\nimport Loading from \"./Loading.vue\"\n\ntype ShowFunc = () => () => void\n\nconst plugin: PluginObject&#x3C;{}> = {\n  install(Vue: VueConstructor, options = {}) {\n    const CONSTRUCTOR = Vue.extend(Loading)\n    let cache: Vue &#x26; { show: ShowFunc } | null = null\n\n    function loading(): () => void {\n      const loadingComponent = cache || (cache = new CONSTRUCTOR())\n      if (!loadingComponent.$el) {\n        const vm = loadingComponent.$mount()\n        ;(document.querySelector(\"body\") as HTMLElement).appendChild(vm.$el)\n      }\n      return loadingComponent.show()\n    }\n    Vue.prototype.$loading = loading\n  },\n}\n\nexport default plugin\n</code></pre>\n\n          <h2 id='toc-2-8' >\n            状态管理\n          </h2>\n        \n<p>单页面应用的状态管理使用 vuex，上面提到了，它就是一个 vue 的插件，会在组件实例上注入$store 对象，这个对象就是<code>new Vuex.Store()</code>,相比 redux ，我觉得 vuex 简单很多。使用需要注意一下几点就可以了，</p>\n<ol>\n<li>改变 state，始终是通过 commit 一个 mutation 方式进行，mutation 函数里必须是同步改变 state，不能异步改变 state。对应 redux 中，就是 reducer 函数的功能了。</li>\n<li>对于异步改变 state，可以通过 dispatch 一个 action，action 里面异步获取数据之后在 commit 一个对应的 mutation。这个在 redux 里，是通过中间件处理异步 action 的。</li>\n<li>对于 state 的过滤筛选，可以定义 getter，getter 是缓存依赖的。</li>\n<li>对于大型复杂的 state，可以采用模块化的方式管理各个模块的 state，这个跟 redux 的思想是一样的。\n本次项目也是用模块化的管理状态的方式，把整个应用的状态以业务划分为子状态，最后在 modules 中合并</li>\n</ol>\n<pre><code class=\"language-typescript\">  modules: {\n    user,\n    list,\n    filter,\n  },\n</code></pre>\n<p>对于单个模块的 state，按照上面的注意点即可以。</p>\n<pre><code class=\"language-typescript\">// user模块的state\nimport { ActionTree, MutationTree, ActionContext } from \"vuex\"\nimport { login, loginOut, LoginInfo } from \"@/api/login\"\nimport { getUserInfo, getUserActions } from \"@/api/user\"\nimport { User } from \"./user\"\nimport { RootState } from \"../../rootstate\"\n\nconst namespaced = true\n\n/* initial state */\nconst state = () => ({\n  id: null,\n  username: null,\n  email: null,\n  avatar: null,\n  likes_count: null,\n  goings_count: null,\n  past_count: null,\n})\n\n/* user actions */\nconst actions: ActionTree&#x3C;User, RootState> = {\n  login({ commit, state }: ActionContext&#x3C;User, RootState>, payload: LoginInfo) {\n    return login(payload).then(\n      ({ token, user }: { token: string; user: User }) => {\n        commit(\"saveToken\", token, { root: true })\n        commit(\"saveUser\", user)\n      }\n    )\n  },\n  getUserInfo({ commit, state }: ActionContext&#x3C;User, RootState>) {\n    return getUserInfo().then((user: User) => {\n      commit(\"saveUser\", user)\n    })\n  },\n}\n\n/* user mutations */\nconst mutations: MutationTree&#x3C;User> = {\n  saveUser(state, user) {\n    state.id = user.id\n    state.username = user.username\n    state.email = user.email\n    state.avatar = user.avatar\n    state.likes_count = user.likes_count\n    state.goings_count = user.goings_count\n    state.past_count = user.past_count\n  },\n}\n\nexport default {\n  state,\n  actions,\n  mutations,\n  namespaced,\n}\n</code></pre>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">目的</a><ul></ul></li><li><a href=\"#toc-2-2\">技术栈</a><ul></ul></li><li><a href=\"#toc-2-3\">开始</a><ul></ul></li><li><a href=\"#toc-2-4\">结构</a><ul></ul></li><li><a href=\"#toc-2-5\">单页面组件</a><ul></ul></li><li><a href=\"#toc-2-6\">配置路由</a><ul></ul></li><li><a href=\"#toc-2-7\">vue 插件编写</a><ul></ul></li><li><a href=\"#toc-2-8\">状态管理</a><ul></ul></li></ul>","frontmatter":{"title":"vue 全家桶初探","date":"June 15, 2018","tags":["vue"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/vue_technology_stack/","previous":{"fields":{"slug":"/post/learn_react16_part4/"},"frontmatter":{"title":"react 16学习(四)"}},"next":{"fields":{"slug":"/post/process_of_webpack_build_project/"},"frontmatter":{"title":"webpack构建常见流程"}}}}