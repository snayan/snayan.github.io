{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","ableZan":true,"menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"4594c5e9-497a-59d8-b519-cd01b32d9081","excerpt":"最近给组内同事做了一次技术分享，有关 React fiber 的。内容涉及了 Stack reconciler，Fiber reconciler，以及它们之间的区别。事后整理了下文字稿，篇幅有点长，内容如下。react 中，一个 virtual dom 是使用 element 来表示的。element 结构如下，Jsx…","html":"<p>最近给组内同事做了一次技术分享，有关 React fiber 的。内容涉及了 Stack reconciler，Fiber reconciler，以及它们之间的区别。事后整理了下文字稿，篇幅有点长，内容如下。</p>\n\n        <h2 id='toc-2-1' >\n          Jsx && element\n        </h2>\n      \n<p>react 中，一个 virtual dom 是使用 element 来表示的。element 结构如下，</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> ReactElement <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  $$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span>\n  <span class=\"token keyword\">type</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span>\n  key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span>\n  ref<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span>\n  props<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span>\n  _owner<span class=\"token punctuation\">:</span> ReactInstance\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Jsx 语法会被 Babel 编译为 <code class=\"language-text\">React.createElement</code> 形式，最后返回的都是 element 对象。</p>\n\n        <h2 id='toc-2-2' >\n          Stack reconciler\n        </h2>\n      \n\n        <h3 id='toc-3-1' >\n          InternalComponent Tree\n        </h3>\n      \n<p>在 v16 之前，react 采用 Stack reconciler 策略来更新 virtual dom 的状态。它会给每一个 element 对象都生成一个 InternalComponent（react 内部对象，不会暴露出去），这样 Element tree 会组织成 InternalComponent tree。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">[</span>object CompositeComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  currentElement<span class=\"token punctuation\">:</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  publicInstance<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span> object App<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  renderedComponent<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object CompositeComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    currentElement<span class=\"token punctuation\">:</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Main</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n    publicInstance<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    renderedComponent<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object DOMComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n      currentElement<span class=\"token punctuation\">:</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n      node<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object HTMLDivElement<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      renderedChildren<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'.0'</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object DOMComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n          currentElement<span class=\"token punctuation\">:</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n          node<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span> object HTMLButtonElement<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n          renderedChildren<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'.1'</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>object DOMComponent<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n          currentElement<span class=\"token punctuation\">:</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n          node<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span> object HTMLSpanElement<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n          renderedChildren<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>每一个 InternalComponent 通过 <code class=\"language-text\">renderedComponent</code> 或者<code class=\"language-text\">renderChildren</code>来关联当前组件<code class=\"language-text\">render</code>出来的 element。通过这样的引用关系，它们就在 react 内部形成了一棵树。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b46108b768ac8532fca6d73df7b74693/24b80/stack-v-dom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 371px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 108.08625336927224%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsSAAALEgHS3X78AAACs0lEQVQ4y5VU2XLaQBDk//8lD6nKS16Schyb4CMcNmBxuGxzI4RupD07swsS4AqJ2aqunZVGrZnpma1w9zuUXwVzf4CtLsm+glhfQfEQGgDn3IIxZrG1OQTPoZhH8KGVgFlaa1Tk+ieQNTDqfsEbAelv6OAGWkQQQmE4GKDdbuPh4QGO41i703WwmA5hvuXrX/TzeE8o/DuoqAXu15F792Q3IcMmlEisk1LKOhZLa1VYBBOZtPbWhQi3DppSYYiiaOu6IymIhBA2VbMbSHOm6MNUItpISKX3ERY/Nx+UhFof7bPZ7CDlDvo9B+46QmfC4UxzpLncExapCCGRJOnuBY4Ii9QNpJQ7WyNjEjlBHQRQUZIbd0Shj9l0bNM3z95H+b9V+JEot1YIvr4nUe6grSgNUi4pHT+Cg7a5BOI79Buf8PL4GUiINKjZPjwnwmJRhDXouAHm3SJbUf9FdaiwftRbZxEqkVOb0ATkCdXRo3Jyaov87BqWhIU75wJRnJQqWx5TH5y39m1DjZ3E0cEU6A8LciTKKmIIUoXxIkT/ZY5wo7COKG11XmRl27ReM/QXCvVhiMZziN5coTth8MIULM+RZRny3X4KptnLCJuGcAnUOkvcOitrd4jQXcfYbFKkaQrP82iKEmu/h3keBMGecOTmmK4Z5oG0mHjMnrncyxHSjP9LbUO4reWBKIUQh+eCxERh5vdvk2NWHMflBVApmI8dt2dBtTH2aDSmS4CVF0RxWUiCub3H4wnVUVlUTrXAipTuzRheXInGwMNgnhPoYyoJTQJGK4bBgqM/y9F69vG85BjSuXJK/kXArUCNoY+vV23c91YYuMCryyk6SbvAcAX7/NtNj7qDzkt9mnDkZrh+ilB98nHRWqDa9VF16FJ9S2x9H18T/HJiXHc8XDQXqPUiiz/YWquL4XskegAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/b46108b768ac8532fca6d73df7b74693/cc182/stack-v-dom.webp 148w,\n/static/b46108b768ac8532fca6d73df7b74693/f7e40/stack-v-dom.webp 295w,\n/static/b46108b768ac8532fca6d73df7b74693/23066/stack-v-dom.webp 371w\"\n          sizes=\"(max-width: 371px) 100vw, 371px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/b46108b768ac8532fca6d73df7b74693/cf440/stack-v-dom.png 148w,\n/static/b46108b768ac8532fca6d73df7b74693/d2d38/stack-v-dom.png 295w,\n/static/b46108b768ac8532fca6d73df7b74693/24b80/stack-v-dom.png 371w\"\n          sizes=\"(max-width: 371px) 100vw, 371px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/b46108b768ac8532fca6d73df7b74693/24b80/stack-v-dom.png\"\n          alt=\"stack v-dom\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p><strong>需要注意的是，如果 children 是一个数组，那么<code class=\"language-text\">renderChildren</code>就会有多个子节点</strong>。可以仔细再观察一下，其实叶子节点都是 HostComponent，因为视图最后是通过 HostComponent 渲染的。我们再来完整看一下 Element tree 与 InternalComponent tree 的联系，</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d29c08627e3602781f3dae1ee3e6e209/05c6f/stack-v-dom-full-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 80.30942334739804%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACQUlEQVQ4y31U246bMBDl/3+pUp/bSKvtqlLVfdhLFCAxAWODr2D7dAxJdpPurtFoMNgzc84Zu7DGQmuNcRyRUsI6ElKcyYeTfxspP6d1Qgjs9zUYa9B3ByT1B0VbdmjYkT4yaKOgtMFkBkSxgSy/I/Y/4LyCCwkVr/Dr9Q4xxUsCpTSGYaB9DkxGFD3vYYymHwqT8ogmIU7kbQkrnhcf44Rck/Yax7G5VJh9RtZ1LYx16KRFcUkVcjoyf4YGWJ/eYU3X0E9z7/0CPcaAjjcoJJcQTOBIsOcTX5m36BhU/4LkqaIY1s2zg7TiqkLOOZqmgRwl2LhHcdy2OO5bHNhhFUdqgi4R+E90228IC4cj3BxRixq/qwcKFC8Bs8UYL0kKY0mEaYJ3EwUhVRWWDSloeCNApK5zWh+oUh/8wke6oeCcoPAkgCcx3OgI2tuiiVAOoyEa8OU4V3m2gr00aOsWvOcLZGsMtJ3wWHvcP4nFK+MIgYMjyyJky+/nIHjXm4XoBLRaG9s5jznDp/IaOaPm1FtixhwCHFGT/0V6z4paarW1F67hF7lJF4ufY8vwuTQYzbxQMFGTcxJP2ZwsXUEvvuLjbNt2xuZvi7unAcchoCTxNo8cD68aXIXrgLebbwNnWNpFNJxOibDUPuuc0byVxOf8xuF/Fd7Id7oI8iTS0VLEm1q/p0DHdfyQx+Krdlj6jR5F1XDGl1NhLN1OvVnm+VLIan/K4UcB8ziUDOVzhd1uByklmqrB7rlEVVdLd7wP+A89jeCr6I2A9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/d29c08627e3602781f3dae1ee3e6e209/cc182/stack-v-dom-full-2.webp 148w,\n/static/d29c08627e3602781f3dae1ee3e6e209/f7e40/stack-v-dom-full-2.webp 295w,\n/static/d29c08627e3602781f3dae1ee3e6e209/1a2f4/stack-v-dom-full-2.webp 590w,\n/static/d29c08627e3602781f3dae1ee3e6e209/6252a/stack-v-dom-full-2.webp 711w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/d29c08627e3602781f3dae1ee3e6e209/cf440/stack-v-dom-full-2.png 148w,\n/static/d29c08627e3602781f3dae1ee3e6e209/d2d38/stack-v-dom-full-2.png 295w,\n/static/d29c08627e3602781f3dae1ee3e6e209/b9e4f/stack-v-dom-full-2.png 590w,\n/static/d29c08627e3602781f3dae1ee3e6e209/05c6f/stack-v-dom-full-2.png 711w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/d29c08627e3602781f3dae1ee3e6e209/b9e4f/stack-v-dom-full-2.png\"\n          alt=\"full stack v-dom\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n\n        <h3 id='toc-3-2' >\n          Recursion Update\n        </h3>\n      \n<p>在 Stack Reconciler 策略中，react 采用 <strong>递归</strong>的方式来生成或者更新 InternalComponent tree。下面我们以更新场景，通过伪代码简单看下它的实现。每一个 InternalComponent 实例都会有一个 <code class=\"language-text\">receiveComponent</code>的方法，它定义如下,</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 我们忽略其他参数</span>\n<span class=\"token comment\">// nextElement 就是更新的element对象，它是通过render生成的。</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">receiveComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextElement<span class=\"token punctuation\">:</span> ReactElement</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span></code></pre></div>\n<p>每次更新时，通过组件的<code class=\"language-text\">render</code>方法返回新的 element 对象，然后会调用当前 InternalComponent 的<code class=\"language-text\">receiveComponent</code>方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">InternalComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">receiveComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextElement</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> prevElement <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_currentElement\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">updateComponent</span><span class=\"token punctuation\">(</span>prevElement<span class=\"token punctuation\">,</span> nextElement<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">updateComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevParentElement<span class=\"token punctuation\">,</span> nextParentElement</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 更新当前节点的props和state</span>\n    <span class=\"token keyword\">var</span> prevProps <span class=\"token operator\">=</span> prevParentElement<span class=\"token punctuation\">.</span>props\n    <span class=\"token keyword\">var</span> nextProps <span class=\"token operator\">=</span> nextParentElement<span class=\"token punctuation\">.</span>props\n    <span class=\"token keyword\">var</span> nextState <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_processPendingState</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextContext<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_publicInstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> nextProps\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_publicInstance<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> nextState\n\n    <span class=\"token comment\">// 更新子节点</span>\n    <span class=\"token keyword\">var</span> prevComponentInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_renderedComponent\n    <span class=\"token comment\">// 上次render出来的element</span>\n    <span class=\"token keyword\">var</span> prevRenderedElement <span class=\"token operator\">=</span> prevComponentInstance<span class=\"token punctuation\">.</span>_currentElement\n    <span class=\"token comment\">// 调用component 的 render，获取新的element</span>\n    <span class=\"token keyword\">var</span> nextRenderedElement <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_publicInstance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 判断是否是仅仅需要更新子节点</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">shouldUpdateReactComponent</span><span class=\"token punctuation\">(</span>prevRenderedElement<span class=\"token punctuation\">,</span> nextRenderedElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 子节点，递归调用receiveComponent</span>\n      prevComponentInstance<span class=\"token punctuation\">.</span><span class=\"token function\">receiveComponent</span><span class=\"token punctuation\">(</span>nextRenderedElement<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 否则，卸载旧的子节点，然后走新建子节点流程</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过递归的方式，利用浏览器调用栈来保存当前执行中的一些数据。这个过程是不可以中断的，必须等到执行栈为空，才可以处理其他事情。这样带来的问题如下，</p>\n<ol>\n<li>如果当前组件层次非常深，或者某一个组件更新耗时非常长，用户操作（点击，输入）不能得到立即响应，表现出卡顿</li>\n<li>对于动画场景而言，如果一帧时间超过 16ms，就会出现掉帧，动画不流畅</li>\n<li>对于一些低优先级的组件（比如隐藏，屏幕外），也会同样占用更新资源，没有优先级之分。</li>\n</ol>\n\n        <h2 id='toc-2-3' >\n          Fiber reconciler\n        </h2>\n      \n<p>为了解决 Stack reconciler 出现的问题，react 团队开始采用新架构，希望可以实现一下几个目标，</p>\n<blockquote>\n<ol>\n<li>Ability to split interruptible work in chunks.</li>\n<li>Ability to prioritize, rebase and reuse work in progress.</li>\n<li>Ability to yield back and forth between parents and children to support layout in React.</li>\n<li>…</li>\n</ol>\n</blockquote>\n\n        <h3 id='toc-3-3' >\n          Fiber Tree\n        </h3>\n      \n<p>类似 Stack reconciler，react 会通过 <a href=\"https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiber.js#L743\">createFiberFromElement</a> 给每一个 element 对象生成一个 Fiber node，Element tree 也会以这样的层次关联形式一颗 Fiber tree</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>object FiberNode<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> App<span class=\"token punctuation\">,</span>\n  stateNode<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> object App<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  return<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> object FiberNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  sibling<span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span><span class=\"token punctuation\">,</span>\n  child<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object FiberNode<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token operator\">:</span> Main<span class=\"token punctuation\">,</span>\n    stateNode<span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span><span class=\"token punctuation\">,</span>\n    return<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> object FiberNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    sibling<span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span><span class=\"token punctuation\">,</span>\n    child<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object FiberNode<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">\"div\"</span><span class=\"token punctuation\">,</span>\n      stateNode<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object DOMComponent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      return<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> object FiberNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      sibling<span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span><span class=\"token punctuation\">,</span>\n      child<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object FiberNode<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n        type<span class=\"token operator\">:</span> <span class=\"token string\">\"button\"</span><span class=\"token punctuation\">,</span>\n        stateNode<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object HTMLButtonElement<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        return<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> object FiberNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        sibling<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object FiberNode<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n          type<span class=\"token operator\">:</span> <span class=\"token string\">\"span\"</span><span class=\"token punctuation\">,</span>\n          stateNode<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>object HTMLSpanElement<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n          return<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> object FiberNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n          sibling<span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span><span class=\"token punctuation\">,</span>\n          child<span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>每一个 Fiber node 的 return 指向的是当前节点的父节点，child 指向当前节点的第一个子节点，如果有多个子节点，则其他子节点通过 sibling 链接起来。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/110a4a47f4abd88c53d18a63aadf9cae/04655/fiber-tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 431px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAACh0lEQVQ4y5WU/U/TQBjH+5/7iz+YEANGBjExMTHGmBgRGG9GNBhUHBvDN94WTYB1FNq146693l3fvj7tAMfcGD7bbc31+unzfL/PnfFhh+HTvo/3X2183GVY3/PRCSLkkWUZ+uNyLgs0Mp0gixIgBbjP4boujNLSCaZWLNx9uoXJhSam3tiwPFk8lA4AEhHFLNeATy/OX65TiFCAMQajtt9BbcfD92OFtbqJte0WZJQNzzDH0ZdBI0QMhYR+MziOA8uyYBR39UWJMWWWqKGwXqAkjCRYF5jC5xye58FISYNUREUZYSgRyr/AmzRknXOEgYAMKc8oRrvdhm3bMDJJCTuiWCQJKKW8FVBpBaVU8R/HMSUTQggBY2OPo5q7+9NG5YCh0gjARHxz2UPm8zBKyxZKKye483gDk4tNTI9w+aptLiroH8aXXQ+VHx62jzRWayZWt0yEOhuZydAMuy53S0wjiWyEy6OBMbU5dX0eWklorYaWdCug7Ui0Dzk6xLHcsBhZn2a9uo0EzlQ8lOsMz97+wny1g7nqOfZ/txBpWbTDIDNuBE4vt/CIXJ4sH6K0cIyH5SaOzzhpGYFR9wdB8F9QI/A1fFdAkZSt0zYs27u2IG90TuDbQg0kRAq7eznSGlGk/9FO0TxjvNC236R+w7pAceGyDAna4zJ9Lps7jhRC4Y/cMYZDLntHPjjpf9aROCWXk+TqaCnCFwlcP8Ep7SDXp4OAFguVDM6wcHbTwZPyN7z+bGGxzmEy0hQRgpQGXb1ruFiocjxfbeDVehPzNY4DUwwGPiibmJhv4t6LPYzPHWGifALTy3sxJaPyLFLMbJ7h/mwLYy8bGJ89xBhdVxusu7vS68A/w5YFv7daQDkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/110a4a47f4abd88c53d18a63aadf9cae/cc182/fiber-tree.webp 148w,\n/static/110a4a47f4abd88c53d18a63aadf9cae/f7e40/fiber-tree.webp 295w,\n/static/110a4a47f4abd88c53d18a63aadf9cae/1f7bb/fiber-tree.webp 431w\"\n          sizes=\"(max-width: 431px) 100vw, 431px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/110a4a47f4abd88c53d18a63aadf9cae/cf440/fiber-tree.png 148w,\n/static/110a4a47f4abd88c53d18a63aadf9cae/d2d38/fiber-tree.png 295w,\n/static/110a4a47f4abd88c53d18a63aadf9cae/04655/fiber-tree.png 431w\"\n          sizes=\"(max-width: 431px) 100vw, 431px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/110a4a47f4abd88c53d18a63aadf9cae/04655/fiber-tree.png\"\n          alt=\"fiber tree\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p><strong>注意跟 InternalComponent tree 中不同是，每一个节点，最多只能有一个 child</strong>。一个 <a href=\"https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiber.js#L128-L257\">Fiber node</a>，也是一个对象，除了 return ，child，sibling 之外，列觉一些比较重要的信息如下，</p>\n<ol>\n<li>statNode，存储 class component instance 或者 dom</li>\n<li>type，跟 react element type 一致</li>\n<li>alternate，指向 workInProgress 中对应 Fiber node</li>\n<li><a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js\">tag</a>，标志当前 Fiber node 组件的类型，根据 react element type 而得出。</li>\n<li><a href=\"https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js\">effectTag</a>，当前 Fiber node 一些副作用的任务类型，有 Placement，Update，Remove 等</li>\n<li>effectNext，指向下一个需要执行 effect 的 Fiber node；通过它，可以把 Fiber node 链接成一个单链表；然后在 commit 阶段，遍历 effectNext 执行更新。</li>\n</ol>\n<p>每一个 Fiber node，可以理解为一个最小更新单元(a unit of work)， 不同的组件(tag)，在更新阶段会有不同的事情要处理，比如（Placement，Update，LifeCycle。。。），这些不同的任务，通过 effectTag 来区分。</p>\n<p>使用 Fiber reconciler 之后，react 将一次完整的更新分为 2 个阶段，</p>\n<ol>\n<li>第一个阶段是 render 阶段，从根组件开始，构建出一个 workInProgress tree，这个阶段是可以中断的，异步的。一些在 render 阶段执行的生命周期方法（比如，willMount，willReceiveXXX，render）等就被要求是无副作用的，可多次执行的。</li>\n<li>第二个阶段就是 commit 阶段，render 阶段完成之后，就可以得到一颗完整的 workInProgress tree。commit 阶段就是将这颗树的状态同步更新到视图上，且执行一些有副作用的方法（比如，didMount，didUpdate）。为了保持视图状态的一致性，所以这个阶段是同步的，不可中断的。</li>\n</ol>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/73b542f4b477fe588a15479849dfcb20/d2b4f/wip-tree2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 561px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 94.8306595365419%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsSAAALEgHS3X78AAAB/ElEQVQ4y5VUS4vbMBjU/z+VXgo99NJLoVB6SHIJJbB5PyAtLDlsSDZvwq7t2I7ttfXwVJ9cZ71pXvvB5AuWNR5pRmJpmiIvpRQ45wckSQKhe6ok3N1Ow4GS4t/br/PyIi5GPwQiiOPYkOagCmOFJ5djHwk4ew7L4wheJKQeT4REwjMIqTLCnJkIT1XCFfaaINbdj7TSUOAlySYr9apSaHIqFgQBPM+D7/sIw/CgLFd+qWjc3gs8eQJrO8azL8B6vR7q9brBcDjUXxKHl4vEx6DiQuF7y8an8iM+Vx7x9c4GG4/HIIxGI0wmkzcKLynLTEwxnPhojhy0NBqjXbaH5yZcW+6Jp2AmGnqZZIqU8qb9K45LSW4rEyJymy2XSywWC6zXa2y323cv+X4Roffg4vfUx595BNZut1GtVg36/f5/plwiJFO+NSx8+PGAjz/H+PLrGcxxHBMZ27ax06fh1LLOEVJ3A45dIHSXcPzkvCnHsbnVOGZZFkil67om4Lkxp7J47nkRrNvtotFooNVqYTAYmOXTPhYdv/XkGIXT6RSz2cyEm3p2RhXyOB0ruWYYu7Qnx6S3hJ7RlZXff8X9K5K+SyGFej6fm3BvNhujKL/OKOir1cqM0X/6+FXCWq2GUqlk0Gw2EUWRUUrXWqfTQaVSQblcNrcRGXaN8C+m2sNUVhMNPgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/73b542f4b477fe588a15479849dfcb20/cc182/wip-tree2.webp 148w,\n/static/73b542f4b477fe588a15479849dfcb20/f7e40/wip-tree2.webp 295w,\n/static/73b542f4b477fe588a15479849dfcb20/72cfd/wip-tree2.webp 561w\"\n          sizes=\"(max-width: 561px) 100vw, 561px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/73b542f4b477fe588a15479849dfcb20/cf440/wip-tree2.png 148w,\n/static/73b542f4b477fe588a15479849dfcb20/d2d38/wip-tree2.png 295w,\n/static/73b542f4b477fe588a15479849dfcb20/d2b4f/wip-tree2.png 561w\"\n          sizes=\"(max-width: 561px) 100vw, 561px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/73b542f4b477fe588a15479849dfcb20/d2b4f/wip-tree2.png\"\n          alt=\"workInProgress tree\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n\n        <h3 id='toc-3-4' >\n          render 阶段\n        </h3>\n      \n<p>render 阶段就是重新构建 workInProgress tree，它会如下类似执行，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// concurrent 模式下，构建 workInProgress tree</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoopConcurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Perform work until Scheduler asks us to yield</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">shouldYield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    workInProgress <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// sync 模式下，构建 workInProgress tree</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoopSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Already timed out, so perform work without checking if we need to yield.</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    workInProgress <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过对比可以得到，concurrent 模式和 sync 模式的区别就是在构建 workInProgress tree 时是否可以中断。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">unitOfWork</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取WIP node 对应的current node</span>\n  <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> unitOfWork<span class=\"token punctuation\">.</span>alternate\n\n  <span class=\"token comment\">// 调用beginWork，对当前 node 处理，得到 child | null</span>\n  <span class=\"token comment\">// 如果 next 为 null，则表明遍历到最底部了，没有子节点了</span>\n  <span class=\"token keyword\">let</span> next <span class=\"token operator\">=</span> <span class=\"token function\">beginWork</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> unitOfWork<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>next <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果没有child了，就开始 complete 当前 node</span>\n    <span class=\"token comment\">// 此时，unitOfWork就是 child，如果当前 node 有 sibling，则返回 sibling，</span>\n    next <span class=\"token operator\">=</span> <span class=\"token function\">completeUnitOfWork</span><span class=\"token punctuation\">(</span>unitOfWork<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> next\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">performUnitOfWork</code> 是 DFS（Depth-first search）遍历过程，先将当前节点执行<code class=\"language-text\">beginWork</code>，然后开始找子节点，对子节点执行<code class=\"language-text\">beginWork</code>，如果没有子节点了，就执行<code class=\"language-text\">completeWork</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">beginWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">current<span class=\"token punctuation\">,</span> workInProgress</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// statNode会存component instance 或者 dom node</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>stateNode\n\n  <span class=\"token comment\">// 这里只是列举了class component情况，注意如果是function component会有不同处理</span>\n  <span class=\"token keyword\">const</span> nextChildren <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 这里会根据render出来的element去创建Fiber，</span>\n  <span class=\"token comment\">// 有其他逻辑，比如根据key来处理，</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    workInProgress<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> <span class=\"token function\">mountChildFibers</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> nextChildren<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    workInProgress<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> <span class=\"token function\">reconcileChildFibers</span><span class=\"token punctuation\">(</span>\n      workInProgress<span class=\"token punctuation\">,</span>\n      current<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">,</span>\n      nextChildren\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 返回child fiber</span>\n  <span class=\"token keyword\">return</span> workInProgress<span class=\"token punctuation\">.</span>child\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">beginWork</code>会根据不同的<code class=\"language-text\">tag</code>来做不同的处理，<code class=\"language-text\">effectTag</code>也是在此方法中生成的，具体代码没有列举出来。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">completeUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">unitOfWork</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Attempt to complete the current unit of work, then move to the next</span>\n  <span class=\"token comment\">// sibling. If there are no more siblings, return to the parent fiber.</span>\n  workInProgress <span class=\"token operator\">=</span> unitOfWork\n  <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>alternate\n    <span class=\"token keyword\">const</span> returnFiber <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>return\n\n    <span class=\"token comment\">//complete task</span>\n    <span class=\"token function\">completeWork</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> workInProgress<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">//这里省略了effectNext的生成过程</span>\n    <span class=\"token comment\">// 。。。</span>\n\n    <span class=\"token keyword\">const</span> siblingFiber <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>sibling\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>siblingFiber <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If there is more work to do in this returnFiber, do that next.</span>\n      <span class=\"token keyword\">return</span> siblingFiber\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// Otherwise, return to the parent</span>\n    workInProgress <span class=\"token operator\">=</span> returnFiber\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// We've reached the root.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressRootExitStatus <span class=\"token operator\">===</span> RootIncomplete<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    workInProgressRootExitStatus <span class=\"token operator\">=</span> RootCompleted\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当子节点为<code class=\"language-text\">null</code>时，就会进入<code class=\"language-text\">completeUnitOfWork</code>，它会先对当前节点执行<code class=\"language-text\">completeWork</code>，如果有兄弟节点，则直接返回兄弟节点（兄弟节点后面也会进入<code class=\"language-text\">beginWork</code> -> <code class=\"language-text\">completeWork</code>流程），否则就对父节点执行<code class=\"language-text\">completeWork</code>。对于我们上面的例子，执行流程如下，</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">beginWork App -&gt; beginWork Main -&gt; beginWork div -&gt; beginWork button -&gt;  completeWork button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    |\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    v\ncompleteWork App &lt;-\tcompleteWork Main &lt;- completeWork div\t&lt;- completeWork span &lt;-\tbeginWork span</code></pre></div>\n<p>类似于执行栈的调用，</p>\n<center>\n  <img src=\"/fiber-stack-5a32b0a2b12c07723b9757b08268c837.gif\">\n</center>\n<!-- ![Fiber stack](/fiber-stack-5a32b0a2b12c07723b9757b08268c837.gif) -->\n<p>在<code class=\"language-text\">completeWork</code>之后，根据节点的<code class=\"language-text\">effectTag</code>来决定是否将当前节点加入到<code class=\"language-text\">effectNext</code>链表中去。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> effectTag <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>effectTag\n\n<span class=\"token comment\">// Skip both NoWork and PerformedWork tags when creating the effect</span>\n<span class=\"token comment\">// list. PerformedWork effect is read by React DevTools but shouldn't be</span>\n<span class=\"token comment\">// committed.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTag <span class=\"token operator\">></span> PerformedWork<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>lastEffect<span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> workInProgress\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> workInProgress\n  <span class=\"token punctuation\">}</span>\n  returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> workInProgress\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fe687d670025dbb722e026c92c143ef0/aff45/effectList.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 475px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 75.15789473684211%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAACNklEQVQoz21Sy2oUQRTtnR/hSsGNfxBREF250Y1Z6MqVq0Q0opBVjEoQRRAZN4IoClloUHDjLGNghM4DTUbQOJkxJpN5dfWjunu6q6rr4a2anslrilrU455zzz33Wnzze/LqejJ7h/gOkUpIqQ4seDn8aJbF7PfBtSPB2NHgh42bQdhCKqMySRTnQ8L3s1gyQuzXV1WzAw8/evd7/PHiytKWol3h+cp1leepblcBlxCHWSxz0KeWR64+XD43Ufqy2IYrF0YtYOJYRZFmgR2GitIB3jIRHLYQso7IWi0kbHiFOhJUBIFWlKZ55p4GGbZZ4XJ6/xQtzREKvyzNZMrkELPADsBHUQ+s6xGNKp4+40+cwPOzccCCzZ0I4UYnTOKkn1hKsYcJISs/gR7X5TR1Hd+EGbqKHd0bCWfOpzuVTKcQB5IbcJYpxwEIE7KDmU5i+pRt2PjW8fDuSVz9udHOqvUw44A3ycG5XDbYaAwAz/yIDfyXGeV+Q7VqpIPGnq9emix9nN/WYWAJJNOGMSaheqVwTJ99+DP5sry87hldXPVLJM3OzcLa6PTK529NDe44WqwGEyJdHd1EyeiUfXp84W3xH7SyjrVB+WyE2KtVtytVHgUKuYNWW7p0hKB7LE7K687SatP1iEJ/kV3Mtsq5PaSbzJyNbx/Lii8G3en3GfBApj3AKvIVU8nrGzDw8dOLeZNoEheu4KkRas/pu+B7wP05kJpUf9CFN/GTC+mnB7t5eoO4f/0H5cA+V3QdyX0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/fe687d670025dbb722e026c92c143ef0/cc182/effectList.webp 148w,\n/static/fe687d670025dbb722e026c92c143ef0/f7e40/effectList.webp 295w,\n/static/fe687d670025dbb722e026c92c143ef0/ef8fc/effectList.webp 475w\"\n          sizes=\"(max-width: 475px) 100vw, 475px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/fe687d670025dbb722e026c92c143ef0/cf440/effectList.png 148w,\n/static/fe687d670025dbb722e026c92c143ef0/d2d38/effectList.png 295w,\n/static/fe687d670025dbb722e026c92c143ef0/aff45/effectList.png 475w\"\n          sizes=\"(max-width: 475px) 100vw, 475px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/fe687d670025dbb722e026c92c143ef0/aff45/effectList.png\"\n          alt=\"effectList\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>类似上面这颗树，得到的 effect List 如下，</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9f697ff9dd9c36b14d43592710d574c/d68ed/effectList2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 14.466292134831463%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAvklEQVQI12P4////u/cfHjx8+OnzVyD7z9+/z5+/ePz4yc+fv4Dcr1+/Pnr0+MWLl//B4M3bdw8fPvr85SuEy/B9SdHf98//AbU9vf5tftbPvTP+/voJ5P48vvLrtJjft08A2f++fvi+rvH7ivI/718Aub/vnf02N/3H1h6GTxV6fx5f+f/79+9rBz4WKn2bnQJU+v/vn++raz4k8/w6sfL/v79/3zz60ubyqdbk77Mb///+/nV248c8uS8TggCc5ZkrityUCAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/b9f697ff9dd9c36b14d43592710d574c/cc182/effectList2.webp 148w,\n/static/b9f697ff9dd9c36b14d43592710d574c/f7e40/effectList2.webp 295w,\n/static/b9f697ff9dd9c36b14d43592710d574c/1a2f4/effectList2.webp 590w,\n/static/b9f697ff9dd9c36b14d43592710d574c/04f0c/effectList2.webp 712w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/b9f697ff9dd9c36b14d43592710d574c/cf440/effectList2.png 148w,\n/static/b9f697ff9dd9c36b14d43592710d574c/d2d38/effectList2.png 295w,\n/static/b9f697ff9dd9c36b14d43592710d574c/b9e4f/effectList2.png 590w,\n/static/b9f697ff9dd9c36b14d43592710d574c/d68ed/effectList2.png 712w\"\n          sizes=\"(max-width: 590px) 100vw, 590px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/b9f697ff9dd9c36b14d43592710d574c/b9e4f/effectList2.png\"\n          alt=\"effectList2\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>这样做的好处是，在 commit 阶段只需遍历<code class=\"language-text\">effectNext</code>就可以了，而不需要遍历整颗树。</p>\n\n        <h3 id='toc-3-5' >\n          commit 阶段\n        </h3>\n      \n<p>commit 阶段就会开始真正的更新视图了，它会处理如下事情</p>\n<ol>\n<li>在更新之前，执行一些方法，比如是<code class=\"language-text\">getSnapshotBeforeUpdate</code>，获取更新之前的状态</li>\n<li>执行更新，包括，dom 的更新，创建，删除等</li>\n<li>将 workInProgress tree 切换为 current tree，因为视图已经根据 workInProgress 更新了</li>\n<li>之前更新之后的一些方法，比如<code class=\"language-text\">componentDidMount</code>，<code class=\"language-text\">componentDidUpdate</code>。</li>\n</ol>\n<p>代码大致如下，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">commitRoot</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// finishedWork 就是 WIP tree</span>\n  <span class=\"token keyword\">const</span> finishedWork <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>finishedWork\n  root<span class=\"token punctuation\">.</span>finishedWork <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n\n  <span class=\"token comment\">// Get the list of effects.</span>\n  <span class=\"token comment\">// 从RootFiber的firstEffect开始</span>\n  <span class=\"token keyword\">let</span> firstEffect <span class=\"token operator\">=</span> finishedWork<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">||</span> finishedWork\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// The first phase a \"before mutation\" phase. We use this phase to read the</span>\n    <span class=\"token comment\">// state of the host tree right before we mutate it. This is where</span>\n    <span class=\"token comment\">// getSnapshotBeforeUpdate is called.</span>\n    <span class=\"token function\">commitBeforeMutationEffects</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// The next phase is the mutation phase, where we mutate the host tree.</span>\n    <span class=\"token comment\">// 包括 Placement | Update | Deletion | Hydrating</span>\n    <span class=\"token comment\">// componentWillUnmount,</span>\n    <span class=\"token function\">commitMutationEffects</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// The work-in-progress tree is now the current tree. This must come after</span>\n    <span class=\"token comment\">// the mutation phase, so that the previous tree is still current during</span>\n    <span class=\"token comment\">// componentWillUnmount, but before the layout phase, so that the finished</span>\n    <span class=\"token comment\">// work is current during componentDidMount/Update.</span>\n    root<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> finishedWork\n\n    <span class=\"token comment\">// The next phase is the layout phase, where we call effects that read</span>\n    <span class=\"token comment\">// the host tree after it's been mutated. The idiomatic use case for this is</span>\n    <span class=\"token comment\">// layout, but class component lifecycles also fire here for legacy reasons.</span>\n    <span class=\"token comment\">// componentDidMount/componentDidUpdate.</span>\n    <span class=\"token function\">commitLayoutEffects</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> expirationTime<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// No effects.</span>\n    root<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> finishedWork\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>对于第 1，2，4 步，都是通过遍历<code class=\"language-text\">effectNext</code>来执行的。类似代码如下，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 遍历 nextEffect 链表</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">executeEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> effectTag <span class=\"token operator\">=</span> nextEffect<span class=\"token punctuation\">.</span>effectTag\n    <span class=\"token comment\">// 根据effectTag 做一些事情</span>\n    <span class=\"token comment\">// 。。。</span>\n    nextEffect <span class=\"token operator\">=</span> nextEffect<span class=\"token punctuation\">.</span>nextEffect\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>render 阶段 和 commit 阶段执行流程如下，</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d948bc1f80b97c0109292678175abb94/3064a/workloop.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 584px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 80.65068493150686%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAABpElEQVQoz42TD2+DIBDF/f7fcFvm1k5R/NeKAoKg+7U2jTHNsktL4I5373F3Jus/TClV17UQ4nK57P0Jf2unrrtqY7F9LISAZ1nXZVmMMX3fxxiP4EvXFuePMEGguPeMgSykDDH2w8CmKIpxHI/gUanq8609f7VSHgQHrVVRNOfzrJRzbp/6AVZ9Lz/T+uu7zvN9jItRqblpbFWtfT9ZOwzDEfyH+Xmu2lZIqaeH/QVe7rb3UKdKyoNzO75gJkCdvffwsLler1LKeZ55Mx42OF+DqXBVVbSUynOJxtLhPM+7rgNJRjxZluGkbUcwYfBIpTZQkQJY27b4NzaYh7txfCGbMOnD3UivtQb/fBI/kNaYF7IBIBud0HJk5cF4nsOnrc3LsrnPafIs0iYShVBtmjf9qGC91WlZkBHr2mTZJAQKk3WJQL1zZckIyjRNy7Lc5pR3kovj6XRiHY3xjMrPjxfCZxltuDFT+2HUId46BAkv3PqEMcwImZx7tMr7cffxJK5ObZWOxXvoxeR80zR0Aqkwk4U9nDTGTtOi9SylEYIVVYB/AW9hoM7D2JM/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <picture>\n        <source\n          srcset=\"/static/d948bc1f80b97c0109292678175abb94/cc182/workloop.webp 148w,\n/static/d948bc1f80b97c0109292678175abb94/f7e40/workloop.webp 295w,\n/static/d948bc1f80b97c0109292678175abb94/d0231/workloop.webp 584w\"\n          sizes=\"(max-width: 584px) 100vw, 584px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/d948bc1f80b97c0109292678175abb94/cf440/workloop.png 148w,\n/static/d948bc1f80b97c0109292678175abb94/d2d38/workloop.png 295w,\n/static/d948bc1f80b97c0109292678175abb94/3064a/workloop.png 584w\"\n          sizes=\"(max-width: 584px) 100vw, 584px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n          src=\"/static/d948bc1f80b97c0109292678175abb94/3064a/workloop.png\"\n          alt=\"work loop\"\n          title=\"\"\n        />\n      </picture>\n  </span>\n  </a></p>\n<p>这个图里使用了<code class=\"language-text\">requestIdleCallback</code>来代表 react 里做时间分片；实际上，react 并不是使用的 rIC，而是自己使用 Message channel 实现的，至于为什么不使用 rIC，是因为 <a href=\"https://github.com/facebook/react/issues/13206#issuecomment-418923831\">rIC 在 1s 内执行频率不够</a>，感兴趣的可以自己去看看。</p>\n\n        <h2 id='toc-2-4' >\n          小结\n        </h2>\n      \n<p>从 stack reconciler 切换到 fiber reconciler，React 团队做的事情是，改变了遍历一颗树的方式。stack reconciler 中是使用递归，利用 JS 调用栈的方式，遍历 InternalComponent tree，这个过程是不可中断的，对于高优先级或者用户操作，需要等待执行栈为空才可以得到处理。而在 fiber reconciler 中，使用循环，通过<code class=\"language-text\">beginWork</code>，<code class=\"language-text\">completeWork</code>模拟入栈，出栈操作，达到遍历 fiber tree，这个过程可以根据<code class=\"language-text\">shouldYield</code>来停止，使用 workInProgress 来暂存当前节点，稍后可以继续恢复遍历。</p>\n\n        <h2 id='toc-2-5' >\n          参考资料\n        </h2>\n      \n<ol>\n<li><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/7942\">Contributing to fiber</a></li>\n<li><a href=\"https://reactjs.org/docs/implementation-notes.html\">Notes for Stack reconciler</a></li>\n<li><a href=\"https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/\">Inside fiber in depth</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\">A Cartoon Intro to Fiber - React Conf 2017</a></li>\n</ol>","tableOfContents":"<ul><li><a href=\"#toc-2-1\">Jsx &#x26;&#x26; element</a></li><li><a href=\"#toc-2-2\">Stack reconciler</a></li><li><a href=\"#toc-2-3\">Fiber reconciler</a></li><li><a href=\"#toc-2-4\">小结</a></li><li><a href=\"#toc-2-5\">参考资料</a></li></ul>","frontmatter":{"title":"React Fiber 分享","date":"July 13, 2020","tags":["react","fiber"],"zan":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2020/stack_reconciler_vs_fiber_reconciler/","previous":{"fields":{"slug":"/post/2020/summary_of_2019/"},"frontmatter":{"title":"2019年小结"}},"next":null}}