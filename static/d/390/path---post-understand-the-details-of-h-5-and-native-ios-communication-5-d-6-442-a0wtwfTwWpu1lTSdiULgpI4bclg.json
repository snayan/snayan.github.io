{"data":{"avatar":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQD/2gAMAwEAAhADEAAAAcSerUQpOzXUqiMAb//EABsQAAMAAgMAAAAAAAAAAAAAAAABAhESAxQh/9oACAEBAAEFAjzJ1VJcZepyU9x0z//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/AWP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAADAAIDAAAAAAAAAAAAAAAAASEQERIxMv/aAAgBAQAGPwImPUNtcTodiz//xAAcEAACAgMBAQAAAAAAAAAAAAAAAREhMUFRYXH/2gAIAQEAAT8hWbK7l6NWStvasZEW4S7fwfTTAkNzkQZ//9oADAMBAAIAAwAAABAs1wP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABEQ/9oACAEDAQE/EMLbwL//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAQ/9oACAECAQE/EIzR4rv/xAAfEAEAAwACAQUAAAAAAAAAAAABABEhMUFRYXGBodH/2gAIAQEAAT8QAjVRsF68R3WyhBpEB4otans9oxQXOZRxVfkow9YivuDFJrEfPmaECm2kqIiV2XP/2Q==","width":40,"height":40,"src":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg","srcSet":"/static/9d156e8486b343189790da372acb0018/987ea/my.jpg 1x,\n/static/9d156e8486b343189790da372acb0018/9c097/my.jpg 1.5x,\n/static/9d156e8486b343189790da372acb0018/bd6c6/my.jpg 2x"}}},"site":{"siteMetadata":{"title":"三羊的小站","author":"三羊","postPath":"/post","contentUrl":"https://github.com/snayan/blog-source/tree/master/content/blog","menu":{"search":{"name":"搜索","link":"/search"}}}},"markdownRemark":{"id":"ae499c39-cdba-50d6-b542-e6b565450b87","excerpt":"在跨平台客户端开发中，H5 是使用最为广泛的方式，它既可以运行在 iOS 中，也可以运行在 Android 中，还可以运行在 web 浏览器中，可以说是”write once, run anywhere”。但是，H5 最为人诟病的就是用户体验不如 native…","html":"<p>在跨平台客户端开发中，H5 是使用最为广泛的方式，它既可以运行在 iOS 中，也可以运行在 Android 中，还可以运行在 web 浏览器中，可以说是\"write once, run anywhere\"。但是，H5 最为人诟病的就是用户体验不如 native 流畅，特别是对于低端机型和较差的网络环境，在页面加载时通常有较长一段时间的白屏等待时间。H5 开发者想尽办法缩短首屏时间，用户可交互时间，为此使用了一系列的优化手段，比如 ssr，code split，compress，lazy load，preload 等等，其实主要是围绕<strong>尽量少</strong>这一核心原则。为了平衡跨终端能力和用户体验，现在流行的又有 RN 和 Flutter 解决方案等。咦，感觉跑题了，还是回到标题说的，具体来看看在 IOS 中，H5 是怎么与 native 通信的。文字略长，但是我相信你看完了，会有所收获。</p>\n<p>说到通信，无非就是两种方式，native 调用 h5，h5 调用 native。H5 在 iOS 中的宿主是 UIWebView 或者 WKWebView，在 IOS8 中，Apple 引入了 WKWebView，将 UIWebView 标记为 Deprecated。现在来说，大部分 app 应该都是使用的 WKWebView，除非那些需要兼容 IOS8 以下系统的才会兼容使用 UIWebView，本文也主要是说说使用 WKWebView 的场景。在实现 H5 与 native 之间的通信，比较流行的库就是<a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\">WebViewJavascriptBridge</a>，为了真正弄明白原理，我也是通读了它的源码，然后根据它的实现思路，自己用 swift 也实现了一遍。下面就结合一个小例子，谈谈它的实现原理。</p>\n<!--more-->\n<p>假如有一个需求，是 H5 在 app 内会有一个截屏按钮，点击这个按钮能对当前 webView 截图，然后显示在我们的 H5 中一个<code>img</code>元素里。</p>\n<img src=\"./p.png\" style=\"zoom:30%\" />\n<p>如图可以看到，有一个截屏按钮，以及一个紫色区域，这个区域内有一个<code>img</code>，用来显示我们截屏之后的图片。</p>\n<p>这个通常需要 H5 与 native 配合才能完成，截屏的功能肯定是 native 那边完成，但是触发时机肯定是 H5 这边来控制。native 需要提供一个 bridge 接口，比如 takeSnapshot，然后在 H5 中就需要调用 takeSnapshot 接口并获得相应数据，</p>\n<pre><code class=\"language-jsx\">// h5部分代码\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      src: null,\n    }\n    this.takeSnapshot = this.takeSnapshot.bind(this)\n  }\n  takeSnapshot() {\n    if (window.mpBridge) {\n      window.mpBridge.ready(bridge => {\n        bridge.callHandler(\"takeSnapshot\", ({ status, data }) => {\n          if (status) {\n            this.setState(() => {\n              return {\n                src: data.path,\n              }\n            })\n          }\n        })\n      })\n    }\n  }\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;div className=\"operate\">\n          &#x3C;button onClick={this.takeSnapshot}>截屏&#x3C;/button>\n        &#x3C;/div>\n        &#x3C;div className=\"result\">\n          &#x3C;img src={this.state.src} />\n        &#x3C;/div>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<p>这段代码比较简单，就不解释。可以看到在调用 takeSnapshot 的回调中，h5 拿到了 path，然后将 path 赋值给了<code>img</code>标签。</p>\n\n          <h4 id='toc-4-1' >\n            Bridge 的初始化\n          </h4>\n        \n<p>在完成上面这个例子时，H5 和 native 两边都需要先完成 bridge 的初始化。H5 这边通常会在<code>html</code>的 <code>head</code>中加载一段 sdk 代码，用来触发生成 H5 端 bridge 对象，每个公司都会自己提供一个对外的 sdk 脚本，比如微信提供的 sdk 等。通常放在<code>head</code> 中，是因为它需要最先执行完成，这样你代码中才可以使用。这个 sdk 脚本，其实就是提供了一个<code>ready</code>函数，bridge 对象完成之后，会调用里面的回调函数，并提供<code>bridge</code>对象作为参数。</p>\n<pre><code class=\"language-javascript\">/* bridge sdk\n mpBridge.ready(bridge => {\n   bridge.callHandler('cmd', params, (error, data) => {\n\n   })\n})\n*/\n\n;(function(w, d) {\n  // 已经加载了就直接返回，防止加载2遍\n  if (w.mpBridge) {\n    return\n  }\n\n  // 是否bridge初始化完成\n  let initialized = false\n  let queue = []\n\n  function ready(handler) {\n    if (initialized) {\n      // 如果bridge初始化完成，则直接派发，执行\n      dispatch(handler)\n    } else {\n      // 否则，先缓存在队列里，等待bridge完成后派发，执行\n      queue.push(handler)\n    }\n  }\n\n  function dispatch(handler) {\n    // 派发，执行时，会提供bridge对象当作第一个参数\n    handler(w.ClientBridge)\n  }\n\n  function _initialize() {\n    // bridge初始化完成了，就开始派发，执行先前缓存在队列里的\n    for (var handler of queue) {\n      dispatch(handler)\n    }\n    queue = []\n    initialized = true\n  }\n\n  // 通知native，注入bridge对象到当前的window对象上\n  setTimeout(function() {\n    var iframe = d.createElement(\"iframe\")\n    iframe.hidden = true\n    // 这个src会被native那边拦截，然后根据host == 'bridgeinject',来判断是否注入bridge对象\n    iframe.src = \"https://bridgeinject\"\n    d.body.appendChild(iframe)\n    setTimeout(function() {\n      iframe.remove()\n    })\n  })\n\n  // interface api\n  const mpBridge = {\n    ready: ready,\n    version: \"1.0\",\n    _initialize: _initialize,\n  }\n\n  window.mpBridge = mpBridge\n})(window, document)\n</code></pre>\n<p>这是我写的 sdk，用于完成上面那个截屏的例子。最为主要功能是生成一个隐藏的 iframe，来通知 native 注入 bridge 对象到 window 上，注入的 bridge 对象就是 ClientBridge。它本身自己也会生成一个对象<code>mpBridge</code>，用来提供给开发人员。当然，这个 sdk 的功能比较简单，其他公司的可能比较复杂，但是它绝对包含了最为重要的功能。这个时候 h5 中 ClientBridge 的初始化才算完成了一半，ClientBridge 还没有被真正创建，真正被创建的过程是在 native 中完成的。</p>\n<p>在 native 端，在 viewController 中创建了 webview 并实现了 navigationDelegate，并且也创建了 NativeBridge。在 navigationDelegate 中，<strong>我们可以拦截 h5 中 iframe 发送的请求，理解这点非常重要，h5 与 native 之间的通信就是通过这个拦截操完成的</strong>，后面会看到具体拦截细节，我们先看 native 端 NativeBridge 初始化的过程。</p>\n<pre><code class=\"language-swift\">/// native 代码\n/// 创建webview\nwebView = WKWebView(frame: CGRect.zero, configuration: configuration)\nwebView.navigationDelegate = self\n/// 初始化native端bridge\nif let bridgeScriptPath = Bundle.main.path(forResource: \"bridge\", ofType: \"js\") {\n    self.bridge = Bridge(webView: webView, scriptURL: URL(fileURLWithPath: bridgeScriptPath))\n}\n</code></pre>\n<p>在 native 端，也会生成一个 bridge 对象，通过这个对象，native 可以注册接口函数给 h5 调用，native 也可以调用 h5 中注册的函数。通过 sdk 中生成的 iframe，触发注入 h5 端 ClientBridge，此时，native 端才开始把 ClientBridge 注入到 h5 中去，</p>\n<pre><code class=\"language-swift\">/// native 代码\nfunc injectClientBridge(completionHandler handler: EvaluateJavasriptHandler?) {\n    if let data = try? Data(contentsOf: scriptURL),\n    let code = String(data: data, encoding: .utf8) {\n        /// 核心点就是，native可以直接执行JavaScript\n        evaluateJavascript(code, completionHandler: handler)\n    } else {\n        handler?(nil, BridgeError.injectBridgeError)\n    }\n}\n</code></pre>\n<p><strong>在 native 端，可以直接以字符串形式执行 JavaScript 脚本</strong>。通常，会先准备好 ClientBridge 的脚本，然后在 native 直接执行，就可以将它注入到 H5 中去了。我准备的 ClientBridge 脚本如下，</p>\n<pre><code class=\"language-javascript\">/*\n   ClientBridge.callHandler('cmd', params, (error, data) => {\n\n   })\n*/\n\n;(function(w, d) {\n  // 已经注入了ClientBridge\n  if (w.ClientBridge) {\n    return\n  }\n\n  // uid自增，用来标记callBackID的\n  var uid = 0\n  // h5中消息队列，用来发送到native中去的\n  var messageQueue = []\n  // h5回调函数映射表，通过callBackID关联\n  var callbacksMap = {}\n\n  // 通信的scheme，可以是其他字符串\n  var scheme = \"https\"\n  // 通信的host，用来标记请求是h5通信发出的\n  var messageHost = \"bridgemessage\"\n  var messageUrl = scheme + \"://\" + messageHost\n  // 会创建一个iframe，h5发送消息给native，通过iframe触发\n  var iframe = (function() {\n    var i = d.createElement(\"iframe\")\n    i.hidden = true\n    d.body.appendChild(i)\n    return i\n  })()\n\n  function _noop() {}\n\n  // 处理来自native端的消息，\n  function _handlerMessageFromNative(dataString) {\n    console.log(\"receive message from native: \" + dataString)\n    let data = JSON.parse(dataString)\n    if (data.responseId) {\n      // 如果有responseId , 则说明消息是h5调用了native的接口，根据responseId可以找到存储的回调函数，然后执行回调，将数据传递给H5\n      var callback = callbacksMap[data.responseId]\n      if (typeof callback === \"function\") {\n        callback(data.responseData)\n      }\n      callbacksMap[data.responseId] = null\n    } else {\n      // 否则，就是native直接调用h5的接口，\n      var callback\n      if (data.callbackId) {\n        // 如果有callbackId，则要回发结果\n        callback = function(res) {\n          _doSend({ responseId: data.callbackId, responseData: res })\n        }\n      } else {\n        // 否则，不处理\n        callback = _noop\n      }\n      // 通过handlerName,找到h5注册好的接口函数\n      var handler = callbacksMap[data.handlerName]\n      if (typeof handler === \"function\") {\n        handler(data.data, callback)\n      } else {\n        console.warn(\"receive unknown message from native:\" + dataString)\n      }\n    }\n  }\n\n  // native 通过调用_fetchQueue函数来获取H5中消息队列里的消息\n  function _fetchQueue() {\n    var message = JSON.stringify(messageQueue)\n    messageQueue = []\n    console.log(\"send message to native : \" + message)\n    return message\n  }\n\n  // 发送消息\n  function _doSend(message) {\n    // 将消息加到消息队列里，\n    messageQueue.push(message)\n    // 然后通过iframe触发\n    iframe.src = messageUrl\n  }\n\n  // ClientBridge对外H5的函数，h5可以通过callHandler来调用native中的接口\n  function callHandler(name, data, callback) {\n    uid = uid + 1\n    if (typeof data === \"function\") {\n      callback = data\n      data = null\n    }\n    if (typeof callback !== \"function\") {\n      callback = _noop\n    }\n    // 先生成一个唯一的callbackId，\n    var callbackId = \"callback_\" + uid + new Date().valueOf()\n    // 将回调函数保存在哈希表中，后面通过responseId可以取出\n    callbacksMap[callbackId] = callback\n    // 发送\n    _doSend({ handlerName: name, data: data, callbackId: callbackId })\n  }\n\n  // ClientBridge对外h5的函数，h5可以通过registerHandler来注册接口，供native来调用\n  function registerHandler(name, callback) {\n    // 直接将注册的接口保存在哈希表中\n    callbacksMap[name] = callback\n  }\n\n  // 在window上生成ClientBridge对象\n  w.ClientBridge = {\n    callHandler: callHandler,\n    registerHandler: registerHandler,\n    _fetchQueue: _fetchQueue,\n    _handlerMessageFromNative: _handlerMessageFromNative,\n  }\n\n  // 调用sdk中的初始化方法\n  if (w.mpBridge) {\n    w.mpBridge._initialize()\n  }\n})(window, document)\n</code></pre>\n<p>核心原理也是通过在 h5 中生成一个 iframe，通过 iframe 来充当 h5 与 native 之间的信使。<code>ClientBridge.callHandler</code>和<code>ClientBridge.registerHandler</code>是暴露给 h5 端使用的，<code>ClientBridge._fetchQueue</code>和<code>ClientBridge._handlerMessageFromNative</code>是提供给 native 端使用的。只有当 native 执行了这一段脚本，h5 中 bridge 才算真正初始化完成。</p>\n\n          <h4 id='toc-4-2' >\n            拦截请求\n          </h4>\n        \n<p>在 native 端，通过实现 WkWebView 的 WKNavigationDelegate，可以拦截 h5 中加载 frame 的请求，然后通过请求的 scheme 和 host 来判断是否是我们约定好的，例如上面注入 bridge 的 sdk 中，我们约定的 scheme 是 https，host 是 bridgeinject。</p>\n<pre><code class=\"language-swift\">/// native 部分代码\n/// 此函数就是拦截h5中iframe发送的请求\nfunc webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {\n    guard webView == self.webView,\n        let bridge = self.bridge,\n        let url = navigationAction.request.url\n    else {\n        decisionHandler(.allow)\n        return\n    }\n    if bridge.isBridgeInjectURL(url) {\n        /// 如果注入bridge的请求，则开始注入bridge到h5中\n        bridge.injectClientBridge(completionHandler: nil)\n        /// 并取消掉本次请求，因为并不是真正的需要请求，\n        decisionHandler(.cancel)\n    } else if bridge.isBridgeMessageURL(url) {\n        /// 如果是h5与native之间的消息请求，则处理h5那边的消息，\n        bridge.flushMessageQueue()\n        /// 同样的，需要取消掉本次请求，\n        decisionHandler(.cancel)\n    } else {\n        /// 否则，其他情况，都正常请求\n        decisionHandler(.allow)\n    }\n}\n</code></pre>\n<p>上面的 native 中代码可以看到，通过实现了 WKNavigationDelegate 中 decidePolicyForNavigationAction 的方法，我们可以拦截 iframe 以及 mainFrame 的请求，然后做如下处理：</p>\n<ul>\n<li>如果请求是注入 bridge 到 h5 的请求，则开始处理注入 bridge 对象到 h5 中，并取消本次请求。这个请求就是上面 sdk 中创建的 iframe 触发的。它的请求 url 是<code>https://bridgeinject</code></li>\n<li>如果请求是 h5 与 native 之间通信的请求，则开始处理 h5 中传递的消息，并取消本次请求。这个请求会在后面看到。它的请求 url 是<code>https://bridgemessage</code></li>\n<li>否则，就是正常的 mainFrame 或者 iframe 请求，正常处理请求</li>\n</ul>\n\n          <h4 id='toc-4-3' >\n            H5 调用 native 接口\n          </h4>\n        \n<p>先来看看第一种通信方式，就是 h5 调用 native 中的接口，比如例子中，h5 调用 native 提供的 takeSnapshot 接口实现截屏功能。</p>\n<p>首先，native 端必须先注册好 takeSnapshot 接口，这样 h5 才能使用。native 端注册 takeSnapshot 接口代码如下，</p>\n<pre><code class=\"language-swift\">/// native端，通过NativeBridge注册takeSnapshot接口\nbridge?.registerHandler(\"takeSnapshot\") {\n    _, callback in\n    /// 调用webView的takeSnapshot函数实现截屏\n    self.webView.takeSnapshot(with: nil) {\n        image, error in\n        let fileName = \"snapshot\"\n        guard let image = image, error == nil else {\n            callback(Bridge.HandlerResult(status: .fail(-1)))\n            return\n        }\n        // 将得到的UIimage保存到cache file目录下\n        guard let _ = LocalStore.storeCacheImage(image, fileName: fileName) else {\n            callback(Bridge.HandlerResult(status: .fail(-2)))\n            return\n        }\n        // 生成src，提供给h5\n        guard let src = ImageBridge.generateSRC(fileName: fileName) else {\n            callback(Bridge.HandlerResult(status: .fail(-3)))\n            return\n        }\n        // 生成返回数据，包含src\n        var result = Bridge.HandlerResult(status: .success)\n        result.data = [\"path\": src]\n        callback(result)\n    }\n}\n</code></pre>\n<p>至于 native 端的 NativeBridge 实现细节，其实与 ClientBridge 思路一样的，大致也是有一个字典保存注册的函数，然后根据 h5 调用 handlerName 来查找出这个函数，然后执行，具体细节就不说了，感兴趣可以看看<a href=\"https://github.com/snayan/MusicPlayer/blob/master/MusicPlayer/bridge/Bridge.swift\">这里</a>。可以看到，h5 与 native 两边必须提供相同的 handlerName。通常呢，这个 handlerName 是 native 开发人员定义好的，然后 H5 开发人员按照文档使用。native 定义好了接口，那么 h5 这边就需要调用了，</p>\n<pre><code class=\"language-javascript\">// h5端，调用native定义的接口\nif (window.mpBridge) {\n  window.mpBridge.ready(bridge => {\n    bridge.callHandler(\"takeSnapshot\", ({ status, data }) => {\n      if (status) {\n        this.setState(() => {\n          return {\n            src: data.path,\n          }\n        })\n      }\n    })\n  })\n}\n</code></pre>\n<p>h5 在调用<code>bridge.callHandler</code>时，生成唯一的 callbackId，并将回调保存在哈希表中，然后通过 iframe 触发通知 native。</p>\n<pre><code class=\"language-javascript\">function callHandler(name, data, callback) {\n  uid = uid + 1\n  if (typeof data === \"function\") {\n    callback = data\n    data = null\n  }\n  if (typeof callback !== \"function\") {\n    callback = _noop\n  }\n  // 生成一个唯一的callbackId\n  var callbackId = \"callback_\" + uid + new Date().valueOf()\n  // 将回调函数保存在哈希表中\n  callbacksMap[callbackId] = callback\n  // 触发iframe发送消息\n  _doSend({ handlerName: name, data: data, callbackId: callbackId })\n}\n</code></pre>\n<p>native 通过拦截 iframe 的请求，判断是否 h5 中通信请求，如果是就开始处理，处理过程如下，</p>\n<pre><code class=\"language-swift\">//native 核心代码如下\nfunc flushMessageQueue() {\n    // 执行ClientBridge._fetchQueue,获取h5中消息队列中数据\n    evaluateJavascript(\"ClientBridge._fetchQueue()\") {\n        result, error in\n         // 转成json\n        let jsonData = try JSONSerialization.jsonObject(with: result, options: [])\n        let messages = jsonData as! [BridgeData]\n        for message in messages {\n            if let callbackId =  message[\"callbackId\"] as? String {\n                /// 生成RequestMesage，调用native接口\n                self.resumeWebCallHandlerMessage(RequestMessage(handlerName: message[\"handlerName\"] as? String, data: message[\"data\"] as? BridgeData, callbackId: callbackId))\n\n            }\n        }\n    }\n}\n</code></pre>\n<p>获取了 h5 中消息之后，判断消息中是否包含了 callbackId，如果包含了，则说明是 h5 发送的一个 RequestMessage。通过 handlerName 取出 native 注册好的接口函数，然后执行，并返回结果。</p>\n<pre><code class=\"language-swift\">func resumeWebCallHandlerMessage(_ message: RequestMessage) {\n    // 通过handlerName拿到native注册的接口，\n    guard let name = message.handlerName, let handler = self.responseHandlersMap[name] else {\n        debugPrint(\"unkown handler name\")\n        return\n    }\n    // 然后执行接口，并返回数据\n    handler(message.data) {\n        result in\n        // callbackId对应变成了responseId，返回的数据在responseData中\n        let responseMessage = ResponseMessage(responseData: result.getData(), responseId: message.callbackId)\n        self.sendToWeb(responseMessage)\n    }\n}\n</code></pre>\n<p>最后，native 通过执行<code>ClientBridge._handlerMessageFromNative</code>来将结果返回给 h5。</p>\n<pre><code class=\"language-swift\">/// 将消息发送给h5端\nfunc sendToWeb(_ message: MessageProtocol) {\n    do {\n        /// 先序列化json数据\n        let data = try JSONSerialization.data(withJSONObject: message.serialization(), options: [])\n        let result = String(data: data, encoding: .utf8) ?? \"\"\n        // 最后执行ClientBridge._handlerMessageFromNative\n        evaluateJavascript(\"\\(clientBridgeName)._handlerMessageFromNative('\\(result)')\", completionHandler: { _,_ in\n                                                                                                            })\n    } catch {\n        debugPrint(error)\n    }\n}\n</code></pre>\n\n          <h4 id='toc-4-4' >\n            native 调用 h5 接口\n          </h4>\n        \n<p>再来看看第二种通信方式，就是 native 调用 h5 端的接口，比如 h5 中会注册一个监听导航条上的返回按钮的函数，比较叫做 onBackEvent，native 通过调用 h5 中 onBackEvent 的接口函数，决定是否直接关闭当前 webView。</p>\n<p>类似的，h5 中必须先注册 onBackEvent 接口，</p>\n<pre><code class=\"language-javascript\">if (window.mpBridge) {\n  window.mpBridge.ready(bridge => {\n    bridge.registerHandler(\"onBackEvent\", (data, done) => {\n      // do something,\n      // 返回true 则直接关闭当前webView，false 则不关闭当前webView\n      done(true)\n    })\n  })\n}\n</code></pre>\n<p>然后，在 native 中监听导航条那个返回按钮的点击事件中，调用 h5 的 onBackEvent，根据结果来决定是否关闭当前 webView。</p>\n<pre><code class=\"language-swift\">/// 导航条返回按钮的点击事件\n@objc private func handleBackTap() {\n    if let bridge = self.bridge {\n        /// 调用h5中注册的onBackEvent函数，\n        bridge.callHandler(\"onBackEvent\") {\n            data in\n            guard let pop = data as? Bool else {\n                return\n            }\n            // 如果为true，则关闭当前webView\n            if pop {\n                self.navigationController?.popViewController(animated: true)\n            }\n        }\n    } else {\n        self.navigationController?.popViewController(animated: true)\n    }\n}\n</code></pre>\n<p>NativeBridge 中的 callHandler 函数实现思路和 h5 中的一样，也是生成一个唯一的 callbackId，然后将回调保存在字典表中，再将消息发送到 h5。</p>\n<pre><code class=\"language-swift\">/// native 端 callHandler的实现\nfunc callHandler(_ name: String, callback: @escaping RequestCallback) {\n    // 生成一个唯一的callbackId\n    let uuid = UUID().uuidString\n    // 将回调保存在字典表中\n    requestHandlersMap[uuid] = callback\n    // 生成一个requestmessage，\n    let requestMessage = RequestMessage(handlerName: name, data: nil, callbackId: uuid)\n    // 然后发送到h5去\n    sendToWeb(requestMessage)\n}\n</code></pre>\n<p>h5 这边通过<code>ClientBridge._handlerMessageFromNative</code> 可以接受这个消息，然后根据 handlerName 查找到 h5 已经注册的接口函数，最后执行并返回数据给 native。</p>\n<pre><code class=\"language-javascript\">// native call web\nvar callback\nif (data.callbackId) {\n  // 如果有callbackId，则要回发结果\n  callback = function(res) {\n    _doSend({ responseId: data.callbackId, responseData: res })\n  }\n} else {\n  // 否则，不处理\n  callback = _noop\n}\nvar handler = callbacksMap[data.handlerName]\nif (typeof handler === \"function\") {\n  handler(data.data, callback)\n} else {\n  console.warn(\"receive unknown message from native:\" + dataString)\n}\n</code></pre>\n\n          <h4 id='toc-4-5' >\n            通信流程图\n          </h4>\n        \n<p><img src=\"./WebViewJavascriptBridge.png\" alt=\"WebViewJavascriptBridge原理图\"></p>\n\n          <h4 id='toc-4-6' >\n            展示截屏图片\n          </h4>\n        \n<p>其实，在 h5 调用 native 中 takeSnapshot 接口后，native 实现了截屏，获得到 UIImage，有两种返回可以返回数据给 h5</p>\n<ol>\n<li>native 直接返回图片的 base64 数据，h5 端直接展示</li>\n<li>native 现将图片存在 cache 目录里，生成一个 src，返回给 h5，h5 请求这个 src 的图片</li>\n</ol>\n<p>其中第一种方式简单，但是图片直接生成的 base64 格式，数据太大，对于传递和调试极为不方便。第二种方式，麻烦一点，生成的 src 又必须是一个约定好的 scheme 格式，native 又通过拦截请求，然后从 cache 目录里拿到图片，作为 response 返回。这次的拦截与 iframe 的拦截方式又不同，是通过<code>WKWebViewConfiguration.setURLSchemeHandler</code>来实现的，具体就不详细讨论了，感兴趣可以查看<a href=\"https://github.com/snayan/MusicPlayer/blob/master/MusicPlayer/Controllers/MPWebViewController.swift#L56-L58\">这里</a>。</p>\n\n          <h4 id='toc-4-7' >\n            小结\n          </h4>\n        \n<p>通过一个例子，详细的讨论了 h5 与 native 之间的通信方式，核心原理如下</p>\n<ul>\n<li>native 可以直接执行 JavaScript 字符串形式执行 js 脚本，与 h5 通信</li>\n<li>native 可以拦截 iframe 的请求，执行 h5 的通信请求</li>\n<li>h5 通过 iframe 来发送数据给 native</li>\n</ul>","tableOfContents":"<ul><li><a href=\"#toc-4-1\">Bridge 的初始化</a><ul></ul></li><li><a href=\"#toc-4-2\">拦截请求</a><ul></ul></li><li><a href=\"#toc-4-3\">H5 调用 native 接口</a><ul></ul></li><li><a href=\"#toc-4-4\">native 调用 h5 接口</a><ul></ul></li><li><a href=\"#toc-4-5\">通信流程图</a><ul></ul></li><li><a href=\"#toc-4-6\">展示截屏图片</a><ul></ul></li><li><a href=\"#toc-4-7\">小结</a><ul></ul></li></ul>","frontmatter":{"title":"理解h5与native(ios)通信细节","date":"December 31, 2018","tags":["h5","bridge"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/understand_the_details_of_h5_and_native(ios)_communication/","previous":{"fields":{"slug":"/post/understand_the_details_of_vritual_dom_snabbdom/"},"frontmatter":{"title":"理解virtual dom的实现细节-snabbdom"}},"next":{"fields":{"slug":"/post/2019/summary_of_2018/"},"frontmatter":{"title":"2018年小结"}}}}